{"Question":{"Data":{"Question":{"questionFrontendId":"4","questionId":"4","Content":"<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n","SampleTestCase":"[1,3]\n[2]","ExampleTestcases":"[1,3]\n[2]\n[1,2]\n[3,4]","Difficulty":"Hard","Title":"Median of Two Sorted Arrays","TitleSlug":"median-of-two-sorted-arrays","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"3.7M\", \"totalSubmission\": \"8.2M\", \"totalAcceptedRaw\": 3665368, \"totalSubmissionRaw\": 8214503, \"acRate\": \"44.6%\"}","Likes":30825,"Dislikes":3464,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEx","Name":"Binary Search","Slug":"binary-search"},{"Id":"VG9waWNUYWdOb2RlOjEy","Name":"Divide and Conquer","Slug":"divide-and-conquer"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        "},{"Lang":"C","LangSlug":"c","Code":"double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Float\n     */\n    function findMedianSortedArrays($nums1, $nums2) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Float}\ndef find_median_sorted_arrays(nums1, nums2)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (find-median-sorted-arrays nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) flonum?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec find_median_sorted_arrays(Nums1 :: [integer()], Nums2 :: [integer()]) -> float().\nfind_median_sorted_arrays(Nums1, Nums2) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float\n  def find_median_sorted_arrays(nums1, nums2) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:54:28.970840189+02:00","AcRate":"44.6","TotalSubmissions":8214503,"TotalAccepted":3665368,"AcceptanceRate":0.4462069099006964,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/median-of-two-sorted-arrays/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array for binary search efficiency\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            # If partitionX is 0 it means nothing is there on left side. Use -inf for maxLeftX\n            # If partitionX is length of input then there is nothing on right side. Use +inf for minRightX\n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n```\n\n=== DESIGN ===\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array for binary search efficiency\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        # Sizes of the arrays\n        x, y = len(nums1), len(nums2)\n        \n        # Binary search on the smaller array\n        low, high = 0, x\n        \n        while low <= high:\n            # Partitioning index for nums1\n            partitionX = (low + high) // 2\n            # Partitioning index for nums2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            # If partitionX is 0 it means nothing is there on left side, use -inf for maxLeftX\n            # If partitionX is x then there is nothing on right side, use +inf for minRightX\n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            # Similarly for nums2\n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            # Check if we've partitioned arrays correctly by comparing four elements\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                # Correct partition is achieved\n                if (x + y) % 2 == 0:\n                    # Even number of elements\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    # Odd number of elements\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                # Move towards left in nums1\n                high = partitionX - 1\n            else:\n                # Move towards right in nums1\n                low = partitionX + 1\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n```\n\n=== VERIFICATION ===\nUpon reviewing the implemented code for the problem of finding the median of two sorted arrays, here is my verification report:\n\n1. **Correctness**: The implemented code correctly applies a binary search approach to solve the problem. It effectively partitions both arrays based on the combined median index, ensuring that elements to the left of the partitions are smaller or equal to those on the right. The solution accounts for both odd and even lengths of combined arrays, returning the median appropriately. The approach compares elements at the boundaries of the partitions to decide whether to adjust the partition in the smaller array.\n\n2. **Edge Cases**: The code handles edge cases such as when the smaller array is empty (by switching arrays) and when the partitions are at the boundaries (by using negative and positive infinity). These conditions ensure that the result is correctly calculated regardless of input sizes or element values.\n\n3. **Complexity**: The time complexity of the solution is O(log(min(m, n))), where `m` and `n` are the sizes of the input arrays. This complexity conforms to the requirement of O(log(m+n)) since the binary search is performed on the smallest array. The space complexity is O(1), as no additional storage is needed beyond a constant number of variables.\n\n4. **Code Quality**: The code is clear, organized, and follows best practices. Variable names are descriptive, making the logic easy to follow. The structure of the code is designed to handle different conditions efficiently, without unnecessary computations.\n\n5. **Test Cases**: Walking through the provided test cases:\n   - Test Case 1 (`nums1 = [1,3], nums2 = [2]`): The merged array is `[1,2,3]`, and the median is `2.0`. The code correctly outputs `2.00000`.\n   - Test Case 2 (`nums1 = [1,2], nums2 = [3,4]`): The merged array is `[1,2,3,4]`, and the median is `(2 + 3) / 2 = 2.5`. The code correctly outputs `2.50000`.\n\n6. **Potential Issues**: There are no observed bugs or logical errors in the solution. The code is robust for the problem constraints, handling minimum, maximum, and boundary condition values efficiently.\n\nFinal Assessment: The solution is correct, meets all requirements for correctness, complexity, edge cases handling, and code quality.\n\nHere is the verified solution without any additions needed:\n\n```python\nfrom typing import List\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n```\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n","Model":"se-gpt-4o","Latency":14161613185,"SolvedAt":"2025-09-07T16:08:41.760111616+02:00","PromptTokens":4768,"OutputTokens":1994}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"4","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n"},"SubmissionId":1762755594,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:34:46.636096857+02:00"}}}
