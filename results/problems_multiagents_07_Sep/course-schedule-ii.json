{"Question":{"Data":{"Question":{"questionFrontendId":"210","questionId":"210","Content":"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n","SampleTestCase":"2\n[[1,0]]","ExampleTestcases":"2\n[[1,0]]\n4\n[[1,0],[2,0],[3,1],[3,2]]\n1\n[]","Difficulty":"Medium","Title":"Course Schedule II","TitleSlug":"course-schedule-ii","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1484645, \"totalSubmissionRaw\": 2746948, \"acRate\": \"54.0%\"}","Likes":11595,"Dislikes":373,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjIx","Name":"Depth-First Search","Slug":"depth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjI0","Name":"Graph","Slug":"graph"},{"Id":"VG9waWNUYWdOb2RlOjI2","Name":"Topological Sort","Slug":"topological-sort"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $numCourses\n     * @param Integer[][] $prerequisites\n     * @return Integer[]\n     */\n    function findOrder($numCourses, $prerequisites) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<int> findOrder(int numCourses, List<List<int>> prerequisites) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func findOrder(numCourses int, prerequisites [][]int) []int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} num_courses\n# @param {Integer[][]} prerequisites\n# @return {Integer[]}\ndef find_order(num_courses, prerequisites)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (find-order numCourses prerequisites)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec find_order(NumCourses :: integer(), Prerequisites :: [[integer()]]) -> [integer()].\nfind_order(NumCourses, Prerequisites) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec find_order(num_courses :: integer, prerequisites :: [[integer]]) :: [integer]\n  def find_order(num_courses, prerequisites) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:50:15.022563367+02:00","AcRate":"54.0","TotalSubmissions":2746948,"TotalAccepted":1484645,"AcceptanceRate":0.5404707333375076,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/course-schedule-ii/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # Create a graph represented by adjacency list\n        graph = defaultdict(list)\n        \n        # Create an array to track the in-degree of each node\n        in_degree = [0] * numCourses\n        \n        # Build the graph and fill the in-degree array\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        # Initialize a queue with all nodes having in-degree of 0 (courses with no prerequisites)\n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        # Initialize an empty list to store the order of courses\n        order = []\n        \n        # Process nodes with in-degree of 0\n        while queue:\n            # Pop the node from the queue and add it to the order\n            course = queue.popleft()\n            order.append(course)\n            \n            # Reduce the in-degree of adjacent nodes by 1\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                # If in-degree becomes 0, add it to the queue\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        # If the order contains all the courses, return the order\n        if len(order) == numCourses:\n            return order\n        # Otherwise, it's impossible to finish all courses due to a cycle\n        return []\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # Create a graph represented by adjacency list\n        graph = defaultdict(list)\n        \n        # Create an array to track the in-degree of each node\n        in_degree = [0] * numCourses\n        \n        # Build the graph and fill the in-degree array\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        # Initialize a queue with all nodes having in-degree of 0 (courses with no prerequisites)\n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        # Initialize an empty list to store the order of courses\n        order = []\n        \n        # Process nodes with in-degree of 0\n        while queue:\n            # Pop the node from the queue and add it to the order\n            course = queue.popleft()\n            order.append(course)\n            \n            # Reduce the in-degree of adjacent nodes by 1\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                # If in-degree becomes 0, add it to the queue\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        # If the order contains all the courses, return the order\n        if len(order) == numCourses:\n            return order\n        # Otherwise, it's impossible to finish all courses due to a cycle\n        return []\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        order = []\n        \n        while queue:\n            course = queue.popleft()\n            order.append(course)\n            \n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(order) == numCourses:\n            return order\n        \n        return []\n```\n\n=== VERIFICATION ===\nLet's review the implemented solution:\n\n1. **Correctness**: The solution correctly implements topological sorting using Kahn's algorithm. It constructs a graph using adjacency lists and calculates in-degrees to identify courses that can be taken without prerequisites. Then, it processes courses with in-degree zero, builds the ordering, and checks if all courses are included in the final order.\n\n2. **Edge Cases**: The solution handles all edge cases:\n   - When `numCourses` is 1 and `prerequisites` is empty, it correctly returns `[0]`.\n   - When `prerequisites` is empty but `numCourses > 1`, it returns a valid list where courses can be taken in any order.\n   - When a cycle is present (making it impossible to complete all courses), it correctly returns an empty list.\n\n3. **Complexity**: The complexity of the solution is efficient given its expected time and space constraints:\n   - **Time complexity** is O(V + E), where V is the number of courses (vertices) and E is the number of prerequisites (edges). This is acceptable given the constraints.\n   - **Space complexity** is O(V + E) due to the graph representation and in-degree array.\n\n4. **Code Quality**: The code is clean, readable, and follows best practices. It uses meaningful variable names and Python's `collections` for efficient graph and queue operations.\n\n5. **Test Cases**: The provided examples are correctly handled by the solution:\n   - Example 1 returns `[0, 1]`.\n   - Example 2 returns `[0, 2, 1, 3]` (or a valid permutation given topological sorting).\n   - Example 3 returns `[0]`.\n\n6. **Potential Issues**: No evident bugs or logical errors are found. The solution correctly checks the presence of cycles and builds course orders accurately.\n\nThe solution is complete, correct, and adheres to best practices. Here's the final code:\n\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        order = []\n        \n        while queue:\n            course = queue.popleft()\n            order.append(course)\n            \n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(order) == numCourses:\n            return order\n        \n        return []\n```\n\n","TypedCode":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        order = []\n        \n        while queue:\n            course = queue.popleft()\n            order.append(course)\n            \n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(order) == numCourses:\n            return order\n        \n        return []\n","Model":"se-gpt-4o","Latency":10922601446,"SolvedAt":"2025-09-07T16:01:41.990150128+02:00","PromptTokens":4958,"OutputTokens":1457}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"210","typed_code":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            in_degree[dest] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        order = []\n        \n        while queue:\n            course = queue.popleft()\n            order.append(course)\n            \n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(order) == numCourses:\n            return order\n        \n        return []\n"},"SubmissionId":1762741811,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:20:45.200503899+02:00"}}}
