{"Question":{"Data":{"Question":{"questionFrontendId":"399","questionId":"399","Content":"<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>\n\n<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>\n\n<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>\n\n<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>\n\n<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>Explanation:</strong> \nGiven: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>\nqueries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined =&gt; -1.0</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>\n</ul>\n","SampleTestCase":"[[\"a\",\"b\"],[\"b\",\"c\"]]\n[2.0,3.0]\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]","ExampleTestcases":"[[\"a\",\"b\"],[\"b\",\"c\"]]\n[2.0,3.0]\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\n[1.5,2.5,5.0]\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n[[\"a\",\"b\"]]\n[0.5]\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]","Difficulty":"Medium","Title":"Evaluate Division","TitleSlug":"evaluate-division","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"635.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 635275, \"totalSubmissionRaw\": 1000885, \"acRate\": \"63.5%\"}","Likes":9936,"Dislikes":1060,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjIx","Name":"Depth-First Search","Slug":"depth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIz","Name":"Union Find","Slug":"union-find"},{"Id":"VG9waWNUYWdOb2RlOjI0","Name":"Graph","Slug":"graph"},{"Id":"VG9waWNUYWdOb2RlOjYxMDc2","Name":"Shortest Path","Slug":"shortest-path"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ndouble* calcEquation(char*** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char*** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string[][]} equations\n * @param {number[]} values\n * @param {string[][]} queries\n * @return {number[]}\n */\nvar calcEquation = function(equations, values, queries) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function calcEquation(equations: string[][], values: number[], queries: string[][]): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String[][] $equations\n     * @param Float[] $values\n     * @param String[][] $queries\n     * @return Float[]\n     */\n    function calcEquation($equations, $values, $queries) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun calcEquation(equations: List<List<String>>, values: DoubleArray, queries: List<List<String>>): DoubleArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<double> calcEquation(List<List<String>> equations, List<double> values, List<List<String>> queries) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String[][]} equations\n# @param {Float[]} values\n# @param {String[][]} queries\n# @return {Float[]}\ndef calc_equation(equations, values, queries)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def calcEquation(equations: List[List[String]], values: Array[Double], queries: List[List[String]]): Array[Double] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (calc-equation equations values queries)\n  (-> (listof (listof string?)) (listof flonum?) (listof (listof string?)) (listof flonum?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec calc_equation(Equations :: [[unicode:unicode_binary()]], Values :: [float()], Queries :: [[unicode:unicode_binary()]]) -> [float()].\ncalc_equation(Equations, Values, Queries) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec calc_equation(equations :: [[String.t]], values :: [float], queries :: [[String.t]]) :: [float]\n  def calc_equation(equations, values, queries) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:50:40.328982829+02:00","AcRate":"63.5","TotalSubmissions":1000885,"TotalAccepted":635275,"AcceptanceRate":0.6347132787483077,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/evaluate-division/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Use a graph representation where each node is a variable and edge weight is the division result.\n        graph = defaultdict(dict)\n        \n        # Building the graph using the given equations and values.\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            # If start or end node is not in the graph, return -1.0\n            if start not in graph or end not in graph:\n                return -1.0\n            # Use BFS to traverse from start node to end node\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        # Evaluate each query using BFS\n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Build a graph based on the equations and values\n        graph = defaultdict(dict)\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            # If either the start or end is not in the graph, return -1\n            if start not in graph or end not in graph:\n                return -1.0\n            \n            # Use BFS to find the path from start to end\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        # Evaluate each query using the BFS function\n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(dict)\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            if start not in graph or end not in graph:\n                return -1.0\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Build a graph based on the equations and values\n        graph = defaultdict(dict)\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            # If either the start or end is not in the graph, return -1.0\n            if start not in graph or end not in graph:\n                return -1.0\n            \n            # Use BFS to find the path from start to end\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        # Evaluate each query using the BFS function\n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n```\n\n","TypedCode":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(dict)\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            if start not in graph or end not in graph:\n                return -1.0\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n","Model":"se-gpt-4o","Latency":8570830147,"SolvedAt":"2025-09-07T16:02:48.714542996+02:00","PromptTokens":5686,"OutputTokens":1117}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"399","typed_code":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(dict)\n        for (start, end), value in zip(equations, values):\n            graph[start][end] = value\n            graph[end][start] = 1 / value\n        \n        def bfs(start, end):\n            if start not in graph or end not in graph:\n                return -1.0\n            queue = deque([(start, 1.0)])\n            visited = set()\n            \n            while queue:\n                current_node, current_value = queue.popleft()\n                if current_node == end:\n                    return current_value\n                visited.add(current_node)\n                \n                for neighbor, weight in graph[current_node].items():\n                    if neighbor not in visited:\n                        queue.append((neighbor, current_value * weight))\n            \n            return -1.0\n        \n        results = []\n        for start, end in queries:\n            results.append(bfs(start, end))\n        \n        return results\n"},"SubmissionId":1762743700,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:22:34.921180077+02:00"}}}
