{"Question":{"Data":{"Question":{"questionFrontendId":"127","questionId":"127","Content":"<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n","SampleTestCase":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]","ExampleTestcases":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]","Difficulty":"Hard","Title":"Word Ladder","TitleSlug":"word-ladder","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1442290, \"totalSubmissionRaw\": 3304016, \"acRate\": \"43.7%\"}","Likes":13047,"Dislikes":1944,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int ladderLength(char* beginWord, char* endWord, char** wordList, int wordListSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return Integer\n     */\n    function ladderLength($beginWord, $endWord, $wordList) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func ladderLength(beginWord string, endWord string, wordList []string) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (ladder-length beginWord endWord wordList)\n  (-> string? string? (listof string?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec ladder_length(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> integer().\nladder_length(BeginWord, EndWord, WordList) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec ladder_length(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: integer\n  def ladder_length(begin_word, end_word, word_list) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:58:54.763613218+02:00","AcRate":"43.7","TotalSubmissions":3304016,"TotalAccepted":1442290,"AcceptanceRate":0.43652633643420613,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/word-ladder/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Ensure endWord is in the wordList\n        if endWord not in wordList:\n            return 0\n\n        wordSet = set(wordList)  # Convert to set for O(1) lookup\n        queue = deque([(beginWord, 1)])  # Store word and length of transformation sequence\n\n        while queue:\n            currentWord, level = queue.popleft()\n\n            # Trying to change every character of currentWord\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)  # Remove to prevent re-visiting\n                        queue.append((nextWord, level + 1))\n\n        return 0  # If queue is exhausted without finding endWord\n```\n\n=== DESIGN ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Ensure endWord is in the wordList\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)  # Convert to set for O(1) lookup\n        queue = deque([(beginWord, 1)])  # Store word and length of transformation sequence\n        \n        while queue:\n            currentWord, level = queue.popleft()\n            # Trying to change every character of currentWord\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)  # Remove to prevent re-visiting\n                        queue.append((nextWord, level + 1))\n        \n        return 0  # If queue is exhausted without finding endWord\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        \n        while queue:\n            currentWord, level = queue.popleft()\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)\n                        queue.append((nextWord, level + 1))\n        \n        return 0\n```\n\n=== VERIFICATION ===\nVerification Report:\n\n1. **Correctness**: \n   - The implemented code accurately follows the description provided. It utilizes Breadth-First Search (BFS) to traverse through possible word transformations, ensuring each word differs by a single letter.\n   - The BFS approach ensures the shortest transformation sequence is found first, as it expands all nodes at the present depth level before moving to the next.\n\n2. **Edge Cases**:\n   - The code begins by checking if the `endWord` is in the `wordList`. If not present, it returns 0 immediately, which correctly handles the edge case.\n   - Handles cases where transformation sequences are possible and correctly returns the length of the shortest sequence.\n\n3. **Complexity**:\n   - **Time Complexity**: For each word, there are 26 possibilities per character position. For a word length of `L`, this leads to around `L * 26` operations per word transformation. Given a `wordList` of size `N`, the complexity becomes approximately `O(N * L * 26)`. This is efficient enough given constraints.\n   - **Space Complexity**: Uses `wordSet` for O(1) lookups and `queue` for BFS, giving a space complexity of `O(N)`.\n\n4. **Code Quality**:\n   - The code is clean and well-structured. It clearly demarcates each step of the BFS logic, uses appropriate data structures (`deque` for BFS, `set` for fast lookup).\n   - Consistent and clear variable names facilitate understanding.\n\n5. **Test Cases**:\n   - Examining both provided test cases, the code performs accurately:\n     - \"hit\" -> \"cog\" with given word list successfully provides a sequence length of 5.\n     - \"hit\" -> \"cog\" with an altered list returns 0 as expected when \"cog\" is missing.\n\n6. **Potential Issues**:\n   - No bugs or logical errors are identified. The code achieves its purpose effectively given the constraints and requirements.\n   - No improvements required unless a new functionality or a different approach is explicitly desired.\n\nConclusion: The solution is correct and adheres to all requirements and constraints. It handles all relevant edge cases, performs efficiently in terms of time and space complexity, and showcases good programming practices. Here is the verified implementation:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        \n        while queue:\n            currentWord, level = queue.popleft()\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)\n                        queue.append((nextWord, level + 1))\n        \n        return 0\n```\n\n","TypedCode":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        \n        while queue:\n            currentWord, level = queue.popleft()\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)\n                        queue.append((nextWord, level + 1))\n        \n        return 0\n","Model":"se-gpt-4o","Latency":10273087181,"SolvedAt":"2025-09-07T16:14:43.049594691+02:00","PromptTokens":4224,"OutputTokens":1298}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"127","typed_code":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        \n        while queue:\n            currentWord, level = queue.popleft()\n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    \n                    if nextWord == endWord:\n                        return level + 1\n                    \n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)\n                        queue.append((nextWord, level + 1))\n        \n        return 0\n"},"SubmissionId":1762768086,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:48:26.06760961+02:00"}}}
