{"Question":{"Data":{"Question":{"questionFrontendId":"76","questionId":"76","Content":"<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n","SampleTestCase":"\"ADOBECODEBANC\"\n\"ABC\"","ExampleTestcases":"\"ADOBECODEBANC\"\n\"ABC\"\n\"a\"\n\"a\"\n\"a\"\n\"aa\"","Difficulty":"Hard","Title":"Minimum Window Substring","TitleSlug":"minimum-window-substring","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 1875320, \"totalSubmissionRaw\": 4080310, \"acRate\": \"46.0%\"}","Likes":19379,"Dislikes":818,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjU1ODIx","Name":"Sliding Window","Slug":"sliding-window"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        "},{"Lang":"C","LangSlug":"c","Code":"char* minWindow(char* s, char* t) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public string MinWindow(string s, string t) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function minWindow(s: string, t: string): string {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return String\n     */\n    function minWindow($s, $t) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun minWindow(s: String, t: String): String {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  String minWindow(String s, String t) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func minWindow(s string, t string) string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} s\n# @param {String} t\n# @return {String}\ndef min_window(s, t)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def minWindow(s: String, t: String): String = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (min-window s t)\n  (-> string? string? string?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec min_window(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmin_window(S, T) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec min_window(s :: String.t, t :: String.t) :: String.t\n  def min_window(s, t) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:55:34.960114811+02:00","AcRate":"46.0","TotalSubmissions":4080310,"TotalAccepted":1875320,"AcceptanceRate":0.4596023341363769,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/minimum-window-substring/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        # Dictionary to hold the count of all characters in t\n        target_count = Counter(t)\n        # Number of unique characters in t that must be present in the windows substring\n        required_chars = len(target_count)\n\n        # Dictionary to hold the count of all characters in current window in s\n        window_count = defaultdict(int)\n        # Number of unique characters in current window which match the required count in t\n        formed_chars = 0\n        \n        # Start and end pointers\n        l = 0\n        r = 0\n\n        # Result variables to keep track of the minimum window length and window indexes\n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n\n        while r < len(s):\n            # Add one character into the window from the right\n            character = s[r]\n            window_count[character] += 1\n\n            # If the current window's character count matches the target's character count\n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n\n            # Try and contract the window till it ceases to be 'desirable'\n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                # Update the result if this window is smaller\n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left, min_right = l, r\n                \n                # Current character is going out of window\n                window_count[character] -= 1\n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n\n                # Move the left pointer to reduce window size\n                l += 1\n\n            # Expand the window as long as it is necessary\n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n```\n\n=== DESIGN ===\n```python\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        # Counter for characters in t\n        target_count = Counter(t)\n        required_chars = len(target_count)\n        \n        # Counter for characters in the current window of s\n        window_count = defaultdict(int)\n        \n        # Variables to track the number of characters that fulfill the requirement\n        formed_chars = 0\n        \n        # Left and Right pointers define the current window in s\n        l = 0\n        r = 0\n        \n        # Variables to track the minimum window substring\n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n        \n        while r < len(s):\n            # Add character from the right to the window\n            character = s[r]\n            window_count[character] += 1\n            \n            # If the character matches the target count in t\n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n            \n            # Contract the window until it is no longer valid\n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                # Update the minimum window substring\n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left = l\n                    min_right = r\n                \n                # Remove the character from the left of the window\n                window_count[character] -= 1\n                \n                # Update formed_chars if the window no longer fulfills the requirement\n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n                \n                # Move the left pointer forward\n                l += 1\n            \n            # Move the right pointer forward\n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        target_count = Counter(t)\n        required_chars = len(target_count)\n        window_count = defaultdict(int)\n        formed_chars = 0\n        \n        l = 0\n        r = 0\n        \n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n        \n        while r < len(s):\n            character = s[r]\n            window_count[character] += 1\n            \n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n            \n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left = l\n                    min_right = r\n                \n                window_count[character] -= 1\n                \n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n                \n                l += 1\n            \n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n```\n\n=== VERIFICATION ===\nHere is the verification report for the provided solution:\n\n**1. Correctness**:  \nThe algorithm correctly implements the sliding window technique to find the minimum window substring that contains all the characters of `t` in `s`. The logic keeps track of character counts using a `window_count` dictionary and checks if the window is valid based on character requirements with `formed_chars`. The `while` loops are properly structured to manage window expansion and contraction.\n\n**2. Edge Cases**:  \n- The solution correctly handles the edge case when `t` has more characters than `s`, returning `\"\"` as expected.  \n- When `t` is longer than `s` or characters in `t` are not all present in `s`, the solution outputs `\"\"`.  \n- It correctly checks for empty input strings and returns `\"\"` if either `t` or `s` is empty.\n\n**3. Complexity**:  \nThe algorithm efficiently runs in O(m + n) time complexity where m is the length of `s` and n is the length of `t`. This is achieved through a single pass with two pointers over the string `s`. The space complexity is mainly dependent on the size of the character set, which in the worst-case scenario is O(1), always manageable since it is limited to the English alphabet.\n\n**4. Code Quality**:  \nThe code is clean and readable, utilizing appropriate data structures (`Counter`, `defaultdict`) to manage character counts. It follows Python best practices and uses descriptive variable names, making the code easy to follow.\n\n**5. Test Cases**:  \n- **Example 1**: With input `s = \"ADOBECODEBANC\"` and `t = \"ABC\"`, the expected output is `\"BANC\"`, which matches the output of the code.\n- **Example 2**: With input `s = \"a\"` and `t = \"a\"`, the expected output is `\"a\"`, matching the output.\n- **Example 3**: With input `s = \"a\"` and `t = \"aa\"`, the expected output is `\"\"`, correctly handled by the code.\n\n**6. Potential Issues**:  \nNo logical errors, bugs, or improvements are necessary for this implementation. The solution is efficient and covers all edge cases.\n\nThe solution is validated and confirmed to be correct given the problem constraints and requirements. Here is the provided code snippet:\n\n```python\nfrom collections import Counter, defaultdict\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        target_count = Counter(t)\n        required_chars = len(target_count)\n        window_count = defaultdict(int)\n        formed_chars = 0\n        \n        l = 0\n        r = 0\n        \n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n        \n        while r < len(s):\n            character = s[r]\n            window_count[character] += 1\n            \n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n            \n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left = l\n                    min_right = r\n                \n                window_count[character] -= 1\n                \n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n                \n                l += 1\n            \n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n```\n\n","TypedCode":"\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        target_count = Counter(t)\n        required_chars = len(target_count)\n        window_count = defaultdict(int)\n        formed_chars = 0\n        \n        l = 0\n        r = 0\n        \n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n        \n        while r < len(s):\n            character = s[r]\n            window_count[character] += 1\n            \n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n            \n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left = l\n                    min_right = r\n                \n                window_count[character] -= 1\n                \n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n                \n                l += 1\n            \n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n","Model":"se-gpt-4o","Latency":14876678037,"SolvedAt":"2025-09-07T16:09:50.222718939+02:00","PromptTokens":4981,"OutputTokens":1925}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"76","typed_code":"\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n        \n        target_count = Counter(t)\n        required_chars = len(target_count)\n        window_count = defaultdict(int)\n        formed_chars = 0\n        \n        l = 0\n        r = 0\n        \n        min_len = float(\"inf\")\n        min_left = 0\n        min_right = 0\n        \n        while r < len(s):\n            character = s[r]\n            window_count[character] += 1\n            \n            if character in target_count and window_count[character] == target_count[character]:\n                formed_chars += 1\n            \n            while l <= r and formed_chars == required_chars:\n                character = s[l]\n                \n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    min_left = l\n                    min_right = r\n                \n                window_count[character] -= 1\n                \n                if character in target_count and window_count[character] < target_count[character]:\n                    formed_chars -= 1\n                \n                l += 1\n            \n            r += 1\n        \n        return \"\" if min_len == float(\"inf\") else s[min_left:min_right + 1]\n"},"SubmissionId":1762757979,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:37:19.23628469+02:00"}}}
