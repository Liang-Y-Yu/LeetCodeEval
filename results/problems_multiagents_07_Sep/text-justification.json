{"Question":{"Data":{"Question":{"questionFrontendId":"68","questionId":"68","Content":"<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n","SampleTestCase":"[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n16","ExampleTestcases":"[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n16\n[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n16\n[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n20","Difficulty":"Hard","Title":"Text Justification","TitleSlug":"text-justification","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"574.4K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 574430, \"totalSubmissionRaw\": 1173451, \"acRate\": \"49.0%\"}","Likes":4297,"Dislikes":5215,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjYxMDU1","Name":"Simulation","Slug":"simulation"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fullJustify(char** words, int wordsSize, int maxWidth, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<string> FullJustify(string[] words, int maxWidth) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function fullJustify(words: string[], maxWidth: number): string[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String[] $words\n     * @param Integer $maxWidth\n     * @return String[]\n     */\n    function fullJustify($words, $maxWidth) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<String> fullJustify(List<String> words, int maxWidth) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func fullJustify(words []string, maxWidth int) []string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String[]} words\n# @param {Integer} max_width\n# @return {String[]}\ndef full_justify(words, max_width)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (full-justify words maxWidth)\n  (-> (listof string?) exact-integer? (listof string?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec full_justify(Words :: [unicode:unicode_binary()], MaxWidth :: integer()) -> [unicode:unicode_binary()].\nfull_justify(Words, MaxWidth) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec full_justify(words :: [String.t], max_width :: integer) :: [String.t]\n  def full_justify(words, max_width) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T15:57:30.550161322+02:00","AcRate":"49.0","TotalSubmissions":1173451,"TotalAccepted":574430,"AcceptanceRate":0.48952193146539563,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/text-justification/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                # Just join the words for the last line, separated by spaces\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength  # Total spaces to distribute\n            gapCount = len(line) - 1  # Number of gaps between words\n            \n            # Calculate minimum spaces and extra spaces to distribute\n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                # If adding the new word exceeds maxWidth, justify the current line\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []  # Reset currentLine\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        # Justify the last line\n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength\n            gapCount = len(line) - 1\n            \n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength\n            gapCount = len(line) - 1\n            \n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n```\n\n=== VERIFICATION ===\n# Verification Report\n\nLet's conduct a thorough review of the implemented solution for the text justification problem.\n\n### Correctness\n\nThe code correctly implements the algorithm for text justification. It processes the input words and formats them into lines with full and even justification as well as handling the last line with left justification. The line justification logic distributes spaces evenly between words, allocating more spaces to slots on the left when necessary.\n\n### Edge Cases\n\nThe solution handles edge cases well:\n1. Words with varying lengths are packed into lines without exceeding `maxWidth`.\n2. Proper functionality for cases where a line consists of a single word, ensuring it is left justified.\n3. Handles the case where the last line is left justified without extra spaces between words.\n\n### Complexity\n\nThe solution has a time complexity of O(n * m), where n is the number of words and m is the maximum length of the words. This complexity is acceptable given the constraint that `words.length <= 300` and `maxWidth <= 100`. Space complexity is also managed well within the constraints, using constant space overhead and storage proportional to the result.\n\n### Code Quality\n\nThe code is clean and readable:\n- Well-named functions and variables facilitate understanding.\n- Logical structure flows well, focusing on the collection and processing of words into justified lines.\n- Proper use of helper functions to separate line processing logic from the main word packing.\n\n### Test Cases\n\nWalking through the provided examples:\n1. Example 1 correctly formats each line, particularly distributing spaces appropriately.\n2. Example 2 demonstrates proper handling of lines with single words and last line justification.\n3. Example 3 verifies the solution's capability to pack multiple words and lines, properly justifying except the last line, which is left justified.\n\n### Potential Issues\n\nNo logical errors or code bugs were identified. The implemented solution fulfills the problem statement requirements effectively.\n\n### Conclusion\n\nThe verified solution is accurate, efficient, and cleanly written. It meets all the requirements and handles both regular and edge cases correctly. Therefore, the solution is valid and ready for deployment.\n\nHere is the final code:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength\n            gapCount = len(line) - 1\n            \n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n```\n\nThis solution can be confidently used for text justification tasks as specified in the problem statement.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength\n            gapCount = len(line) - 1\n            \n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n","Model":"se-gpt-4o","Latency":12964827294,"SolvedAt":"2025-09-07T16:13:23.972961663+02:00","PromptTokens":5672,"OutputTokens":1676}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"68","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justifyLine(line, lineLength, maxWidth, isLastLine):\n            if isLastLine or len(line) == 1:\n                return ' '.join(line).ljust(maxWidth)\n            \n            totalSpace = maxWidth - lineLength\n            gapCount = len(line) - 1\n            \n            avgSpace = totalSpace // gapCount\n            extraSpace = totalSpace % gapCount\n            \n            justifiedLine = ''\n            for i, word in enumerate(line):\n                justifiedLine += word\n                if i < gapCount:\n                    justifiedLine += ' ' * (avgSpace + (1 if extraSpace > 0 else 0))\n                    extraSpace -= 1\n            \n            return justifiedLine\n        \n        currentLine = []\n        currentLineLength = 0\n        result = []\n        \n        for word in words:\n            if currentLineLength + len(word) + len(currentLine) > maxWidth:\n                result.append(justifyLine(currentLine, currentLineLength, maxWidth, False))\n                currentLine = []\n                currentLineLength = 0\n            \n            currentLine.append(word)\n            currentLineLength += len(word)\n        \n        result.append(justifyLine(currentLine, currentLineLength, maxWidth, True))\n        \n        return result\n"},"SubmissionId":1762765340,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T16:45:29.10970633+02:00"}}}
