{"Question":{"Data":{"Question":{"questionFrontendId":"1268","questionId":"1397","Content":"<p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p>\n\n<p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>\n\n<p>Return <em>a list of lists of the suggested products after each character of </em><code>searchWord</code><em> is typed</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;\n<strong>Output:</strong> [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]\n<strong>Explanation:</strong> products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;].\nAfter typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;].\nAfter typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> products = [&quot;havana&quot;], searchWord = &quot;havana&quot;\n<strong>Output:</strong> [[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]\n<strong>Explanation:</strong> The only word &quot;havana&quot; will be always suggested while typing the search word.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= products.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= products[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(products[i].length) &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>All the strings of <code>products</code> are <strong>unique</strong>.</li>\n\t<li><code>products[i]</code> consists of lowercase English letters.</li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>\n\t<li><code>searchWord</code> consists of lowercase English letters.</li>\n</ul>\n","SampleTestCase":"[\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"]\n\"mouse\"","ExampleTestcases":"[\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"]\n\"mouse\"\n[\"havana\"]\n\"havana\"","Difficulty":"Medium","Title":"Search Suggestions System","TitleSlug":"search-suggestions-system","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"407.5K\", \"totalSubmission\": \"626.1K\", \"totalAcceptedRaw\": 407463, \"totalSubmissionRaw\": 626125, \"acRate\": \"65.1%\"}","Likes":5037,"Dislikes":260,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjEx","Name":"Binary Search","Slug":"binary-search"},{"Id":"VG9waWNUYWdOb2RlOjI3","Name":"Trie","Slug":"trie"},{"Id":"VG9waWNUYWdOb2RlOjYxMDQ5","Name":"Sorting","Slug":"sorting"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** suggestedProducts(char** products, int productsSize, char* searchWord, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<IList<string>> SuggestedProducts(string[] products, string searchWord) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string[]} products\n * @param {string} searchWord\n * @return {string[][]}\n */\nvar suggestedProducts = function(products, searchWord) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function suggestedProducts(products: string[], searchWord: string): string[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String[] $products\n     * @param String $searchWord\n     * @return String[][]\n     */\n    function suggestedProducts($products, $searchWord) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func suggestedProducts(_ products: [String], _ searchWord: String) -> [[String]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun suggestedProducts(products: Array<String>, searchWord: String): List<List<String>> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<String>> suggestedProducts(List<String> products, String searchWord) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func suggestedProducts(products []string, searchWord string) [][]string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String[]} products\n# @param {String} search_word\n# @return {String[][]}\ndef suggested_products(products, search_word)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def suggestedProducts(products: Array[String], searchWord: String): List[List[String]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn suggested_products(products: Vec<String>, search_word: String) -> Vec<Vec<String>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (suggested-products products searchWord)\n  (-> (listof string?) string? (listof (listof string?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec suggested_products(Products :: [unicode:unicode_binary()], SearchWord :: unicode:unicode_binary()) -> [[unicode:unicode_binary()]].\nsuggested_products(Products, SearchWord) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec suggested_products(products :: [String.t], search_word :: String.t) :: [[String.t]]\n  def suggested_products(products, search_word) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:35:53.349852582+02:00","AcRate":"65.1","TotalSubmissions":626125,"TotalAccepted":407463,"AcceptanceRate":0.6507694150529048,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/search-suggestions-system/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            suggestions = []\n            start_index = self.binarySearch(products, prefix)\n            \n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n            \n            result.append(suggestions)\n        \n        return result\n    \n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n        \n        while low < high:\n            mid = (low + high) // 2\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low\n```\n\n=== DESIGN ===\n```python\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        # Sort the products lexicographically\n        products.sort()\n        result = []\n        prefix = \"\"\n\n        for char in searchWord:\n            prefix += char\n            # Use binary search to find the starting index of the products that match the current prefix\n            start_index = self.binarySearch(products, prefix)\n            suggestions = []\n\n            # Iterate over the products starting from the found index\n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n\n            result.append(suggestions)\n\n        return result\n\n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n\n        while low < high:\n            mid = (low + high) // 2\n            # Compare the mid product against the prefix\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n\n        return low\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        for char in searchWord:\n            prefix += char\n            start_index = self.binarySearch(products, prefix)\n            suggestions = []\n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n            result.append(suggestions)\n        return result\n    \n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n        while low < high:\n            mid = (low + high) // 2\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n```\n\n=== VERIFICATION ===\nThe implemented solution is as follows:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            suggestions = []\n            start_index = self.binarySearch(products, prefix)\n            \n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n            \n            result.append(suggestions)\n        \n        return result\n    \n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n        \n        while low < high:\n            mid = (low + high) // 2\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low\n```\n\nVerification Report:\n\n1. **Correctness**: The solution correctly implements the designed algorithm. It performs a binary search to efficiently find the starting index of products that match the current prefix. It then gathers up to three lexicographically smallest suggestions for that prefix.\n\n2. **Edge Cases**: The solution should handle all edge cases, including:\n   - An empty list for products.\n   - A `searchWord` that doesn't match any products.\n   - Products of varying lengths.\n   The current constraints suggest these edge cases are either accounted for or not applicable due to constraints like non-zero lengths.\n\n3. **Complexity**:\n   - Time Complexity: The sorting part takes \\(O(N \\log N)\\), where \\(N\\) is the number of products. Since each prefix character requires traversing through the possible suggestions, the total complexity is approximately \\(O(M \\cdot N)\\), where \\(M\\) is the length of the searchWord. Given constraints, this is efficient.\n   - Space Complexity: The space used is primarily for the results list, which is manageable given input constraints.\n\n4. **Code Quality**: The code is clean, well-organized, and adheres to Python best practices. It makes good use of helper functions and is readable.\n\n5. **Test Cases**: The provided test cases are successfully passed:\n   - For products `[\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"]` and searchWord `\"mouse\"`, it returns `[['mobile','moneypot','monitor'],['mobile','moneypot','monitor'],['mouse','mousepad'],['mouse','mousepad'],['mouse','mousepad']]`.\n   - For products `[\"havana\"]` and searchWord `\"havana\"`, it correctly returns `[['havana'],['havana'],['havana'],['havana'],['havana'],['havana']]`.\n\n6. **Potential Issues**: No bugs or logical errors were identified. The binary search is correctly used for prefix matching optimization. \n\nConclusion: The solution is correct, efficient given constraints, and exhibits good coding practices.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        for char in searchWord:\n            prefix += char\n            start_index = self.binarySearch(products, prefix)\n            suggestions = []\n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n            result.append(suggestions)\n        return result\n    \n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n        while low < high:\n            mid = (low + high) // 2\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n","Model":"se-gpt-4o","Latency":15641056617,"SolvedAt":"2025-09-05T23:53:55.760659865+02:00","PromptTokens":4192,"OutputTokens":1242}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"1397","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        for char in searchWord:\n            prefix += char\n            start_index = self.binarySearch(products, prefix)\n            suggestions = []\n            for i in range(start_index, len(products)):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                if len(suggestions) == 3:\n                    break\n            result.append(suggestions)\n        return result\n    \n    def binarySearch(self, products, prefix):\n        low, high = 0, len(products)\n        while low < high:\n            mid = (low + high) // 2\n            if products[mid] < prefix:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n"},"SubmissionId":1760938128,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:24:51.778922532+02:00"}}}
