{"Question":{"Data":{"Question":{"questionFrontendId":"207","questionId":"207","Content":"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n","SampleTestCase":"2\n[[1,0]]","ExampleTestcases":"2\n[[1,0]]\n2\n[[1,0],[0,1]]","Difficulty":"Medium","Title":"Course Schedule","TitleSlug":"course-schedule","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"4.5M\", \"totalAcceptedRaw\": 2244020, \"totalSubmissionRaw\": 4499772, \"acRate\": \"49.9%\"}","Likes":17417,"Dislikes":831,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjIx","Name":"Depth-First Search","Slug":"depth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjI0","Name":"Graph","Slug":"graph"},{"Id":"VG9waWNUYWdOb2RlOjI2","Name":"Topological Sort","Slug":"topological-sort"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        "},{"Lang":"C","LangSlug":"c","Code":"bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nvar canFinish = function(numCourses, prerequisites) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $numCourses\n     * @param Integer[][] $prerequisites\n     * @return Boolean\n     */\n    function canFinish($numCourses, $prerequisites) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  bool canFinish(int numCourses, List<List<int>> prerequisites) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func canFinish(numCourses int, prerequisites [][]int) bool {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} num_courses\n# @param {Integer[][]} prerequisites\n# @return {Boolean}\ndef can_finish(num_courses, prerequisites)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (can-finish numCourses prerequisites)\n  (-> exact-integer? (listof (listof exact-integer?)) boolean?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec can_finish(NumCourses :: integer(), Prerequisites :: [[integer()]]) -> boolean().\ncan_finish(NumCourses, Prerequisites) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec can_finish(num_courses :: integer, prerequisites :: [[integer]]) :: boolean\n  def can_finish(num_courses, prerequisites) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:28:11.944298302+02:00","AcRate":"49.9","TotalSubmissions":4499772,"TotalAccepted":2244020,"AcceptanceRate":0.4986963783942831,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/course-schedule/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Create a graph as an adjacency list and an in-degree array\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        # Populate the graph and in-degree array based on prerequisites\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        # Use a queue to track courses with no prerequisites\n        queue = []\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        # Count of courses we can take\n        courses_taken = 0\n        \n        # Process the courses in the queue\n        while queue:\n            course = queue.pop(0)\n            courses_taken += 1\n            \n            # Reduce in-degree of adjacent courses by 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                # If in-degree becomes zero, add to queue\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        # If we have been able to take all courses, return True\n        return courses_taken == numCourses\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Step 1: Create graph as adjacency list and in-degree count\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        # Populate the graph and in-degree list based on prerequisites\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        # Step 2: Initialize queue with courses with no prerequisites\n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        # Step 3: Process courses with no prerequisites\n        courses_taken = 0\n        \n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            # Reduce in-degree of adjacent courses\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        # Step 4: Check if all courses have been taken\n        return courses_taken == numCourses\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        courses_taken = 0\n        \n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        return courses_taken == numCourses\n```\n\n=== VERIFICATION ===\nVerification Report:\n\n1. **Correctness**: The code correctly implements the topological sort algorithm using a queue initialized with courses that have no prerequisites. It processes each course by decrementing the in-degree of dependent courses and ensures that all courses can be taken if there are no cycles. This implementation is correct and closely follows the strategy outlined in the problem analysis.\n\n2. **Edge Cases**: The code handles various edge cases, such as:\n   - No prerequisites at all (the queue will initially contain all courses).\n   - Cyclic dependencies (detected by the fact that not all courses can be taken).\n   - Large input sizes within the provided constraints.\n\n3. **Complexity**: The time complexity of the solution is O(V + E), where V is the number of courses (vertices), and E is the number of prerequisite pairs (edges). This is optimal for problems involving graph traversal. The space complexity is O(V + E) to store the graph and in-degree arrays, which aligns with expectations given the constraints.\n\n4. **Code Quality**: The code is clean and well-structured. It uses Python's `collections.deque` for efficient queue operations and employs list comprehensions effectively. The variable names are descriptive, improving readability. The code follows Python best practices without redundant operations or statements.\n\n5. **Test Cases**: The code successfully handles the provided test cases:\n   - Example 1: It correctly returns `true` for a scenario where courses can be completed.\n   - Example 2: It correctly returns `false` for a scenario with cyclic dependencies.\n\n6. **Potential Issues**: There are no evident bugs or logical errors. The algorithm handles all prerequisites and edge cases efficiently within given constraints. No improvements are necessary as the code is already optimal.\n\nConclusion: The implementation is correct, efficient, and adheres to good coding practices. It successfully meets all problem requirements and constraints. The solution is valid and complete.\n\n```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        courses_taken = 0\n        \n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        return courses_taken == numCourses\n```\n\n","TypedCode":"\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        courses_taken = 0\n        \n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        return courses_taken == numCourses\n","Model":"se-gpt-4o","Latency":10580757908,"SolvedAt":"2025-09-05T23:43:00.167263394+02:00","PromptTokens":4214,"OutputTokens":1328}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"207","typed_code":"\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = {i: [] for i in range(numCourses)}\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        courses_taken = 0\n        \n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        return courses_taken == numCourses\n"},"SubmissionId":1760930294,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:03:32.677659202+02:00"}}}
