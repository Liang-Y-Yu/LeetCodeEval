{"Question":{"Data":{"Question":{"questionFrontendId":"279","questionId":"279","Content":"<p>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 12\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 12 = 4 + 4 + 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 13 = 4 + 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n","SampleTestCase":"12","ExampleTestcases":"12\n13","Difficulty":"Medium","Title":"Perfect Squares","TitleSlug":"perfect-squares","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"991.3K\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 991333, \"totalSubmissionRaw\": 1773031, \"acRate\": \"55.9%\"}","Likes":11640,"Dislikes":485,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjg=","Name":"Math","Slug":"math"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int numSquares(int n) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int numSquares(int n) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def numSquares(self, n: int) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int numSquares(int n) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int NumSquares(int n) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} n\n * @return {number}\n */\nvar numSquares = function(n) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function numSquares(n: number): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numSquares($n) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func numSquares(_ n: Int) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun numSquares(n: Int): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int numSquares(int n) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func numSquares(n int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} n\n# @return {Integer}\ndef num_squares(n)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def numSquares(n: Int): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn num_squares(n: i32) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (num-squares n)\n  (-> exact-integer? exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec num_squares(N :: integer()) -> integer().\nnum_squares(N) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec num_squares(n :: integer) :: integer\n  def num_squares(n) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:34:50.92965695+02:00","AcRate":"55.9","TotalSubmissions":1773031,"TotalAccepted":991333,"AcceptanceRate":0.5591176916816457,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/perfect-squares/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # Prepare list of perfect squares <= n\n        squares = []\n        for i in range(1, int(math.sqrt(n)) + 1):\n            squares.append(i * i)\n        \n        # BFS initialization\n        queue = deque([(n, 0)])  # (remaining value, steps)\n        visited = set()\n        visited.add(n)\n        \n        # BFS process\n        while queue:\n            current, steps = queue.popleft()\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n\n        return n  # Fallback return, shouldn't reach here given problem constraints\n```\n\n=== DESIGN ===\n```python\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # Step 1: Prepare a list of perfect squares less than or equal to n\n        squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]\n        \n        # Step 2: Initialize BFS queue and visited set\n        queue = deque([(n, 0)])  # (current value, number of steps)\n        visited = set()\n        visited.add(n)\n        \n        # Step 3: Perform BFS\n        while queue:\n            current, steps = queue.popleft()\n            # Step 4: Explore subtraction of perfect squares from current\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n        \n        # The function should never reach here due to the constraints\n        return n\n```\n\n=== IMPLEMENTATION ===\n```python\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]\n        queue = deque([(n, 0)])\n        visited = set()\n        visited.add(n)\n        \n        while queue:\n            current, steps = queue.popleft()\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n        \n        return n\n```\n\n=== VERIFICATION ===\nThe following verification report outlines the assessment of the given code snippet to determine its correctness, efficiency, readability, and adherence to coding best practices:\n\n1. **Correctness**:\n   - The code correctly implements the Breadth-First Search (BFS) algorithm to find the least number of perfect square numbers that sum to the given integer `n`.\n   - It efficiently generates all perfect squares less than or equal to `n` and uses them to construct combinations that yield the target sum using BFS.\n\n2. **Edge Cases**:\n   - The code handles edge cases effectively:\n     - Small values of `n`, such as `n = 1`, correctly return `1` because `1` itself is a perfect square.\n     - Larger values within the constraint (up to `n = 10,000`) are supported by the algorithm's breadth-first traversal strategy.\n\n3. **Complexity**:\n   - The BFS approach is inherently designed to explore possibilities level by level, which typically ensures that the first occurrence of a zero remainder represents the minimal steps needed. This strategy offers a reasonable balance between time and space complexity for the problem constraints.\n   - The algorithm has a time complexity of approximately \\( O(S \\cdot n) \\), where \\( S \\) is the number of perfect squares less than or equal to `n`. Given \\( S \\approx \\sqrt{n} \\), the complexity is manageable within the problem's constraints.\n\n4. **Code Quality**:\n   - The code is clean, readable, and follows Python best practices:\n     - Use of list comprehension for generating perfect squares.\n     - Use of a deque for an efficient FIFO queue in BFS.\n     - Use of a set for fast membership testing to avoid unnecessary processing of nodes.\n\n5. **Test Cases**:\n   - The examples provided (`n = 12` and `n = 13`) are correctly solved by this code:\n     - For `n = 12`, the output is `3` (using 4 + 4 + 4).\n     - For `n = 13`, the output is `2` (using 4 + 9).\n\n6. **Potential Issues**:\n   - No logical errors, bugs, or major improvements were identified. The design and implementation are sound as far as the provided problem and constraints are concerned.\n\nOutputting valid Python code that can be executed without further improvements or fixes:\n```python\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]\n        queue = deque([(n, 0)])\n        visited = set()\n        visited.add(n)\n        \n        while queue:\n            current, steps = queue.popleft()\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n        \n        return n\n```\nThis code snippet is valid, functional, and aligns with the requirements given by the problem statement.\n\n","TypedCode":"\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]\n        queue = deque([(n, 0)])\n        visited = set()\n        visited.add(n)\n        \n        while queue:\n            current, steps = queue.popleft()\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n        \n        return n\n","Model":"se-gpt-4o","Latency":11657657317,"SolvedAt":"2025-09-05T23:52:26.527980219+02:00","PromptTokens":3288,"OutputTokens":1262}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"279","typed_code":"\nimport math\nfrom collections import deque\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]\n        queue = deque([(n, 0)])\n        visited = set()\n        visited.add(n)\n        \n        while queue:\n            current, steps = queue.popleft()\n            for square in squares:\n                next_value = current - square\n                if next_value < 0:\n                    break\n                if next_value == 0:\n                    return steps + 1\n                if next_value not in visited:\n                    visited.add(next_value)\n                    queue.append((next_value, steps + 1))\n        \n        return n\n"},"SubmissionId":1760937117,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:21:57.083867634+02:00"}}}
