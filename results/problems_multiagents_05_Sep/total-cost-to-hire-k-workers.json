{"Question":{"Data":{"Question":{"questionFrontendId":"2462","questionId":"2553","Content":"<p>You are given a <strong>0-indexed</strong> integer array <code>costs</code> where <code>costs[i]</code> is the cost of hiring the <code>i<sup>th</sup></code> worker.</p>\n\n<p>You are also given two integers <code>k</code> and <code>candidates</code>. We want to hire exactly <code>k</code> workers according to the following rules:</p>\n\n<ul>\n\t<li>You will run <code>k</code> sessions and hire exactly one worker in each session.</li>\n\t<li>In each hiring session, choose the worker with the lowest cost from either the first <code>candidates</code> workers or the last <code>candidates</code> workers. Break the tie by the smallest index.\n\t<ul>\n\t\t<li>For example, if <code>costs = [3,2,7,7,1,2]</code> and <code>candidates = 2</code>, then in the first hiring session, we will choose the <code>4<sup>th</sup></code> worker because they have the lowest cost <code>[<u>3,2</u>,7,7,<u><strong>1</strong>,2</u>]</code>.</li>\n\t\t<li>In the second hiring session, we will choose <code>1<sup>st</sup></code> worker because they have the same lowest cost as <code>4<sup>th</sup></code> worker but they have the smallest index <code>[<u>3,<strong>2</strong></u>,7,<u>7,2</u>]</code>. Please note that the indexing may be changed in the process.</li>\n\t</ul>\n\t</li>\n\t<li>If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.</li>\n\t<li>A worker can only be chosen once.</li>\n</ul>\n\n<p>Return <em>the total cost to hire exactly </em><code>k</code><em> workers.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [<u>17,12,10,2</u>,7,<u>2,11,20,8</u>]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from [<u>17,12,10,7</u>,<u>2,11,20,8</u>]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from [<u>17,12,10,7,11,20,8</u>]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [1,2,4,1], k = 3, candidates = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [<u>1,2,4,1</u>]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from [<u>2,4,1</u>]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [<u>2,4</u>]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= costs.length &lt;= 10<sup>5 </sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>\n</ul>\n","SampleTestCase":"[17,12,10,2,7,2,11,20,8]\n3\n4","ExampleTestcases":"[17,12,10,2,7,2,11,20,8]\n3\n4\n[1,2,4,1]\n3\n3","Difficulty":"Medium","Title":"Total Cost to Hire K Workers","TitleSlug":"total-cost-to-hire-k-workers","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"148.3K\", \"totalSubmission\": \"342.3K\", \"totalAcceptedRaw\": 148285, \"totalSubmissionRaw\": 342283, \"acRate\": \"43.3%\"}","Likes":2035,"Dislikes":720,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjk=","Name":"Two Pointers","Slug":"two-pointers"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"},{"Id":"VG9waWNUYWdOb2RlOjYxMDU1","Name":"Simulation","Slug":"simulation"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public long totalCost(int[] costs, int k, int candidates) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def totalCost(self, costs, k, candidates):\n        \"\"\"\n        :type costs: List[int]\n        :type k: int\n        :type candidates: int\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"long long totalCost(int* costs, int costsSize, int k, int candidates) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public long TotalCost(int[] costs, int k, int candidates) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} costs\n * @param {number} k\n * @param {number} candidates\n * @return {number}\n */\nvar totalCost = function(costs, k, candidates) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function totalCost(costs: number[], k: number, candidates: number): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $costs\n     * @param Integer $k\n     * @param Integer $candidates\n     * @return Integer\n     */\n    function totalCost($costs, $k, $candidates) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func totalCost(_ costs: [Int], _ k: Int, _ candidates: Int) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int totalCost(List<int> costs, int k, int candidates) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func totalCost(costs []int, k int, candidates int) int64 {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} costs\n# @param {Integer} k\n# @param {Integer} candidates\n# @return {Integer}\ndef total_cost(costs, k, candidates)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def totalCost(costs: Array[Int], k: Int, candidates: Int): Long = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (total-cost costs k candidates)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec total_cost(Costs :: [integer()], K :: integer(), Candidates :: integer()) -> integer().\ntotal_cost(Costs, K, Candidates) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec total_cost(costs :: [integer], k :: integer, candidates :: integer) :: integer\n  def total_cost(costs, k, candidates) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:37:09.86357784+02:00","AcRate":"43.3","TotalSubmissions":342283,"TotalAccepted":148285,"AcceptanceRate":0.4332233853273461,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/total-cost-to-hire-k-workers/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        # Initialize min-heaps for the candidates section\n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[i], i) for i in range(n-1, max(n-candidates-1, -1), -1) if i >= candidates]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        # Process the hiring sessions\n        while hired_workers < k:\n            # If left heap and right heap both have elements\n            if left_heap and right_heap:\n                left_cost, left_index = left_heap[0]\n                right_cost, right_index = right_heap[0]\n                \n                # Hire from the heap with the lower cost\n                if left_cost < right_cost or (left_cost == right_cost and left_index < right_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    # replace the worker with the next unprocessed candidate\n                    if hired_workers + len(left_heap) < min(candidates, n):\n                        next_index = hired_workers + len(left_heap)\n                        if next_index < n:\n                            heapq.heappush(left_heap, (costs[next_index], next_index))\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    # replace the worker with the next unprocessed candidate from the end\n                    if hired_workers + len(right_heap) < candidates and n - hired_workers - len(right_heap) > candidates:\n                        next_index = n - hired_workers - len(right_heap) - 1\n                        if next_index >= 0:\n                            heapq.heappush(right_heap, (costs[next_index], next_index))\n            # If only the left heap has elements\n            elif left_heap:\n                left_cost, left_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if hired_workers + len(left_heap) < min(candidates, n):\n                    next_index = hired_workers + len(left_heap)\n                    if next_index < n:\n                        heapq.heappush(left_heap, (costs[next_index], next_index))\n            # If only the right heap has elements\n            elif right_heap:\n                right_cost, right_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if hired_workers + len(right_heap) < candidates and n - hired_workers - len(right_heap) > candidates:\n                    next_index = n - hired_workers - len(right_heap) - 1\n                    if next_index >= 0:\n                        heapq.heappush(right_heap, (costs[next_index], next_index))\n\n        return hired_cost\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        # Initial heaps for candidates\n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[n-1-i], n-1-i) for i in range(min(candidates, n))]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        left_index = candidates\n        right_index = n - candidates - 1\n        \n        while hired_workers < k:\n            if left_heap and right_heap:\n                left_cost, left_worker_index = left_heap[0]\n                right_cost, right_worker_index = right_heap[0]\n                \n                if left_cost < right_cost or (left_cost == right_cost and left_worker_index < right_worker_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    if left_index < n:\n                        heapq.heappush(left_heap, (costs[left_index], left_index))\n                        left_index += 1\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    if right_index >= 0:\n                        heapq.heappush(right_heap, (costs[right_index], right_index))\n                        right_index -= 1\n            elif left_heap:\n                left_cost, left_worker_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if left_index < n:\n                    heapq.heappush(left_heap, (costs[left_index], left_index))\n                    left_index += 1\n            elif right_heap:\n                right_cost, right_worker_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if right_index >= 0:\n                    heapq.heappush(right_heap, (costs[right_index], right_index))\n                    right_index -= 1\n                    \n        return hired_cost\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[n-1-i], n-1-i) for i in range(min(candidates, n))]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        left_index = candidates\n        right_index = n - candidates - 1\n        \n        while hired_workers < k:\n            if left_heap and right_heap:\n                left_cost, left_worker_index = left_heap[0]\n                right_cost, right_worker_index = right_heap[0]\n                \n                if left_cost < right_cost or (left_cost == right_cost and left_worker_index < right_worker_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    if left_index < n:\n                        heapq.heappush(left_heap, (costs[left_index], left_index))\n                        left_index += 1\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    if right_index >= 0:\n                        heapq.heappush(right_heap, (costs[right_index], right_index))\n                        right_index -= 1\n            elif left_heap:\n                left_cost, left_worker_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if left_index < n:\n                    heapq.heappush(left_heap, (costs[left_index], left_index))\n                    left_index += 1\n            elif right_heap:\n                right_cost, right_worker_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if right_index >= 0:\n                    heapq.heappush(right_heap, (costs[right_index], right_index))\n                    right_index -= 1\n                    \n        return hired_cost\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        # Initialize heaps for the first and last `candidates` workers\n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[n-1-i], n-1-i) for i in range(min(candidates, n))]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        left_index = candidates\n        right_index = n - candidates - 1\n        \n        while hired_workers < k:\n            if left_heap and right_heap:\n                left_cost, left_worker_index = left_heap[0]\n                right_cost, right_worker_index = right_heap[0]\n                \n                if left_cost < right_cost or (left_cost == right_cost and left_worker_index < right_worker_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    if left_index < n:\n                        heapq.heappush(left_heap, (costs[left_index], left_index))\n                        left_index += 1\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    if right_index >= 0:\n                        heapq.heappush(right_heap, (costs[right_index], right_index))\n                        right_index -= 1\n            elif left_heap:\n                left_cost, left_worker_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if left_index < n:\n                    heapq.heappush(left_heap, (costs[left_index], left_index))\n                    left_index += 1\n            elif right_heap:\n                right_cost, right_worker_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if right_index >= 0:\n                    heapq.heappush(right_heap, (costs[right_index], right_index))\n                    right_index -= 1\n        \n        return hired_cost\n```\n\n","TypedCode":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[n-1-i], n-1-i) for i in range(min(candidates, n))]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        left_index = candidates\n        right_index = n - candidates - 1\n        \n        while hired_workers < k:\n            if left_heap and right_heap:\n                left_cost, left_worker_index = left_heap[0]\n                right_cost, right_worker_index = right_heap[0]\n                \n                if left_cost < right_cost or (left_cost == right_cost and left_worker_index < right_worker_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    if left_index < n:\n                        heapq.heappush(left_heap, (costs[left_index], left_index))\n                        left_index += 1\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    if right_index >= 0:\n                        heapq.heappush(right_heap, (costs[right_index], right_index))\n                        right_index -= 1\n            elif left_heap:\n                left_cost, left_worker_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if left_index < n:\n                    heapq.heappush(left_heap, (costs[left_index], left_index))\n                    left_index += 1\n            elif right_heap:\n                right_cost, right_worker_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if right_index >= 0:\n                    heapq.heappush(right_heap, (costs[right_index], right_index))\n                    right_index -= 1\n                    \n        return hired_cost\n","Model":"se-gpt-4o","Latency":16400429877,"SolvedAt":"2025-09-05T23:55:35.909961732+02:00","PromptTokens":7975,"OutputTokens":2057}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"2553","typed_code":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        \n        left_heap = [(costs[i], i) for i in range(min(candidates, n))]\n        right_heap = [(costs[n-1-i], n-1-i) for i in range(min(candidates, n))]\n        \n        heapq.heapify(left_heap)\n        heapq.heapify(right_heap)\n        \n        hired_cost = 0\n        hired_workers = 0\n        \n        left_index = candidates\n        right_index = n - candidates - 1\n        \n        while hired_workers < k:\n            if left_heap and right_heap:\n                left_cost, left_worker_index = left_heap[0]\n                right_cost, right_worker_index = right_heap[0]\n                \n                if left_cost < right_cost or (left_cost == right_cost and left_worker_index < right_worker_index):\n                    heapq.heappop(left_heap)\n                    hired_cost += left_cost\n                    hired_workers += 1\n                    if left_index < n:\n                        heapq.heappush(left_heap, (costs[left_index], left_index))\n                        left_index += 1\n                else:\n                    heapq.heappop(right_heap)\n                    hired_cost += right_cost\n                    hired_workers += 1\n                    if right_index >= 0:\n                        heapq.heappush(right_heap, (costs[right_index], right_index))\n                        right_index -= 1\n            elif left_heap:\n                left_cost, left_worker_index = heapq.heappop(left_heap)\n                hired_cost += left_cost\n                hired_workers += 1\n                if left_index < n:\n                    heapq.heappush(left_heap, (costs[left_index], left_index))\n                    left_index += 1\n            elif right_heap:\n                right_cost, right_worker_index = heapq.heappop(right_heap)\n                hired_cost += right_cost\n                hired_workers += 1\n                if right_index >= 0:\n                    heapq.heappush(right_heap, (costs[right_index], right_index))\n                    right_index -= 1\n                    \n        return hired_cost\n"},"SubmissionId":1760939462,"CheckResponse":{"status_code":11,"status_msg":"Wrong Answer","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:28:12.754179623+02:00"}}}
