{"Question":{"Data":{"Question":{"questionFrontendId":"123","questionId":"123","Content":"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n","SampleTestCase":"[3,3,5,0,0,3,1,4]","ExampleTestcases":"[3,3,5,0,0,3,1,4]\n[1,2,3,4,5]\n[7,6,4,3,1]","Difficulty":"Hard","Title":"Best Time to Buy and Sell Stock III","TitleSlug":"best-time-to-buy-and-sell-stock-iii","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"846.4K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 846394, \"totalSubmissionRaw\": 1627386, \"acRate\": \"52.0%\"}","Likes":10328,"Dislikes":216,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int maxProfit(int* prices, int pricesSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxProfit(prices: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int maxProfit(List<int> prices) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxProfit(prices []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-profit prices)\n  (-> (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_profit(Prices :: [integer()]) -> integer().\nmax_profit(Prices) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_profit(prices :: [integer]) :: integer\n  def max_profit(prices) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:27:48.6892027+02:00","AcRate":"52.0","TotalSubmissions":1627386,"TotalAccepted":846394,"AcceptanceRate":0.520094187857091,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\n=== DESIGN ===\nSure, let's design a solution based on the insights provided and implement the code.\n\n**Algorithm Choice**: \nThe algorithm leverages dynamic programming to track profits from the first and second transactions separately.\n\n**Step-by-Step Approach**:\n\n1. **Initial Checks**:\n   - If the `prices` list is empty or has fewer than 2 elements, return 0, as no transactions can be made.\n\n2. **First Transaction Profits**:\n   - Create an array `left_profits` to store maximum profits achievable until each day from a single transaction.\n   - Iterate over the prices from left to right, updating `left_profits` with the maximum profit possible by selling on day `i`.\n   - Maintain the minimum price encountered so far to calculate possible maximum profit at each step.\n\n3. **Second Transaction Profits**:\n   - Create another array `right_profits` to store maximum profits achievable from each day to the last day from a single transaction.\n   - Iterate over the prices from right to left, updating `right_profits` with the maximum profit possible by buying on day `i`.\n   - Maintain the maximum price encountered from the end to calculate possible maximum profit at each step.\n   \n4. **Calculate Maximum Total Profit**:\n   - Iterate through each day and find the maximum sum of profits combining `left_profits[i]` and `right_profits[i]` which gives the profit from two transactions.\n\n5. **Return the Result**:\n   - Return the maximum profit calculated.\n\n**Data Structures**:\n- Two arrays: `left_profits` and `right_profits` to store profits from the first and second transactions.\n\n**Time Complexity**:\n- O(n), where n is the number of days (or length of `prices`).\n\n**Space Complexity**:\n- O(n), for storing profits arrays.\n\n**Pseudocode**:\n```\nfunction maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    \n    n = len(prices)\n    left_profits = [0] * n\n    right_profits = [0] * n\n    \n    min_price = prices[0]\n    for i from 1 to n-1:\n        left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n        min_price = min(min_price, prices[i])\n    \n    max_price = prices[n-1]\n    for i from n-2 downto 0:\n        right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n        max_price = max(max_price, prices[i])\n    \n    max_profit = 0\n    for i from 0 to n-1:\n        max_profit = max(max_profit, left_profits[i] + right_profits[i])\n    \n    return max_profit\n```\n\nLet's implement this solution in Python.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n\n        n = len(prices)\n\n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n\n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n\n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n\n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n\n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n\n        return max_profit\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\n=== VERIFICATION ===\nThe implemented solution uses dynamic programming to track the maximum profit achievable with up to two transactions on given stock prices. Here's the verification step-by-step:\n\n1. **Correctness**: \n   - The solution correctly sets up arrays `left_profits` and `right_profits` to compute the maximum profit from the first and potential second transaction.\n   - It calculates the best profit up to each day using array `left_profits`, and the best profit from each day to the last using array `right_profits`.\n   - Finally, it iterates over the days to find the maximum profit possible with the sum of the profits of the two transactions.\n\n2. **Edge Cases**: \n   - The solution handles the case where there are fewer than two days by returning zero, as no transactions are possible.\n   - It should correctly handle cases where stock prices are constant or strictly decreasing, producing zero profit as expected.\n\n3. **Complexity**: \n   - Time Complexity: O(n) due to the linear scans through the prices for calculating profits.\n   - Space Complexity: O(n) required for storing profits per day.\n\n4. **Code Quality**: \n   - The code is clean and easy to understand. It follows best practices using clear variable names and straightforward logic.\n   - The solution uses fixed arrays for the storage of profits, which maintains clarity and efficiency.\n\n5. **Test Cases**:\n   - When running through the test cases:\n     - Example 1 `prices = [3,3,5,0,0,3,1,4]` outputs 6, which is correct.\n     - Example 2 `prices = [1,2,3,4,5]` outputs 4, which is correct.\n     - Example 3 `prices = [7,6,4,3,1]` outputs 0, which is correct.\n\n6. **Potential Issues**:\n   - There are no evident logical errors or bugs. The approach correctly addresses the problem statement requirements and constraints.\n\nOverall, the implemented solution is correct, efficient, and meets all the requirements outlined in the problem statement. Here is the confirmed source code:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\nThis solution properly computes the maximum profit achievable from at most two transactions from the given prices list using dynamic programming techniques.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n","Model":"se-gpt-4o","Latency":15299585042,"SolvedAt":"2025-09-05T23:41:12.207481667+02:00","PromptTokens":5393,"OutputTokens":1978}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"123","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n"},"SubmissionId":1760928811,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-05T23:59:47.084949743+02:00"}}}
