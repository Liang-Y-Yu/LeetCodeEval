{"Question":{"Data":{"Question":{"questionFrontendId":"238","questionId":"238","Content":"<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The input is generated such that <code>answer[i]</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n","SampleTestCase":"[1,2,3,4]","ExampleTestcases":"[1,2,3,4]\n[-1,1,0,-3,3]","Difficulty":"Medium","Title":"Product of Array Except Self","TitleSlug":"product-of-array-except-self","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"3.9M\", \"totalSubmission\": \"5.8M\", \"totalAcceptedRaw\": 3916647, \"totalSubmissionRaw\": 5755731, \"acRate\": \"68.0%\"}","Likes":24767,"Dislikes":1603,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjYxMDY4","Name":"Prefix Sum","Slug":"prefix-sum"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function productExceptSelf(nums: number[]): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function productExceptSelf($nums) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun productExceptSelf(nums: IntArray): IntArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<int> productExceptSelf(List<int> nums) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func productExceptSelf(nums []int) []int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @return {Integer[]}\ndef product_except_self(nums)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def productExceptSelf(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (product-except-self nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec product_except_self(Nums :: [integer()]) -> [integer()].\nproduct_except_self(Nums) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec product_except_self(nums :: [integer]) :: [integer]\n  def product_except_self(nums) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:34:48.412174055+02:00","AcRate":"68.0","TotalSubmissions":5755731,"TotalAccepted":3916647,"AcceptanceRate":0.680477770764478,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/product-of-array-except-self/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        \n        # Initialize the answer array\n        answer = [0] * n\n        \n        # Calculate the prefix product for each element\n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        # Calculate the suffix product and multiply with the prefix product\n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        \n        # Initialize the answer array\n        answer = [0] * n\n        \n        # Calculate the prefix product for each element\n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        # Calculate the suffix product and multiply with the prefix product\n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        \n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n```\n\n=== VERIFICATION ===\nBased on the provided code and requirements, here is the verification report:\n\n**1. Correctness:**\n- The code correctly implements the designed algorithm using prefix and suffix products to calculate the result without using division.\n- The logic is sound and correctly iterates through the array twice to achieve the desired product, excluding each element.\n\n**2. Edge Cases:**\n- The code effectively handles edge cases, including the presence of zero in the input array which is demonstrated in the sample test case where the input is `[-1,1,0,-3,3]`.\n- It correctly handles arrays of size `n` with `n` being in the range 2 <= nums.length <= 100,000, which is a requirement.\n\n**3. Complexity:**\n- The implemented solution has a time complexity of O(n), which meets the requirement since the operations inside the loops are constant time.\n- The space complexity is O(1) extra space, considering the output array does not count as extra space, which aligns with the requirement.\n\n**4. Code Quality:**\n- The code is clean, well-organized, and follows Python best practices, such as meaningful variable names and proper initialization.\n- It avoids unnecessary computations and maintains code simplicity.\n\n**5. Test Cases:**\n- The provided examples produce correct outputs when walked through the code.\n  - For `nums = [1,2,3,4]`, the output is `[24,12,8,6]`, matching the expected result.\n  - For `nums = [-1,1,0,-3,3]`, the output is `[0,0,9,0,0]`, matching the expected result.\n\n**6. Potential Issues:**\n- I did not find any bugs or logical errors in the code.\n- No improvements are necessary as the code already meets the requirements efficiently and correctly.\n\n**Conclusion:** The solution is valid, correct, and meets all stated requirements in terms of correctness, complexity, and handling of edge cases. It is ready for use in any environment that aligns with the problem constraints.\n\nHere is the final code snippet as requested:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        \n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n```\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        \n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n","Model":"se-gpt-4o","Latency":8526999394,"SolvedAt":"2025-09-05T23:52:48.919246677+02:00","PromptTokens":3190,"OutputTokens":957}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"238","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        \n        prefix_product = 1\n        for i in range(n):\n            answer[i] = prefix_product\n            prefix_product *= nums[i]\n        \n        suffix_product = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix_product\n            suffix_product *= nums[i]\n        \n        return answer\n"},"SubmissionId":1760937298,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:22:35.551525691+02:00"}}}
