{"Question":{"Data":{"Question":{"questionFrontendId":"57","questionId":"57","Content":"<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n","SampleTestCase":"[[1,3],[6,9]]\n[2,5]","ExampleTestcases":"[[1,3],[6,9]]\n[2,5]\n[[1,2],[3,5],[6,7],[8,10],[12,16]]\n[4,8]","Difficulty":"Medium","Title":"Insert Interval","TitleSlug":"insert-interval","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 1548730, \"totalSubmissionRaw\": 3524272, \"acRate\": \"43.9%\"}","Likes":11336,"Dislikes":895,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function insert(intervals: number[][], newInterval: number[]): number[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func insert(intervals [][]int, newInterval []int) [][]int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (insert intervals newInterval)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec insert(Intervals :: [[integer()]], NewInterval :: [integer()]) -> [[integer()]].\ninsert(Intervals, NewInterval) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec insert(intervals :: [[integer]], new_interval :: [integer]) :: [[integer]]\n  def insert(intervals, new_interval) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:30:42.623732806+02:00","AcRate":"43.9","TotalSubmissions":3524272,"TotalAccepted":1548730,"AcceptanceRate":0.43944678503815826,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/insert-interval/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals to newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== DESIGN ===\nAlgorithm Choice: The approach is a straightforward iteration with conditional merging. Given the intervals are already sorted by the start time, we proceed to iterate to find where the new interval can be inserted or needs to merge, which minimizes complexity compared to sorting or more complex data structures.\n\nStep-by-Step Approach:\n1. Initialize an empty list `result` to store the final merged intervals.\n2. Iterate over the given `intervals`, using index `i`, starting from 0.\n3. Add all intervals to `result` that end before the start of `newInterval` (no overlap).\n4. Merge intervals with `newInterval` that overlap with it:\n   - Update the start of `newInterval` to be the minimum of itself and the current interval's start.\n   - Update the end of `newInterval` to be the maximum of itself and the current interval's end.\n   - Continue this until there are no more overlapping intervals.\n5. After merging, append the `newInterval` to `result`.\n6. Add any remaining intervals to `result` that start after `newInterval` ends as they do not overlap.\n7. Return the `result` list containing the merged intervals.\n\nData Structures: Use a list to store and manipulate intervals, which supports efficient appending operations.\n\nTime Complexity: O(n), where n is the number of intervals. This is efficient as we are making a single pass over the intervals.\n\nSpace Complexity: O(n), as we are creating a new list to store the merged intervals.\n\nPseudocode:\n```\nfunction insert(intervals, newInterval):\n    result = []\n    i = 0\n    n = length(intervals)\n\n    # Step 1: Add all intervals that end before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        append intervals[i] to result\n        increment i\n    \n    # Step 2: Merge overlapping intervals with newInterval\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        increment i\n        \n    # Step 3: Add merged newInterval to result\n    append newInterval to result\n\n    # Step 4: Add remaining intervals\n    while i < n:\n        append intervals[i] to result\n        increment i\n\n    return result\n```\n\nHere is the code implementation:\n\n```python\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== VERIFICATION ===\nHere's the verification report for the provided implementation of the interval insertion and merging problem:\n\n1. **Correctness**:\n   - The code correctly implements the designed algorithm, which aims to insert a new interval into an existing list of non-overlapping, sorted intervals, and merge overlapping intervals if necessary.\n   - The logic for handling intervals that end before the new interval starts, for merging overlapping intervals, and for adding intervals that start after the new interval ends is correctly implemented.\n   - The code successfully returns a list of merged intervals after inserting the new interval.\n\n2. **Edge Cases**:\n   - The code handles edge cases such as:\n     - An empty list of intervals.\n     - A newInterval that doesn't overlap with any existing intervals.\n     - A newInterval that overlaps with one or more intervals and requires merging.\n     - Intervals at the start or end of the list.\n   - The approach should work correctly for these scenarios as verified by the conditional checks in the loops.\n\n3. **Complexity**:\n   - The algorithm operates in O(n) time complexity due to the single pass through the list of intervals, where n is the number of intervals. This is optimal for this problem.\n   - The space complexity is also O(n), where n is the number of intervals, as the algorithm constructs a new list to store the merged intervals.\n\n4. **Code Quality**:\n   - The code is clean and readable, with clear variable names and straightforward logic implementation.\n   - It follows Python best practices and makes appropriate use of data structures, particularly lists.\n   - The absence of unnecessary complexity or redundant code makes it easy to understand.\n\n5. **Test Cases**:\n   - The solution passes the provided examples:\n     - Example 1: `intervals = [[1,3],[6,9]], newInterval = [2,5]`, Output: `[[1,5],[6,9]]`\n     - Example 2: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]`, Output: `[[1,2],[3,10],[12,16]]`\n   - The solution outputs the correct, expected results for these example inputs, verifying the correctness of the solution.\n\n6. **Potential Issues**:\n   - There are no apparent bugs or logical errors in the current implementation.\n   - The implementation is efficient and sufficient for the given constraints.\n\nBased on the analysis, the provided code fulfills the requirements outlined in the problem statement with correct logic and optimal time and space complexity. It correctly implements the design, passes all provided sample test cases, and maintains code quality standards. Thus, the solution is valid and complete.\n\nHere is the implementation code:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n","Model":"se-gpt-4o","Latency":17160748362,"SolvedAt":"2025-09-05T23:46:07.981121052+02:00","PromptTokens":4969,"OutputTokens":1851}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"57","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n"},"SubmissionId":1760932729,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:09:57.469694236+02:00"}}}
