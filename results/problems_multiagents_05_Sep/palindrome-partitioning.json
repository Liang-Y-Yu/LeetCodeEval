{"Question":{"Data":{"Question":{"questionFrontendId":"131","questionId":"131","Content":"<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n","SampleTestCase":"\"aab\"","ExampleTestcases":"\"aab\"\n\"a\"","Difficulty":"Medium","Title":"Palindrome Partitioning","TitleSlug":"palindrome-partitioning","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1196515, \"totalSubmissionRaw\": 1643241, \"acRate\": \"72.8%\"}","Likes":13852,"Dislikes":558,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"},{"Id":"VG9waWNUYWdOb2RlOjE0","Name":"Backtracking","Slug":"backtracking"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<List<String>> partition(String s) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** partition(char* s, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<IList<string>> Partition(string s) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function partition(s: string): string[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $s\n     * @return String[][]\n     */\n    function partition($s) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func partition(_ s: String) -> [[String]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun partition(s: String): List<List<String>> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<String>> partition(String s) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func partition(s string) [][]string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} s\n# @return {String[][]}\ndef partition(s)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def partition(s: String): List[List[String]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn partition(s: String) -> Vec<Vec<String>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (partition s)\n  (-> string? (listof (listof string?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec partition(S :: unicode:unicode_binary()) -> [[unicode:unicode_binary()]].\npartition(S) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec partition(s :: String.t) :: [[String.t]]\n  def partition(s) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:34:40.874294412+02:00","AcRate":"72.8","TotalSubmissions":1643241,"TotalAccepted":1196515,"AcceptanceRate":0.7281433459851598,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/palindrome-partitioning/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n```\n\n=== DESIGN ===\nLet's design a solution for the problem using recursive backtracking to explore all potential partitions and verify palindromic substrings. Here's a structured breakdown of the approach:\n\n1. **Algorithm Choice**: \n   Use recursive backtracking to explore all partitions and check if substrings are palindromes by reversing each substring.\n\n2. **Step-by-Step Approach**:\n   - Define a utility function `is_palindrome` that checks whether a string is equal to its reverse.\n   - Implement a `backtrack` function which starts from the given index (initially zero) and explores all partition options by iterating through potential substring endpoints.\n   - Whenever a substring is identified as a palindrome, add it to the current path and continue exploring the remaining substring.\n   - If the starting index reaches the length of the string, add the current path to the results as it represents a valid partition.\n   - Use a list to hold the current path of explored palindromes and append/pop them as you backtrack through recursive calls.\n\n3. **Data Structures**:\n   - A list `res` for storing the resultant partitions.\n   - A list `path` to store the current sequence of palindromic partitions being tested.\n\n4. **Time Complexity**:\n   - The complexity involves generating all possible partitions, checking each partition for palindromic substrings. This has exponential complexity, generally `O(N * 2^N)` at worst, considering the palindrome checks.\n\n5. **Space Complexity**:\n   - Space complexity is primarily for storing the results and recursive stack, potentially up to `O(N * 2^N)`.\n\n6. **Pseudocode**:\n   ```plaintext\n   function is_palindrome(sub):\n       return sub == reverse(sub)\n\n   function backtrack(start, path):\n       if start equals length of s:\n           append path copy to res\n           return\n       \n       for end from start+1 to len(s)+1:\n           substring = s[start:end]\n           if is_palindrome(substring):\n               append substring to path\n               call backtrack(end, path)\n               remove last element from path\n\n   initialize res as an empty list\n   call backtrack(0, [])\n   return res\n   ```\n\nHere's the complete Python implementation using the described approach:\n\n```python\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n```\n\nThis solution performs exhaustive partition testing and ensures all parts are palindromes using recursion and list manipulation.\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n```\n\n=== VERIFICATION ===\nThe given solution for the problem of partitioning a string into palindromic substrings is correct and meets the problem requirements effectively. Let me go through the verification steps:\n\n1. **Correctness**:\n   - The algorithm uses recursive backtracking to explore all partition possibilities and checks for palindromic substrings.\n   - The `is_palindrome` method is correctly implemented to verify whether a substring is a palindrome by comparing it with its reverse.\n   - Each valid partition path is added to the list of results `res` when the start index reaches the end of the string.\n   - The solution correctly partitions \"aab\" into [[\"a\",\"a\",\"b\"], [\"aa\",\"b\"]], and \"a\" into [[\"a\"]], matching the sample outputs.\n   \n2. **Edge Cases**:\n   - The constraints specify a minimum length of 1 and only lower case English letters, which are handled correctly.\n   - The solution should handle the smallest inputs (single-character strings) and the largest inputs (16-character strings) defined by the problem constraints without issue.\n\n3. **Complexity**:\n   - Given the recursive nature of the algorithm that explores all possible partitions, the time complexity can be considered `O(N * 2^N)`, which is expected for this exhaustive partitioning problem.\n   - The space complexity is similarly `O(N * 2^N)` due to the storage required for results and the recursive stack.\n   - This complexity is manageable within the input limits defined by the problem constraints.\n\n4. **Code Quality**:\n   - The code is clear, with well-segmented functions for palindrome checking (`is_palindrome`) and backtracking (`backtrack`).\n   - Recursive calls and list operations are used correctly, with good use of list slicing and manipulation.\n   - The code avoids unnecessary complexity and remains efficient for the given task.\n\n5. **Test Cases**:\n   - The provided test cases in the problem statement were successfully handled by the code during my walkthrough.\n   - The function will correctly handle similar cases generated according to constraints, thanks to its systematic exploration of substring partitions.\n\n6. **Potential Issues**:\n   - The algorithm is robust under the current problem constraints. No immediate bugs or logical errors were identified.\n\nOverall, the solution is correct and implemented according to best practices for recursion and backtracking. It correctly handles all valid inputs within the constraints and delivers expected outputs.\n\nHere is the final, verified code:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n```\n\n\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n","Model":"se-gpt-4o","Latency":12140425592,"SolvedAt":"2025-09-05T23:52:02.193518454+02:00","PromptTokens":3645,"OutputTokens":1547}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"131","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                res.append(path[:])\n                return\n                \n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res\n"},"SubmissionId":1760936817,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:21:09.69564558+02:00"}}}
