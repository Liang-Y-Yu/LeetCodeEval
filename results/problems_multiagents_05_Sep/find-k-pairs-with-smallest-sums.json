{"Question":{"Data":{"Question":{"questionFrontendId":"373","questionId":"373","Content":"<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>non-decreasing&nbsp;order</strong> and an integer <code>k</code>.</p>\n\n<p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> <em>with the smallest sums</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>Output:</strong> [[1,2],[1,4],[1,6]]\n<strong>Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>Output:</strong> [[1,1],[1,1]]\n<strong>Explanation:</strong> The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k &lt;=&nbsp;nums1.length *&nbsp;nums2.length</code></li>\n</ul>\n","SampleTestCase":"[1,7,11]\n[2,4,6]\n3","ExampleTestcases":"[1,7,11]\n[2,4,6]\n3\n[1,1,2]\n[1,2,3]\n2","Difficulty":"Medium","Title":"Find K Pairs with Smallest Sums","TitleSlug":"find-k-pairs-with-smallest-sums","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"397.2K\", \"totalSubmission\": \"970K\", \"totalAcceptedRaw\": 397212, \"totalSubmissionRaw\": 969951, \"acRate\": \"41.0%\"}","Likes":6715,"Dislikes":480,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nvar kSmallestPairs = function(nums1, nums2, k) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function kSmallestPairs(nums1: number[], nums2: number[], k: number): number[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function kSmallestPairs($nums1, $nums2, $k) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<int>> kSmallestPairs(List<int> nums1, List<int> nums2, int k) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer} k\n# @return {Integer[][]}\ndef k_smallest_pairs(nums1, nums2, k)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def kSmallestPairs(nums1: Array[Int], nums2: Array[Int], k: Int): List[List[Int]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (k-smallest-pairs nums1 nums2 k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec k_smallest_pairs(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> [[integer()]].\nk_smallest_pairs(Nums1, Nums2, K) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec k_smallest_pairs(nums1 :: [integer], nums2 :: [integer], k :: integer) :: [[integer]]\n  def k_smallest_pairs(nums1, nums2, k) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-05T23:29:52.492481044+02:00","AcRate":"41.0","TotalSubmissions":969951,"TotalAccepted":397212,"AcceptanceRate":0.40951759418774764,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        # Initial population of the heap with pairs from nums1[0] + nums2[i] for i in range(len(nums2))\n        # We are only interested in the smallest pairs, so start with the first element of nums1\n        for j in range(min(len(nums2), k)):  # Only need to consider the first k elements as we want k pairs\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            # If we add the next element from nums1 (i+1, j) it is still within bounds\n            # Push the next candidate pair (nums1[i+1], nums2[j]) to the heap\n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n```\n\n=== DESIGN ===\n```python\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        \n        # Initialize the heap with the first element of nums1 and all elements of nums2 up to k\n        for j in range(min(len(nums2), k)):\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            # Push the next element from nums1 if within bounds\n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        for j in range(min(len(nums2), k)):\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n```\n\n=== VERIFICATION ===\nVerification Report:\n\n1. **Correctness**:\n   - The implemented code follows the design and algorithm outlined in the analysis. It uses a min-heap to find the k pairs with the smallest sums by initially adding pairs formed from the first element of `nums1` and each element of `nums2`. The heap ensures that we can efficiently extract the smallest available pair, and the code correctly handles index incrementing to explore further pairs.\n\n2. **Edge Cases**:\n   - The solution correctly handles the constraint where `k` can be smaller or equal to `nums1.length * nums2.length`, ensuring that it doesn't attempt to find more pairs than available.\n   - The iteration over `nums2` is limited to the first `k` elements for initial heap population, addressing the scenario where `k` is smaller than `len(nums2)`.\n\n3. **Complexity**:\n   - The time complexity involves maintaining a heap of size `k`, and iteratively processing its elements, which is efficient given the constraints. The complexity should be proportional to `k * log(min(k, len(nums1) * len(nums2)))`, making it feasible for large input sizes within the provided constraints.\n\n4. **Code Quality**:\n   - The code is clean and readable. Variable names are descriptive and the logic is organized. It utilized Python's heapq methods for maintaining the priority queue, which is appropriate for this problem.\n\n5. **Test Cases**:\n   - The given test cases, when run through the code, produce correct outputs. The sample inputs ensure basic correctness, demonstrating the output for different pair selections and input array configurations.\n\n6. **Potential Issues**:\n   - No logical errors were identified. The code efficiently handles the computations required and uses the correct algorithmic constructs given the problem constraints.\n\nConclusion:\nThe solution correctly implements the intended algorithm, handles edge cases, maintains efficient complexity, follows clean coding practices, and produces correct outputs for the provided test cases. The solution is valid and no changes are necessary.\n\nThe complete solution is as follows:\n\n```python\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        for j in range(min(len(nums2), k)):\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n```\n\n","TypedCode":"\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        for j in range(min(len(nums2), k)):\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n","Model":"se-gpt-4o","Latency":10653293859,"SolvedAt":"2025-09-05T23:44:22.166688545+02:00","PromptTokens":4404,"OutputTokens":1279}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"373","typed_code":"\nfrom heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        min_heap = []\n        for j in range(min(len(nums2), k)):\n            heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n        \n        result = []\n        \n        while min_heap and len(result) < k:\n            _, i, j = heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            \n            if i + 1 < len(nums1):\n                heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        return result\n"},"SubmissionId":1760931308,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T00:06:02.482123663+02:00"}}}
