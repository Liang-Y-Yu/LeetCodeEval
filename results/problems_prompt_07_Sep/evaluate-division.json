{"Question":{"Data":{"Question":{"questionFrontendId":"399","questionId":"399","Content":"<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>\n\n<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>\n\n<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>\n\n<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>\n\n<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>Explanation:</strong> \nGiven: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>\nqueries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined =&gt; -1.0</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>\n</ul>\n","SampleTestCase":"[[\"a\",\"b\"],[\"b\",\"c\"]]\n[2.0,3.0]\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]","ExampleTestcases":"[[\"a\",\"b\"],[\"b\",\"c\"]]\n[2.0,3.0]\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\n[1.5,2.5,5.0]\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n[[\"a\",\"b\"]]\n[0.5]\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]","Difficulty":"Medium","Title":"Evaluate Division","TitleSlug":"evaluate-division","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"635.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 635259, \"totalSubmissionRaw\": 1000864, \"acRate\": \"63.5%\"}","Likes":9936,"Dislikes":1060,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjIx","Name":"Depth-First Search","Slug":"depth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"},{"Id":"VG9waWNUYWdOb2RlOjIz","Name":"Union Find","Slug":"union-find"},{"Id":"VG9waWNUYWdOb2RlOjI0","Name":"Graph","Slug":"graph"},{"Id":"VG9waWNUYWdOb2RlOjYxMDc2","Name":"Shortest Path","Slug":"shortest-path"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ndouble* calcEquation(char*** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char*** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string[][]} equations\n * @param {number[]} values\n * @param {string[][]} queries\n * @return {number[]}\n */\nvar calcEquation = function(equations, values, queries) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function calcEquation(equations: string[][], values: number[], queries: string[][]): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String[][] $equations\n     * @param Float[] $values\n     * @param String[][] $queries\n     * @return Float[]\n     */\n    function calcEquation($equations, $values, $queries) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun calcEquation(equations: List<List<String>>, values: DoubleArray, queries: List<List<String>>): DoubleArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<double> calcEquation(List<List<String>> equations, List<double> values, List<List<String>> queries) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String[][]} equations\n# @param {Float[]} values\n# @param {String[][]} queries\n# @return {Float[]}\ndef calc_equation(equations, values, queries)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def calcEquation(equations: List[List[String]], values: Array[Double], queries: List[List[String]]): Array[Double] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (calc-equation equations values queries)\n  (-> (listof (listof string?)) (listof flonum?) (listof (listof string?)) (listof flonum?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec calc_equation(Equations :: [[unicode:unicode_binary()]], Values :: [float()], Queries :: [[unicode:unicode_binary()]]) -> [float()].\ncalc_equation(Equations, Values, Queries) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec calc_equation(equations :: [[String.t]], values :: [float], queries :: [[String.t]]) :: [float]\n  def calc_equation(equations, values, queries) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-07T14:29:40.751740104+02:00","AcRate":"63.5","TotalSubmissions":1000864,"TotalAccepted":635259,"AcceptanceRate":0.6347106100329315,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/evaluate-division/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the j^th query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n \nExample 1:\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\nExplanation: \nGiven: a / b = 2.0, b / c = 3.0\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\nExample 2:\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\nOutput: [3.75000,0.40000,5.00000,0.20000]\nExample 3:\nInput: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\n \nConstraints:\n\t1 <= equations.length <= 20\n\tequations[i].length == 2\n\t1 <= Ai.length, Bi.length <= 5\n\tvalues.length == equations.length\n\t0.0 < values[i] <= 20.0\n\t1 <= queries.length <= 20\n\tqueries[i].length == 2\n\t1 <= Cj.length, Dj.length <= 5\n\tAi, Bi, Cj, Dj consist of lower case English letters and digits.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n","Answer":"```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Graph will store the ratio in the form of adjacency list\n        graph = defaultdict(dict)\n        \n        # Build the graph\n        for (A, B), value in zip(equations, values):\n            graph[A][B] = value\n            graph[B][A] = 1 / value\n        \n        # Function to perform BFS to find the value\n        def bfs(query):\n            start, end = query\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            \n            # Queue for BFS and visited set\n            queue = deque([(start, 1.0)])\n            visited = set([start])\n            \n            while queue:\n                current, product = queue.popleft()\n                if current == end:\n                    return product\n                for neighbor, value in graph[current].items():\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, product * value))\n            return -1.0\n        \n        # Process each query and evaluate using BFS\n        result = []\n        for query in queries:\n            result.append(bfs(query))\n        \n        return result\n```","TypedCode":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Graph will store the ratio in the form of adjacency list\n        graph = defaultdict(dict)\n        \n        # Build the graph\n        for (A, B), value in zip(equations, values):\n            graph[A][B] = value\n            graph[B][A] = 1 / value\n        \n        # Function to perform BFS to find the value\n        def bfs(query):\n            start, end = query\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            \n            # Queue for BFS and visited set\n            queue = deque([(start, 1.0)])\n            visited = set([start])\n            \n            while queue:\n                current, product = queue.popleft()\n                if current == end:\n                    return product\n                for neighbor, value in graph[current].items():\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, product * value))\n            return -1.0\n        \n        # Process each query and evaluate using BFS\n        result = []\n        for query in queries:\n            result.append(bfs(query))\n        \n        return result\n","Model":"gpt-4o-2024-08-06","Latency":2266580495,"SolvedAt":"2025-09-07T14:45:50.938276062+02:00","PromptTokens":825,"OutputTokens":293}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"399","typed_code":"\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Graph will store the ratio in the form of adjacency list\n        graph = defaultdict(dict)\n        \n        # Build the graph\n        for (A, B), value in zip(equations, values):\n            graph[A][B] = value\n            graph[B][A] = 1 / value\n        \n        # Function to perform BFS to find the value\n        def bfs(query):\n            start, end = query\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            \n            # Queue for BFS and visited set\n            queue = deque([(start, 1.0)])\n            visited = set([start])\n            \n            while queue:\n                current, product = queue.popleft()\n                if current == end:\n                    return product\n                for neighbor, value in graph[current].items():\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, product * value))\n            return -1.0\n        \n        # Process each query and evaluate using BFS\n        result = []\n        for query in queries:\n            result.append(bfs(query))\n        \n        return result\n"},"SubmissionId":1762672329,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-07T15:08:03.459829916+02:00"}}}
