{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "126",
        "questionId": "126",
        "Content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n",
        "SampleTestCase": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "ExampleTestcases": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "Difficulty": "Hard",
        "Title": "Word Ladder II",
        "TitleSlug": "word-ladder-ii",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"438.3K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 438315, \"totalSubmissionRaw\": 1602775, \"acRate\": \"27.3%\"}",
        "Likes": 6461,
        "Dislikes": 823,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIy",
            "Name": "Breadth-First Search",
            "Slug": "breadth-first-search"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** findLadders(char* beginWord, char* endWord, char** wordList, int wordListSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findLadders(beginWord string, endWord string, wordList []string) [][]string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findLadders(beginWord: String, endWord: String, wordList: List<String>): List<List<String>> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_ladders(begin_word: String, end_word: String, word_list: Vec<String>) -> Vec<Vec<String>> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {String[][]}\ndef find_ladders(begin_word, end_word, word_list)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return String[][]\n     */\n    function findLadders($beginWord, $endWord, $wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findLadders(beginWord: String, endWord: String, wordList: List[String]): List[List[String]] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_ladders(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: [[String.t]]\n  def find_ladders(begin_word, end_word, word_list) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_ladders(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].\nfind_ladders(BeginWord, EndWord, WordList) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-ladders beginWord endWord wordList)\n  (-> string? string? (listof string?) (listof (listof string?)))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:31:20.506798+01:00",
    "AcRate": "27.3",
    "TotalSubmissions": 1602775,
    "TotalAccepted": 438315,
    "AcceptanceRate": 0.2734725710096551,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/word-ladder-ii/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nLooking at this problem, I need to find ALL shortest transformation sequences from beginWord to endWord.\n\n## Analysis:\n\n1. **Problem Type**: Graph traversal - treating words as nodes and single-letter differences as edges\n2. **Key Patterns**: \n   - BFS to find shortest paths (level-order traversal)\n   - Backtracking/DFS to reconstruct all paths\n   - Graph construction\n3. **Constraints**: Words are short (\u22645 chars), wordList is moderate (\u2264500), need to handle multiple shortest paths\n4. **Edge Cases**: \n   - endWord not in wordList\n   - No path exists\n   - Multiple shortest paths\n   - beginWord already differs by one letter from endWord\n5. **Approach**:\n   - Use BFS to find shortest distance and build a parent map\n   - Use DFS/backtracking to reconstruct all shortest paths\n\n## Solution Strategy:\n1. First, use BFS from beginWord to find the shortest distance to each word\n2. During BFS, track all possible parents for each word at the shortest distance\n3. Use DFS from endWord backwards to reconstruct all shortest paths\n\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n```\n\n",
      "TypedCode": "\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 27298989292,
      "SolvedAt": "2025-11-20T00:05:42.199274+01:00",
      "PromptTokens": 7462,
      "OutputTokens": 2387
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "126",
        "typed_code": "\nfrom typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        \n        def getNeighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c != word[i]:\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in wordSet:\n                            neighbors.append(newWord)\n            return neighbors\n        \n        parents = defaultdict(set)\n        level = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        currentLevel = 0\n        \n        while queue and not found:\n            levelSize = len(queue)\n            currentLevel += 1\n            visitedThisLevel = set()\n            \n            for _ in range(levelSize):\n                word = queue.popleft()\n                \n                for neighbor in getNeighbors(word):\n                    if neighbor not in level:\n                        if neighbor not in visitedThisLevel:\n                            visitedThisLevel.add(neighbor)\n                            queue.append(neighbor)\n                            level[neighbor] = currentLevel\n                        parents[neighbor].add(word)\n                        \n                        if neighbor == endWord:\n                            found = True\n                    elif level[neighbor] == currentLevel:\n                        parents[neighbor].add(word)\n        \n        if endWord not in level:\n            return []\n        \n        result = []\n        path = [endWord]\n        \n        def backtrack(word):\n            if word == beginWord:\n                result.append(path[::-1])\n                return\n            \n            for parent in parents[word]:\n                path.append(parent)\n                backtrack(parent)\n                path.pop()\n        \n        backtrack(endWord)\n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T09:24:04+01:00"
    }
  }
}