{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "60",
        "questionId": "60",
        "Content": "<p>The set <code>[1, 2, 3, ...,&nbsp;n]</code> contains a total of <code>n!</code> unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>Given <code>n</code> and <code>k</code>, return the <code>k<sup>th</sup></code> permutation sequence.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 3\n<strong>Output:</strong> \"213\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 4, k = 9\n<strong>Output:</strong> \"2314\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> \"123\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n",
        "SampleTestCase": "3\n3",
        "ExampleTestcases": "3\n3\n4\n9\n3\n1",
        "Difficulty": "Hard",
        "Title": "Permutation Sequence",
        "TitleSlug": "permutation-sequence",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"524.1K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 524097, \"totalSubmissionRaw\": 1022789, \"acRate\": \"51.2%\"}",
        "Likes": 7127,
        "Dislikes": 500,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjg=",
            "Name": "Math",
            "Slug": "math"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjMx",
            "Name": "Recursion",
            "Slug": "recursion"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public String getPermutation(int n, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function getPermutation(n: number, k: number): string {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public string GetPermutation(int n, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "char* getPermutation(int n, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func getPermutation(n int, k int) string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun getPermutation(n: Int, k: Int): String {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func getPermutation(_ n: Int, _ k: Int) -> String {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn get_permutation(n: i32, k: i32) -> String {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer} n\n# @param {Integer} k\n# @return {String}\ndef get_permutation(n, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function getPermutation($n, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  String getPermutation(int n, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def getPermutation(n: Int, k: Int): String = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec get_permutation(n :: integer, k :: integer) :: String.t\n  def get_permutation(n, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec get_permutation(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_permutation(N, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (get-permutation n k)\n  (-> exact-integer? exact-integer? string?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:35:37.02878+01:00",
    "AcRate": "51.2",
    "TotalSubmissions": 1022789,
    "TotalAccepted": 524097,
    "AcceptanceRate": 0.5124194726380514,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/permutation-sequence/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nLooking at this problem, I need to find the k-th permutation of numbers 1 to n without generating all permutations.\n\n**Analysis:**\n1. **Problem Type**: Combinatorics, Math, Permutation\n2. **Key Pattern**: Factorial number system - we can determine each digit by calculating which \"block\" of permutations k falls into\n3. **Constraints**: n \u2264 9 means at most 9! = 362,880 permutations - manageable\n4. **Edge Cases**: k=1 (first permutation), k=n! (last permutation), n=1\n5. **Input/Output**: Two integers \u2192 string of digits\n6. **Difficulty**: Understanding that permutations can be built digit-by-digit using factorial blocks\n\n**Solution Approach:**\n- For n digits, there are (n-1)! permutations starting with each digit\n- Find which digit should be first by: index = (k-1) // (n-1)!\n- Remove that digit from available digits\n- Update k to position within that block: k = k % (n-1)!\n- Repeat for remaining positions\n\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n```\n\n=== DESIGN ===\nLooking at this problem, I need to find the k-th permutation without generating all permutations. The key insight is using the factorial number system to determine each digit position by position.\n\n**Algorithm Choice**: Factorial number system decomposition\n\n**Step-by-Step Approach**:\n1. Precompute factorials from 0! to (n-1)!\n2. Maintain a list of available digits (1 to n)\n3. Convert k to 0-indexed (k-1)\n4. For each position from left to right:\n   - Determine which digit to place by dividing k by the factorial of remaining positions\n   - Select that digit from available digits and add to result\n   - Remove the selected digit from available digits\n   - Update k to be the remainder for the next iteration\n\n**Data Structures**:\n- List for precomputed factorials\n- List for available digits (to maintain order and allow removal)\n- List for building result string\n\n**Time Complexity**: O(n\u00b2) - n iterations, each with O(n) list operations\n**Space Complexity**: O(n) - for factorials, available digits, and result\n\n**Pseudocode**:\n```\n1. Compute factorials[i] = i! for i from 0 to n-1\n2. Initialize available = [1, 2, ..., n]\n3. Initialize result = []\n4. Set k = k - 1 (convert to 0-indexed)\n5. For each position i from 0 to n-1:\n   a. remaining_positions = n - 1 - i\n   b. index = k // factorials[remaining_positions]\n   c. Add available[index] to result\n   d. Remove available[index] from available\n   e. k = k % factorials[remaining_positions]\n6. Return result as string\n```\n\nHere's the implementation:\n\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n```\n\n=== VERIFICATION ===\nLooking at this problem, I need to find the k-th permutation of numbers 1 to n without generating all permutations.\n\nThe approach uses the factorial number system:\n- For n digits, there are (n-1)! permutations starting with each digit\n- I can determine which digit goes in each position by calculating which \"block\" k falls into\n- Then update k for the next position\n\nLet me trace through Example 1: n=3, k=3\n- Factorials: [1, 1, 2]\n- Available: [1, 2, 3]\n- k = 3-1 = 2 (0-indexed)\n- Position 0: index = 2 // 2 = 1, pick available[1] = 2, k = 2 % 2 = 0\n- Position 1: index = 0 // 1 = 0, pick available[0] = 1, k = 0 % 1 = 0  \n- Position 2: index = 0, pick available[0] = 3\n- Result: \"213\" \u2713\n\nLet me trace through Example 2: n=4, k=9\n- Factorials: [1, 1, 2, 6]\n- Available: [1, 2, 3, 4]\n- k = 9-1 = 8\n- Position 0: index = 8 // 6 = 1, pick 2, k = 8 % 6 = 2\n- Position 1: index = 2 // 2 = 1, pick 3, k = 2 % 2 = 0\n- Position 2: index = 0 // 1 = 0, pick 1, k = 0 % 1 = 0\n- Position 3: index = 0, pick 4\n- Result: \"2314\" \u2713\n\nThe solution is correct. Here's the implementation:\n\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 29084271418,
      "SolvedAt": "2025-11-19T23:52:34.647161+01:00",
      "PromptTokens": 5235,
      "OutputTokens": 1953
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "60",
        "typed_code": "\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1]\n        for i in range(1, n):\n            factorials.append(factorials[-1] * i)\n        \n        available = list(range(1, n + 1))\n        \n        result = []\n        k -= 1\n        \n        for i in range(n):\n            factorial_idx = n - 1 - i\n            if factorial_idx == 0:\n                index = 0\n            else:\n                index = k // factorials[factorial_idx]\n                k = k % factorials[factorial_idx]\n            \n            result.append(str(available[index]))\n            available.pop(index)\n        \n        return ''.join(result)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T09:42:04+01:00"
    }
  }
}