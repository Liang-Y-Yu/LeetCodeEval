{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "901",
        "questionId": "937",
        "Content": "<p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>\n\n<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>\n\n<ul>\n\t<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>\n\t<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>\n</ul>\n\n<p>Implement the <code>StockSpanner</code> class:</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> Initializes the object of the class.</li>\n\t<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>Output</strong>\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>Explanation</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.\nstockSpanner.next(85);  // return 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "ExampleTestcases": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "Difficulty": "Medium",
        "Title": "Online Stock Span",
        "TitleSlug": "online-stock-span",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"533.2K\", \"totalSubmission\": \"780.3K\", \"totalAcceptedRaw\": 533155, \"totalSubmissionRaw\": 780342, \"acRate\": \"68.3%\"}",
        "Likes": 7070,
        "Dislikes": 486,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjE1",
            "Name": "Stack",
            "Slug": "stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU0",
            "Name": "Monotonic Stack",
            "Slug": "monotonic-stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class StockSpanner(object):\n\n    def __init__(self):\n        \n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar StockSpanner = function() {\n    \n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    \n};\n\n/** \n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class StockSpanner {\n    constructor() {\n        \n    }\n\n    next(price: number): number {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int Next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.Next(price);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} StockSpanner;\n\n\nStockSpanner* stockSpannerCreate() {\n    \n}\n\nint stockSpannerNext(StockSpanner* obj, int price) {\n    \n}\n\nvoid stockSpannerFree(StockSpanner* obj) {\n    \n}\n\n/**\n * Your StockSpanner struct will be instantiated and called as such:\n * StockSpanner* obj = stockSpannerCreate();\n * int param_1 = stockSpannerNext(obj, price);\n \n * stockSpannerFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type StockSpanner struct {\n    \n}\n\n\nfunc Constructor() StockSpanner {\n    \n}\n\n\nfunc (this *StockSpanner) Next(price int) int {\n    \n}\n\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Next(price);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class StockSpanner() {\n\n    fun next(price: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass StockSpanner {\n\n    init() {\n        \n    }\n    \n    func next(_ price: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner()\n * let ret_1: Int = obj.next(price)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct StockSpanner {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockSpanner {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn next(&self, price: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner::new();\n * let ret_1: i32 = obj.next(price);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class StockSpanner\n    def initialize()\n        \n    end\n\n\n=begin\n    :type price: Integer\n    :rtype: Integer\n=end\n    def next(price)\n        \n    end\n\n\nend\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner.new()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class StockSpanner {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $price\n     * @return Integer\n     */\n    function next($price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * $obj = StockSpanner();\n * $ret_1 = $obj->next($price);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class StockSpanner {\n\n  StockSpanner() {\n    \n  }\n  \n  int next(int price) {\n    \n  }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = StockSpanner();\n * int param1 = obj.next(price);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class StockSpanner() {\n\n    def next(price: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * val obj = new StockSpanner()\n * val param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule StockSpanner do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec next(price :: integer) :: integer\n  def next(price) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockSpanner.init_()\n# param_1 = StockSpanner.next(price)\n\n# StockSpanner.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec stock_spanner_init_() -> any().\nstock_spanner_init_() ->\n  .\n\n-spec stock_spanner_next(Price :: integer()) -> integer().\nstock_spanner_next(Price) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_spanner_init_(),\n%% Param_1 = stock_spanner_next(Price),\n\n%% stock_spanner_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define stock-spanner%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; next : exact-integer? -> exact-integer?\n    (define/public (next price)\n      )))\n\n;; Your stock-spanner% object will be instantiated and called as such:\n;; (define obj (new stock-spanner%))\n;; (define param_1 (send obj next price))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:50:37.88752+01:00",
    "AcRate": "68.3",
    "TotalSubmissions": 780342,
    "TotalAccepted": 533155,
    "AcceptanceRate": 0.683232480117692,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/online-stock-span/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nLooking at this problem, I need to:\n\n1. Track stock prices as they come in\n2. For each new price, count how many consecutive days (going backward) had prices \u2264 current price\n3. Return this count (span)\n\n**Analysis:**\n\n1. **Problem Type**: Stack, Monotonic Stack\n2. **Key Pattern**: This is a classic monotonic stack problem where we need to find the previous greater element\n3. **Constraints**: Up to 10^4 calls means O(n) per call would be acceptable, but we can do better with O(1) amortized\n4. **Edge Cases**: \n   - First element (span is always 1)\n   - Monotonically decreasing prices (each span is 1)\n   - Monotonically increasing prices (span keeps growing)\n   - Equal consecutive prices\n5. **Difficulty**: The key insight is using a monotonic stack to avoid recounting previous elements\n\n**Solution Approach:**\n\nUse a monotonic decreasing stack that stores (price, span) pairs:\n- For each new price, pop elements from stack while their price \u2264 current price\n- Sum up the spans of popped elements to get the current span\n- Push (current_price, current_span) onto stack\n\nThis works because if we pop an element with span S, it means those S days are all \u2264 current price, so we can add S to our count without checking each day individually.\n\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n```\n\n=== DESIGN ===\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n```\n\n=== IMPLEMENTATION ===\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n```\n\n=== VERIFICATION ===\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n```\n\n",
      "TypedCode": "\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 15149061708,
      "SolvedAt": "2025-11-19T23:49:31.756057+01:00",
      "PromptTokens": 5553,
      "OutputTokens": 761
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "937",
        "typed_code": "\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        \n        self.stack.append((price, span))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T08:36:59+01:00"
    }
  }
}