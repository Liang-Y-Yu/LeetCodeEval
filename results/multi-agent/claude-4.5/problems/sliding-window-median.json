{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "480",
        "questionId": "480",
        "Content": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is <code>3</code>.</li>\n\t<li>For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. There is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the median array for each window in the original array</em>. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n<strong>Explanation:</strong> \nWindow position                Median\n---------------                -----\n[<strong>1  3  -1</strong>] -3  5  3  6  7        1\n 1 [<strong>3  -1  -3</strong>] 5  3  6  7       -1\n 1  3 [<strong>-1  -3  5</strong>] 3  6  7       -1\n 1  3  -1 [<strong>-3  5  3</strong>] 6  7        3\n 1  3  -1  -3 [<strong>5  3  6</strong>] 7        5\n 1  3  -1  -3  5 [<strong>3  6  7</strong>]       6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,2,3,1,4,2], k = 3\n<strong>Output:</strong> [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "SampleTestCase": "[1,3,-1,-3,5,3,6,7]\n3",
        "ExampleTestcases": "[1,3,-1,-3,5,3,6,7]\n3\n[1,2,3,4,2,3,1,4,2]\n3",
        "Difficulty": "Hard",
        "Title": "Sliding Window Median",
        "TitleSlug": "sliding-window-median",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"205.6K\", \"totalSubmission\": \"529.8K\", \"totalAcceptedRaw\": 205634, \"totalSubmissionRaw\": 529797, \"acRate\": \"38.8%\"}",
        "Likes": 3499,
        "Dislikes": 231,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar medianSlidingWindow = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function medianSlidingWindow(nums: number[], k: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public double[] MedianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ndouble* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func medianSlidingWindow(nums []int, k int) []float64 {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun medianSlidingWindow(nums: IntArray, k: Int): DoubleArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Float[]}\ndef median_sliding_window(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Float[]\n     */\n    function medianSlidingWindow($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<double> medianSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec median_sliding_window(nums :: [integer], k :: integer) :: [float]\n  def median_sliding_window(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec median_sliding_window(Nums :: [integer()], K :: integer()) -> [float()].\nmedian_sliding_window(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (median-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof flonum?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:15:09.240796+01:00",
    "AcRate": "38.8",
    "TotalSubmissions": 529797,
    "TotalAccepted": 205634,
    "AcceptanceRate": 0.38813734317106363,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/sliding-window-median/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nLooking at this problem, I need to:\n\n1. **Problem Type Classification**: Sliding Window + Heap/Balanced Data Structure\n2. **Key Patterns & Algorithms**: Sliding Window with Two Heaps (max heap for smaller half, min heap for larger half) or sorted container\n3. **Constraints Analysis**: With n up to 10^5, we need better than O(n*k*log(k)) - ideally O(n*log(k))\n4. **Edge Cases**: k=1, k=n, negative numbers, duplicate values, even/odd k\n5. **Input/Output Analysis**: Array of integers and window size k \u2192 Array of floats (medians)\n6. **Difficulty Assessment**: Managing the sliding window efficiently while maintaining sorted order for median calculation\n\nThe key insight is to use two heaps to maintain the median efficiently:\n- A max heap for the smaller half of numbers\n- A min heap for the larger half of numbers\n- Balance them so we can quickly get the median\n\nHowever, the challenge with heaps is lazy deletion (when elements leave the window). We'll use a multiset-like approach with sorted containers or implement lazy deletion with heaps.\n\nI'll use a two-heap approach with lazy deletion using hash maps to track elements that should be removed.\n\n```python\nfrom typing import List\nimport heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        result = []\n        \n        small = []\n        large = []\n        \n        balance = 0\n        \n        to_remove = defaultdict(int)\n        \n        def add_num(num):\n            nonlocal balance\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                balance += 1\n            else:\n                heapq.heappush(large, num)\n                balance -= 1\n        \n        def remove_num(num):\n            nonlocal balance\n            to_remove[num] += 1\n            if num <= -small[0]:\n                balance -= 1\n            else:\n                balance += 1\n        \n        def rebalance():\n            nonlocal balance\n            if balance < 0:\n                heapq.heappush(small, -heapq.heappop(large))\n                balance += 2\n            elif balance > 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                balance -= 2\n        \n        def prune_top(heap):\n            while heap and to_remove[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                to_remove[val] -= 1\n        \n        def get_median():\n            prune_top(small)\n            prune_top(large)\n            \n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add_num(nums[i])\n            \n            if i >= k:\n                remove_num(nums[i - k])\n            \n            rebalance()\n            \n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n```\n\nWait, I need to reconsider the logic. Let me use a cleaner implementation with proper heap management:\n\n```python\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if num <= -small[0]:\n                small_size -= 1\n                if num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if num <= -small[0]:\n                small_size -= 1\n                if num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if num <= -small[0]:\n                small_size -= 1\n                if num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if small and num <= -small[0]:\n                small_size -= 1\n                if small and num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if large and num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n```\n\n",
      "TypedCode": "\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if num <= -small[0]:\n                small_size -= 1\n                if num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 36654040542,
      "SolvedAt": "2025-11-19T23:59:19.543553+01:00",
      "PromptTokens": 9804,
      "OutputTokens": 3231
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "480",
        "typed_code": "\nfrom typing import List\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        small = []\n        large = []\n        result = []\n        \n        delayed = Counter()\n        \n        small_size = 0\n        large_size = 0\n        \n        def prune(heap):\n            while heap and delayed[abs(heap[0])] > 0:\n                val = abs(heapq.heappop(heap))\n                delayed[val] -= 1\n        \n        def balance():\n            nonlocal small_size, large_size\n            if small_size > large_size + 1:\n                heapq.heappush(large, -heapq.heappop(small))\n                small_size -= 1\n                large_size += 1\n                prune(small)\n            elif large_size > small_size:\n                heapq.heappush(small, -heapq.heappop(large))\n                large_size -= 1\n                small_size += 1\n                prune(large)\n        \n        def add(num):\n            nonlocal small_size, large_size\n            if not small or num <= -small[0]:\n                heapq.heappush(small, -num)\n                small_size += 1\n            else:\n                heapq.heappush(large, num)\n                large_size += 1\n            balance()\n        \n        def remove(num):\n            nonlocal small_size, large_size\n            delayed[num] += 1\n            if num <= -small[0]:\n                small_size -= 1\n                if num == -small[0]:\n                    prune(small)\n            else:\n                large_size -= 1\n                if num == large[0]:\n                    prune(large)\n            balance()\n        \n        def get_median():\n            prune(small)\n            prune(large)\n            if k % 2 == 1:\n                return float(-small[0])\n            else:\n                return (-small[0] + large[0]) / 2.0\n        \n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k:\n                remove(nums[i - k])\n            if i >= k - 1:\n                result.append(get_median())\n        \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T08:13:10+01:00"
    }
  }
}