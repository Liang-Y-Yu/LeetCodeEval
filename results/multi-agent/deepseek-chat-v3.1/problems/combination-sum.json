{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "39",
        "questionId": "39",
        "Content": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>\n\n<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword=\"frequency-array\">frequency</span> of at least one of the chosen numbers is different.</p>\n\n<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,6,7], target = 7\n<strong>Output:</strong> [[2,2,3],[7]]\n<strong>Explanation:</strong>\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,5], target = 8\n<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2], target = 1\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n",
        "SampleTestCase": "[2,3,6,7]\n7",
        "ExampleTestcases": "[2,3,6,7]\n7\n[2,3,5]\n8\n[2]\n1",
        "Difficulty": "Medium",
        "Title": "Combination Sum",
        "TitleSlug": "combination-sum",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"3.8M\", \"totalAcceptedRaw\": 2853747, \"totalSubmissionRaw\": 3773877, \"acRate\": \"75.6%\"}",
        "Likes": 20520,
        "Dislikes": 516,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function combinationSum(candidates: number[], target: number): number[][] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<IList<int>> CombinationSum(int[] candidates, int target) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func combinationSum(candidates []int, target int) [][]int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum(candidates, target)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum($candidates, $target) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<List<int>> combinationSum(List<int> candidates, int target) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec combination_sum(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum(candidates, target) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec combination_sum(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum(Candidates, Target) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (combination-sum candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:37:14.509179+01:00",
    "AcRate": "75.6",
    "TotalSubmissions": 3773877,
    "TotalAccepted": 2853747,
    "AcceptanceRate": 0.7561844225447729,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/combination-sum/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n        \n        result = []\n        candidates.sort()\n        backtrack(0, [], 0)\n        return result\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Backtracking (DFS) with pruning by sorting and index tracking to avoid duplicates and unnecessary searches.\n\n**Step-by-Step Approach**:\n1. Sort the candidates to facilitate early termination when the current sum exceeds the target.\n2. Use a backtracking function that starts from a given index (to avoid duplicates and ensure combinations are generated in a non-decreasing order).\n3. At each step, add the current candidate to the path and recursively call the function with the same index (to allow reuse) and updated current sum.\n4. If the current sum equals the target, add a copy of the path to the result.\n5. If the current sum exceeds the target, backtrack by popping the last element and return.\n6. Iterate through the candidates starting from the given index to the end.\n\n**Data Structures**:\n- List to store the result (list of lists).\n- List to store the current path (which will be modified during backtracking).\n\n**Time Complexity**: O(N^(T/M + 1)) where N is the number of candidates, T is the target, and M is the minimum candidate value. This is because the depth of the recursion tree is at most T/M and each node can have up to N children.\n\n**Space Complexity**: O(T/M) for the recursion stack and the path storage. The number of combinations is bounded by the problem (less than 150).\n\n**Pseudocode**:\n1. Sort the candidates.\n2. Initialize an empty result list.\n3. Define a recursive backtrack function that takes:\n   - start index\n   - current path\n   - current sum\n4. If current sum equals target, append a copy of path to result.\n5. If current sum exceeds target, return.\n6. Loop from start index to end of candidates:\n   - Append candidate[i] to path.\n   - Recursively call backtrack with same i (to allow reuse), path, and current_sum + candidate[i].\n   - Pop the last element from path.\n7. Call backtrack with start=0, empty path, and current_sum=0.\n8. Return result.\n\nHere is the code:\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n                \n        backtrack(0, [], 0)\n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n                \n        backtrack(0, [], 0)\n        return result\n```\n\n=== VERIFICATION ===\nAfter reviewing the provided solution, I can confirm that it is correct and well-implemented. Here is my verification report:\n\n**1. Correctness**: The code correctly implements the backtracking algorithm with pruning. It generates all unique combinations by allowing reuse of the same element (by passing the same index `i` in the recursive call) and avoids duplicates by starting from the current index (which maintains non-decreasing order in the combination).\n\n**2. Edge Cases**: The code handles all edge cases:\n- When the target is smaller than all candidates (e.g., Example 3: candidates=[2], target=1) -> returns [].\n- When there are multiple combinations (e.g., Example 1 and 2).\n- The sorting step ensures that if the current sum exceeds the target, the loop breaks early (since all subsequent candidates are larger), which is efficient.\n\n**3. Complexity**: The time complexity is O(N^(T/M + 1)) and space complexity is O(T/M), which is acceptable given the constraints (target <= 40 and candidates.length <= 30). The problem also states that the number of unique combinations is less than 150, so the solution is efficient.\n\n**4. Code Quality**: The code is clean and readable. The backtracking function is defined inside the main method, which keeps the scope limited. The use of a list slice (`path[:]`) to append a copy of the path is correct to avoid reference issues.\n\n**5. Test Cases**:\n- Example 1: candidates = [2,3,6,7], target=7 -> returns [[2,2,3],[7]] (correct).\n- Example 2: candidates = [2,3,5], target=8 -> returns [[2,2,2,2],[2,3,3],[3,5]] (correct).\n- Example 3: candidates = [2], target=1 -> returns [] (correct).\n\n**6. Potential Issues**: There are no bugs or logical errors. The solution is optimal for the problem constraints.\n\nTherefore, the solution is valid and does not require any changes. Here is the code as requested (without any modifications):\n\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n                \n        backtrack(0, [], 0)\n        return result\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n                \n        backtrack(0, [], 0)\n        return result\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 20775151250,
      "SolvedAt": "2025-11-20T23:39:07.415744+01:00",
      "PromptTokens": 4217,
      "OutputTokens": 1371
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "39",
        "typed_code": "\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, current_sum):\n            if current_sum == target:\n                result.append(path[:])\n                return\n            if current_sum > target:\n                return\n            \n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, current_sum + candidates[i])\n                path.pop()\n                \n        backtrack(0, [], 0)\n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T00:59:40+01:00"
    }
  }
}