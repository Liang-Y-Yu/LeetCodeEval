{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "646",
        "questionId": "646",
        "Content": "<p>You are given an array of <code>n</code> pairs <code>pairs</code> where <code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> and <code>left<sub>i</sub> &lt; right<sub>i</sub></code>.</p>\n\n<p>A pair <code>p2 = [c, d]</code> <strong>follows</strong> a pair <code>p1 = [a, b]</code> if <code>b &lt; c</code>. A <strong>chain</strong> of pairs can be formed in this fashion.</p>\n\n<p>Return <em>the length longest chain which can be formed</em>.</p>\n\n<p>You do not need to use up all the given intervals. You can select pairs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[2,3],[3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [3,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[7,8],[4,5]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
        "SampleTestCase": "[[1,2],[2,3],[3,4]]",
        "ExampleTestcases": "[[1,2],[2,3],[3,4]]\n[[1,2],[7,8],[4,5]]",
        "Difficulty": "Medium",
        "Title": "Maximum Length of Pair Chain",
        "TitleSlug": "maximum-length-of-pair-chain",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"297.1K\", \"totalSubmission\": \"484.5K\", \"totalAcceptedRaw\": 297114, \"totalSubmissionRaw\": 484500, \"acRate\": \"61.3%\"}",
        "Likes": 4836,
        "Dislikes": 137,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int findLongestChain(int[][] pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findLongestChain(self, pairs):\n        \"\"\"\n        :type pairs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[][]} pairs\n * @return {number}\n */\nvar findLongestChain = function(pairs) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findLongestChain(pairs: number[][]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int FindLongestChain(int[][] pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int findLongestChain(int** pairs, int pairsSize, int* pairsColSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findLongestChain(pairs [][]int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findLongestChain(pairs: Array<IntArray>): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findLongestChain(_ pairs: [[Int]]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_longest_chain(pairs: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[][]} pairs\n# @return {Integer}\ndef find_longest_chain(pairs)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[][] $pairs\n     * @return Integer\n     */\n    function findLongestChain($pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int findLongestChain(List<List<int>> pairs) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findLongestChain(pairs: Array[Array[Int]]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_longest_chain(pairs :: [[integer]]) :: integer\n  def find_longest_chain(pairs) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_longest_chain(Pairs :: [[integer()]]) -> integer().\nfind_longest_chain(Pairs) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-longest-chain pairs)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:08:39.29473+01:00",
    "AcRate": "61.3",
    "TotalSubmissions": 484500,
    "TotalAccepted": 297114,
    "AcceptanceRate": 0.6132383900928793,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/maximum-length-of-pair-chain/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n**Problem Analysis:**\n\n1. **Problem Type Classification**: This problem belongs to the category of **Greedy Algorithms** and **Interval Scheduling**. It is similar to the classic \"Maximum Length of Chain of Pairs\" problem, which is often solved using greedy techniques.\n\n2. **Key Patterns & Algorithms**: The most relevant algorithmic pattern is **Greedy Selection** after sorting. The idea is to sort the pairs based on their end values (righti). Then, we traverse the sorted list and select the next pair that starts after the end of the last selected pair. This greedy approach ensures we always choose the pair that ends earliest, leaving more room for subsequent pairs.\n\n3. **Constraints Analysis**: The constraints (n <= 1000) allow for an O(n^2) solution, but the greedy approach with sorting (O(n log n)) and a linear scan (O(n)) is more efficient. The space complexity is O(1) or O(n) depending on whether we sort in-place.\n\n4. **Edge Cases**: \n   - Single pair: should return 1.\n   - All pairs overlapping: should return 1 (since only one can be chosen).\n   - Negative numbers and zero in pairs.\n   - Pairs with large gaps between them.\n\n5. **Input/Output Analysis**: The input is a list of pairs (each pair is a list of two integers). The output is an integer representing the longest chain length.\n\n6. **Difficulty Assessment**: The problem is of medium difficulty. The challenge lies in recognizing the greedy strategy (sorting by end) and implementing it correctly. The key insight is that by choosing the pair that ends earliest, we maximize the number of pairs we can chain.\n\n**Solution Code:**\n\n```python\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Greedy algorithm with sorting by the end value of each pair.\n\n**Step-by-Step Approach**:\n1. Sort the list of pairs based on the second value (righti) in ascending order. This allows us to always consider the pair that ends earliest first.\n2. Initialize a counter to 1 (for the first pair) and set the end value to the end of the first pair.\n3. Iterate through the sorted pairs starting from the second pair.\n4. For each pair, if its start value is greater than the current end value, it can be chained. Increment the counter and update the end value to the end of the current pair.\n5. After processing all pairs, return the counter.\n\n**Data Structures**: Only the input list is used. No additional data structures are required.\n\n**Time Complexity**: O(n log n) due to the sorting step. The subsequent iteration is O(n), so overall it is dominated by sorting.\n\n**Space Complexity**: O(1) if we sort in-place (without using additional space for sorting). However, the sorting algorithm in Python (Timsort) uses O(n) space in the worst case. So overall space complexity is O(n).\n\n**Pseudocode**:\n```\nSort pairs by the second element (right value)\nInitialize count = 1\nSet current_end = first pair's right value\nFor i from 1 to n-1:\n    if pairs[i][0] > current_end:\n        count += 1\n        current_end = pairs[i][1]\nReturn count\n```\n\n**Solution Code**:\n```python\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n```\n\n=== VERIFICATION ===\n**Verification Report**\n\n1. **Correctness**: The code correctly implements the greedy algorithm by sorting pairs based on the end value and then building the chain by selecting pairs that start after the last selected pair's end. This is the standard solution for the problem.\n2. **Edge Cases**:\n   - Single pair: Returns 1 (correct).\n   - All pairs overlapping: Only one pair will be selected (correct).\n   - Negative numbers and zero: Handled correctly because comparisons work with negatives.\n   - Large gaps: The greedy approach naturally handles gaps.\n3. **Complexity**: The sorting step is O(n log n) and the loop is O(n), so overall time complexity is O(n log n). Space complexity is O(1) for variables and O(n) for sorting (which is acceptable). This meets expectations.\n4. **Code Quality**: The code is clean, readable, and follows Python best practices. It uses a lambda for sorting and a simple loop. Variable names are clear.\n5. **Test Cases**:\n   - Example 1: [[1,2],[2,3],[3,4]] -> sorted by end: same order. Chain: [1,2] (end=2) -> [3,4] (since 3>2). Count=2 (correct).\n   - Example 2: [[1,2],[7,8],[4,5]] -> sorted by end: [[1,2],[4,5],[7,8]]. Chain: [1,2] (end=2) -> [4,5] (4>2, end=5) -> [7,8] (7>5). Count=3 (correct).\n6. **Potential Issues**: None. The solution is optimal and correct.\n\n**Conclusion**: The solution is valid and passes all checks. No changes are needed.\n\nFinal code:\n```python\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 34140741376,
      "SolvedAt": "2025-11-21T00:05:23.113001+01:00",
      "PromptTokens": 4611,
      "OutputTokens": 1433
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "646",
        "typed_code": "\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        count = 1\n        end = pairs[0][1]\n        for i in range(1, len(pairs)):\n            if pairs[i][0] > end:\n                count += 1\n                end = pairs[i][1]\n        return count\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T01:29:30+01:00"
    }
  }
}