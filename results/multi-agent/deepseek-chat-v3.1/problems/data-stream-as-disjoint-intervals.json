{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "352",
        "questionId": "352",
        "Content": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n",
        "SampleTestCase": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "ExampleTestcases": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "Difficulty": "Hard",
        "Title": "Data Stream as Disjoint Intervals",
        "TitleSlug": "data-stream-as-disjoint-intervals",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"125.3K\", \"totalSubmission\": \"209.8K\", \"totalAcceptedRaw\": 125278, \"totalSubmissionRaw\": 209830, \"acRate\": \"59.7%\"}",
        "Likes": 1795,
        "Dislikes": 371,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIz",
            "Name": "Union Find",
            "Slug": "union-find"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcw",
            "Name": "Ordered Set",
            "Slug": "ordered-set"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class SummaryRanges {\npublic:\n    SummaryRanges() {\n        \n    }\n    \n    void addNum(int value) {\n        \n    }\n    \n    vector<vector<int>> getIntervals() {\n        \n    }\n};\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges* obj = new SummaryRanges();\n * obj->addNum(value);\n * vector<vector<int>> param_2 = obj->getIntervals();\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void addNum(int value) {\n        \n    }\n    \n    public int[][] getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(value);\n * int[][] param_2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class SummaryRanges(object):\n\n    def __init__(self):\n        \n\n    def addNum(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getIntervals(self):\n        \"\"\"\n        :rtype: List[List[int]]\n        \"\"\"\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar SummaryRanges = function() {\n    \n};\n\n/** \n * @param {number} value\n * @return {void}\n */\nSummaryRanges.prototype.addNum = function(value) {\n    \n};\n\n/**\n * @return {number[][]}\n */\nSummaryRanges.prototype.getIntervals = function() {\n    \n};\n\n/** \n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class SummaryRanges {\n    constructor() {\n        \n    }\n\n    addNum(value: number): void {\n        \n    }\n\n    getIntervals(): number[][] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void AddNum(int value) {\n        \n    }\n    \n    public int[][] GetIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.AddNum(value);\n * int[][] param_2 = obj.GetIntervals();\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} SummaryRanges;\n\n\nSummaryRanges* summaryRangesCreate() {\n    \n}\n\nvoid summaryRangesAddNum(SummaryRanges* obj, int value) {\n    \n}\n\nint** summaryRangesGetIntervals(SummaryRanges* obj, int* retSize, int** retColSize) {\n    \n}\n\nvoid summaryRangesFree(SummaryRanges* obj) {\n    \n}\n\n/**\n * Your SummaryRanges struct will be instantiated and called as such:\n * SummaryRanges* obj = summaryRangesCreate();\n * summaryRangesAddNum(obj, value);\n \n * int** param_2 = summaryRangesGetIntervals(obj, retSize, retColSize);\n \n * summaryRangesFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type SummaryRanges struct {\n    \n}\n\n\nfunc Constructor() SummaryRanges {\n    \n}\n\n\nfunc (this *SummaryRanges) AddNum(value int)  {\n    \n}\n\n\nfunc (this *SummaryRanges) GetIntervals() [][]int {\n    \n}\n\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddNum(value);\n * param_2 := obj.GetIntervals();\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class SummaryRanges() {\n\n    fun addNum(value: Int) {\n        \n    }\n\n    fun getIntervals(): Array<IntArray> {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass SummaryRanges {\n\n    init() {\n        \n    }\n    \n    func addNum(_ value: Int) {\n        \n    }\n    \n    func getIntervals() -> [[Int]] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges()\n * obj.addNum(value)\n * let ret_2: [[Int]] = obj.getIntervals()\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct SummaryRanges {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SummaryRanges {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add_num(&self, value: i32) {\n        \n    }\n    \n    fn get_intervals(&self) -> Vec<Vec<i32>> {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges::new();\n * obj.add_num(value);\n * let ret_2: Vec<Vec<i32>> = obj.get_intervals();\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class SummaryRanges\n    def initialize()\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Void\n=end\n    def add_num(value)\n        \n    end\n\n\n=begin\n    :rtype: Integer[][]\n=end\n    def get_intervals()\n        \n    end\n\n\nend\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges.new()\n# obj.add_num(value)\n# param_2 = obj.get_intervals()"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class SummaryRanges {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return NULL\n     */\n    function addNum($value) {\n        \n    }\n  \n    /**\n     * @return Integer[][]\n     */\n    function getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * $obj = SummaryRanges();\n * $obj->addNum($value);\n * $ret_2 = $obj->getIntervals();\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class SummaryRanges {\n\n  SummaryRanges() {\n    \n  }\n  \n  void addNum(int value) {\n    \n  }\n  \n  List<List<int>> getIntervals() {\n    \n  }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = SummaryRanges();\n * obj.addNum(value);\n * List<List<int>> param2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class SummaryRanges() {\n\n    def addNum(value: Int): Unit = {\n        \n    }\n\n    def getIntervals(): Array[Array[Int]] = {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * val obj = new SummaryRanges()\n * obj.addNum(value)\n * val param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule SummaryRanges do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add_num(value :: integer) :: any\n  def add_num(value) do\n    \n  end\n\n  @spec get_intervals() :: [[integer]]\n  def get_intervals() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SummaryRanges.init_()\n# SummaryRanges.add_num(value)\n# param_2 = SummaryRanges.get_intervals()\n\n# SummaryRanges.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec summary_ranges_init_() -> any().\nsummary_ranges_init_() ->\n  .\n\n-spec summary_ranges_add_num(Value :: integer()) -> any().\nsummary_ranges_add_num(Value) ->\n  .\n\n-spec summary_ranges_get_intervals() -> [[integer()]].\nsummary_ranges_get_intervals() ->\n  .\n\n\n%% Your functions will be called as such:\n%% summary_ranges_init_(),\n%% summary_ranges_add_num(Value),\n%% Param_2 = summary_ranges_get_intervals(),\n\n%% summary_ranges_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define summary-ranges%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add-num : exact-integer? -> void?\n    (define/public (add-num value)\n      )\n    ; get-intervals : -> (listof (listof exact-integer?))\n    (define/public (get-intervals)\n      )))\n\n;; Your summary-ranges% object will be instantiated and called as such:\n;; (define obj (new summary-ranges%))\n;; (send obj add-num value)\n;; (define param_2 (send obj get-intervals))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:21:39.253726+01:00",
    "AcRate": "59.7",
    "TotalSubmissions": 209830,
    "TotalAccepted": 125278,
    "AcceptanceRate": 0.5970452270885955,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "multi",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nfrom bisect import bisect_left, bisect_right\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        # Find the position where the new value should be inserted\n        left = bisect_left(self.intervals, [value, value])\n        right = bisect_right(self.intervals, [value, value])\n        \n        # Check if the value is already covered by an existing interval\n        if left > 0 and self.intervals[left-1][1] >= value:\n            return  # Value already in an interval\n        \n        # Check if we can merge with left interval\n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        # Check if we can merge with right interval\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            # Merge both sides\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            # Extend left interval\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            # Extend right interval (by lowering its start)\n            self.intervals[left][0] = value\n        else:\n            # Insert new interval\n            self.intervals.insert(left, [value, value])\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n```\n\n=== DESIGN ===\nGiven the problem and analysis, we need to efficiently maintain disjoint intervals as we add numbers one by one. The key challenge is to merge intervals correctly when adding a new number.\n\n### Algorithm Choice\nWe will use a sorted list of disjoint intervals. For each new number, we will:\n1. Check if it is already covered by an existing interval.\n2. If not, check if it can be merged with the left interval (if the number is exactly one more than the end of the left interval) and/or the right interval (if the number is exactly one less than the start of the right interval).\n3. Merge both sides if possible, or extend one side, or insert a new interval.\n\nWe will use binary search (via `bisect_left` and `bisect_right`) to efficiently find the position where the new value should be inserted.\n\n### Step-by-Step Approach\n1. **Initialize** an empty list to store the disjoint intervals.\n2. **addNum(value)**:\n   - Use `bisect_left` to find the index `left` where the interval [value, value] would be inserted.\n   - Check if the value is already in an existing interval (specifically, if the previous interval ends at or after `value`).\n   - Check for merges with the left and right intervals:\n        - `merge_left`: if there is a left interval and its end + 1 equals `value`.\n        - `merge_right`: if there is a right interval and its start - 1 equals `value`.\n   - If both merges are possible, merge the left and right intervals by extending the left interval to the end of the right interval and remove the right interval.\n   - If only left merge is possible, extend the left interval to `value`.\n   - If only right merge is possible, extend the right interval to start at `value`.\n   - Otherwise, insert a new interval [value, value] at the correct position.\n3. **getIntervals()**: Return the list of intervals.\n\n### Data Structures\n- A list `intervals` to store the disjoint intervals. Each interval is represented as [start, end].\n\n### Time Complexity\n- `addNum`: O(N) per operation in the worst case due to list insertion/deletion. However, since the number of intervals is small (due to merges) and we use binary search (O(log N)) to find the position, the overall cost is acceptable given the constraints.\n- `getIntervals`: O(1) if we return the list directly (but note that the problem says at most 100 calls to `getIntervals`).\n\n### Space Complexity\n- O(K) where K is the number of disjoint intervals. In the worst case, if there are no merges, K could be up to the number of distinct values added (but typically merges reduce this).\n\n### Pseudocode\n```\nInitialize:\n    intervals = empty list\n\naddNum(value):\n    left = bisect_left(intervals, [value, value])\n    right = bisect_right(intervals, [value, value])\n\n    if left > 0 and intervals[left-1][1] >= value:\n        return   # already covered\n\n    merge_left = (left > 0) and (intervals[left-1][1] + 1 == value)\n    merge_right = (left < len(intervals)) and (intervals[left][0] - 1 == value)\n\n    if merge_left and merge_right:\n        intervals[left-1][1] = intervals[left][1]\n        remove intervals[left]\n    else if merge_left:\n        intervals[left-1][1] = value\n    else if merge_right:\n        intervals[left][0] = value\n    else:\n        insert [value, value] at position left\n\ngetIntervals():\n    return intervals\n```\n\nNow, we implement the code accordingly.\n\n```python\nfrom bisect import bisect_left, bisect_right\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        left = bisect_left(self.intervals, [value, value])\n        right = bisect_right(self.intervals, [value, value])\n        \n        if left > 0 and self.intervals[left-1][1] >= value:\n            return\n        \n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            self.intervals[left][0] = value\n        else:\n            self.intervals.insert(left, [value, value])\n            \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom bisect import bisect_left, bisect_right\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        left = bisect_left(self.intervals, [value, value])\n        right_val = bisect_right(self.intervals, [value, value])\n        \n        if left > 0 and self.intervals[left-1][1] >= value:\n            return\n        \n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            self.intervals[left][0] = value\n        else:\n            self.intervals.insert(left, [value, value])\n            \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n```\n\n=== VERIFICATION ===\nLooking at the analysis and the implemented code, I can see that the solution is mostly correct but has one small issue in the binary search usage. Let me verify the solution step by step.\n\n### Verification Report:\n\n**1. Correctness:**\nThe algorithm design is sound and follows the intended approach. However, there's an issue with the `right_val` variable in `addNum` - it's calculated but never used. The `bisect_right` call should actually be replaced with a check for the right interval at index `left` (which is already done correctly).\n\n**2. Edge Cases:**\n- Adding duplicate values: Handled correctly (returns early if already in an interval)\n- Adding values that connect two intervals: Handled correctly with the merge logic\n- Empty stream: Handled correctly (initial empty list)\n- Consecutive values: Should merge properly\n\n**3. Complexity:**\n- Time: O(n) per addNum in worst case due to list insertion, but with binary search for positioning\n- Space: O(k) where k is number of intervals\n- Meets constraints (30k calls to addNum, 100 calls to getIntervals)\n\n**4. Code Quality:**\n- Clean and readable\n- Good variable naming (except for unused `right_val`)\n- Proper use of bisect functions\n\n**5. Test Cases:**\nLet's walk through the example:\n- Start: intervals = []\n- addNum(1): inserts [1,1] \u2192 intervals = [[1,1]]\n- addNum(3): inserts [3,3] \u2192 intervals = [[1,1], [3,3]]\n- addNum(7): inserts [7,7] \u2192 intervals = [[1,1], [3,3], [7,7]]\n- addNum(2): \n  - Can merge with left (1+1=2) and right (3-1=2)\n  - Merges both: becomes [[1,3], [7,7]]\n- addNum(6):\n  - Can merge with right (7-1=6)\n  - Extends right interval: becomes [[1,3], [6,7]]\n\nThis matches the expected output.\n\n**6. Issues Found:**\nThe only issue is the unused `right_val` variable from `bisect_right`. This is unnecessary and can be removed to clean up the code.\n\n### Fixed Code:\n\n```python\nfrom bisect import bisect_left\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        left = bisect_left(self.intervals, [value, value])\n        \n        if left > 0 and self.intervals[left-1][1] >= value:\n            return\n        \n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            self.intervals[left][0] = value\n        else:\n            self.intervals.insert(left, [value, value])\n            \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n```\n\n",
      "TypedCode": "\nfrom bisect import bisect_left, bisect_right\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        left = bisect_left(self.intervals, [value, value])\n        right_val = bisect_right(self.intervals, [value, value])\n        \n        if left > 0 and self.intervals[left-1][1] >= value:\n            return\n        \n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            self.intervals[left][0] = value\n        else:\n            self.intervals.insert(left, [value, value])\n            \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 28594863418,
      "SolvedAt": "2025-11-20T23:47:46.944398+01:00",
      "PromptTokens": 7402,
      "OutputTokens": 2381
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "352",
        "typed_code": "\nfrom bisect import bisect_left, bisect_right\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        left = bisect_left(self.intervals, [value, value])\n        right_val = bisect_right(self.intervals, [value, value])\n        \n        if left > 0 and self.intervals[left-1][1] >= value:\n            return\n        \n        merge_left = left > 0 and self.intervals[left-1][1] + 1 == value\n        merge_right = left < len(self.intervals) and self.intervals[left][0] - 1 == value\n        \n        if merge_left and merge_right:\n            self.intervals[left-1][1] = self.intervals[left][1]\n            self.intervals.pop(left)\n        elif merge_left:\n            self.intervals[left-1][1] = value\n        elif merge_right:\n            self.intervals[left][0] = value\n        else:\n            self.intervals.insert(left, [value, value])\n            \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T03:36:16+01:00"
    }
  }
}