{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "2300",
        "questionId": "2392",
        "Content": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>\n\n<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>\n\n<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<strong>Output:</strong> [4,0,3]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.\nThus, [4,0,3] is returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16\n<strong>Output:</strong> [2,0,2]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[5,1,3]\n[1,2,3,4,5]\n7",
        "ExampleTestcases": "[5,1,3]\n[1,2,3,4,5]\n7\n[3,1,2]\n[8,5,8]\n16",
        "Difficulty": "Medium",
        "Title": "Successful Pairs of Spells and Potions",
        "TitleSlug": "successful-pairs-of-spells-and-potions",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"362.7K\", \"totalSubmission\": \"736.4K\", \"totalAcceptedRaw\": 362706, \"totalSubmissionRaw\": 736363, \"acRate\": \"49.3%\"}",
        "Likes": 3151,
        "Dislikes": 104,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjk=",
            "Name": "Two Pointers",
            "Slug": "two-pointers"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def successfulPairs(self, spells, potions, success):\n        \"\"\"\n        :type spells: List[int]\n        :type potions: List[int]\n        :type success: int\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} spells\n * @param {number[]} potions\n * @param {number} success\n * @return {number[]}\n */\nvar successfulPairs = function(spells, potions, success) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function successfulPairs(spells: number[], potions: number[], success: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func successfulPairs(spells []int, potions []int, success int64) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun successfulPairs(spells: IntArray, potions: IntArray, success: Long): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn successful_pairs(spells: Vec<i32>, potions: Vec<i32>, success: i64) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} spells\n# @param {Integer[]} potions\n# @param {Integer} success\n# @return {Integer[]}\ndef successful_pairs(spells, potions, success)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $spells\n     * @param Integer[] $potions\n     * @param Integer $success\n     * @return Integer[]\n     */\n    function successfulPairs($spells, $potions, $success) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> successfulPairs(List<int> spells, List<int> potions, int success) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def successfulPairs(spells: Array[Int], potions: Array[Int], success: Long): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec successful_pairs(spells :: [integer], potions :: [integer], success :: integer) :: [integer]\n  def successful_pairs(spells, potions, success) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec successful_pairs(Spells :: [integer()], Potions :: [integer()], Success :: integer()) -> [integer()].\nsuccessful_pairs(Spells, Potions, Success) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (successful-pairs spells potions success)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T13:40:29.830982+01:00",
    "AcRate": "49.3",
    "TotalSubmissions": 736363,
    "TotalAccepted": 362706,
    "AcceptanceRate": 0.4925641293764081,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/successful-pairs-of-spells-and-potions/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nLooking at this problem, we need to find for each spell, how many potions when multiplied with it give a product \u2265 success.\n\n**1. Problem Type Classification**: \n- Array\n- Binary Search\n- Sorting\n\n**2. Key Patterns & Algorithms**:\n- The key insight is that for each spell `s`, we need to find all potions `p` where `s * p \u2265 success`\n- Rearranging: `p \u2265 ceil(success / s)` (with careful handling of integer division)\n- We can sort the potions array and use binary search to efficiently count the number of potions meeting this condition for each spell\n- This avoids the O(n*m) brute force approach\n\n**3. Constraints Analysis**:\n- Both arrays can have up to 10^5 elements\n- Brute force O(n*m) would be 10^10 operations - too slow\n- Sorting potions: O(m log m)\n- Binary search for each spell: O(n log m)\n- Total: O((n + m) log m) which is efficient enough\n\n**4. Edge Cases**:\n- Very large success value that exceeds maximum possible product\n- Very small spells that make success threshold impossible to reach\n- Duplicate values in spells or potions\n- Integer division edge cases (rounding up/down)\n\n**5. Input/Output Analysis**:\n- Input: two integer arrays and an integer\n- Output: integer array of same length as spells\n\n**6. Difficulty Assessment**:\n- Medium difficulty\n- Requires recognizing the binary search optimization\n- Needs careful handling of integer division and boundary conditions\n\n```python\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        n = len(spells)\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            \n            if target > potions[-1]:\n                result.append(0)\n                continue\n                \n            left, right = 0, m - 1\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            \n            result.append(m - left)\n        \n        return result\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Sorting and Binary Search\n\n**Step-by-Step Approach**:\n1. Sort the potions array to enable binary search.\n2. For each spell, calculate the minimum potion strength required to achieve success. This is given by `ceil(success / spell)`. Use integer arithmetic: `(success + spell - 1) // spell`.\n3. If this minimum required value exceeds the largest potion, no potion pairs successfully with the spell.\n4. Otherwise, perform a binary search on the sorted potions to find the first index where the potion strength is at least the minimum required value.\n5. The number of successful pairs for the spell is the number of potions from that index to the end.\n\n**Data Structures**:\n- Sorted list for potions.\n- List to store results.\n\n**Time Complexity**:\n- Sorting the potions: O(m log m)\n- Processing each spell with binary search: O(n log m)\n- Overall: O((n + m) log m)\n\n**Space Complexity**:\n- O(1) additional space (excluding input and output).\n\n**Pseudocode**:\n1. Sort the potions array.\n2. Initialize an empty result list.\n3. For each spell in spells:\n   - Compute min_potion = ceil(success / spell)\n   - If min_potion > max(potions): append 0 to result.\n   - Else:\n        Use binary search to find the leftmost index i such that potions[i] >= min_potion.\n        Append (number of potions from i to end) to result.\n4. Return result.\n\n```python\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        n = len(spells)\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            if target > potions[-1]:\n                result.append(0)\n                continue\n            left, right = 0, m\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(m - left)\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            if target > potions[-1]:\n                result.append(0)\n                continue\n            left, right = 0, m\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(m - left)\n        \n        return result\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            left, right = 0, m\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(m - left)\n        \n        return result\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            if target > potions[-1]:\n                result.append(0)\n                continue\n            left, right = 0, m\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(m - left)\n        \n        return result\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 32464594833,
      "SolvedAt": "2025-11-21T00:44:14.747101+01:00",
      "PromptTokens": 6064,
      "OutputTokens": 1282
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "2392",
        "typed_code": "\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        result = []\n        \n        for spell in spells:\n            target = (success + spell - 1) // spell\n            if target > potions[-1]:\n                result.append(0)\n                continue\n            left, right = 0, m\n            while left < right:\n                mid = (left + right) // 2\n                if potions[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(m - left)\n        \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T03:33:05+01:00"
    }
  }
}