{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "713",
        "questionId": "713",
        "Content": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than </em><code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,5,2,6], k = 100\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], k = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[10,5,2,6]\n100",
        "ExampleTestcases": "[10,5,2,6]\n100\n[1,2,3]\n0",
        "Difficulty": "Medium",
        "Title": "Subarray Product Less Than K",
        "TitleSlug": "subarray-product-less-than-k",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"548.5K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 548479, \"totalSubmissionRaw\": 1026034, \"acRate\": \"53.5%\"}",
        "Likes": 7347,
        "Dislikes": 233,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDY4",
            "Name": "Prefix Sum",
            "Slug": "prefix-sum"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def numSubarrayProductLessThanK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar numSubarrayProductLessThanK = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function numSubarrayProductLessThanK(nums: number[], k: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int NumSubarrayProductLessThanK(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int numSubarrayProductLessThanK(int* nums, int numsSize, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func numSubarrayProductLessThanK(nums []int, k int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun numSubarrayProductLessThanK(nums: IntArray, k: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func numSubarrayProductLessThanK(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn num_subarray_product_less_than_k(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef num_subarray_product_less_than_k(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function numSubarrayProductLessThanK($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int numSubarrayProductLessThanK(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def numSubarrayProductLessThanK(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec num_subarray_product_less_than_k(nums :: [integer], k :: integer) :: integer\n  def num_subarray_product_less_than_k(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec num_subarray_product_less_than_k(Nums :: [integer()], K :: integer()) -> integer().\nnum_subarray_product_less_than_k(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (num-subarray-product-less-than-k nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:05:22.156634+01:00",
    "AcRate": "53.5",
    "TotalSubmissions": 1026034,
    "TotalAccepted": 548479,
    "AcceptanceRate": 0.5345622074902001,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/subarray-product-less-than-k/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nProblem Type Classification: Array, Sliding Window\n\nKey Patterns & Algorithms: Sliding Window technique. We can use a two-pointer approach to maintain a window where the product of all elements is less than k. For each right pointer, we expand the window until the product becomes >= k, then we adjust the left pointer. The number of subarrays ending at the right pointer and starting from any index between left and right is (right - left + 1).\n\nConstraints Analysis: With n <= 30000, we need an O(n) solution. The sliding window approach achieves O(n) time and O(1) space.\n\nEdge Cases: \n1. k <= 1: Since nums[i] >= 1, if k <= 1, no subarray can have product < k (except k=0, but product is always positive, so output 0).\n2. Large numbers: But product might overflow? However, since k <= 10^6, and we break when product >= k, we avoid large numbers.\n\nInput/Output Analysis: The input is a list of integers and an integer k. The output is an integer count.\n\nDifficulty Assessment: Medium. The challenge is to avoid O(n^2) brute force and to correctly count the subarrays without missing or duplicating.\n\n```python\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product /= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n```\n\n=== DESIGN ===\n\n```python\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n```\n\n=== VERIFICATION ===\nI will verify the provided solution step by step.\n\n### 1. **Correctness**\nThe code uses a sliding window approach to count the number of contiguous subarrays with product less than k. For each right pointer, it expands the window and adjusts the left pointer when the product becomes >= k. The number of subarrays ending at `right` is `(right - left + 1)`, which is added to the count. This correctly counts all valid subarrays without duplication. The logic aligns with the standard solution for this problem.\n\n### 2. **Edge Cases**\n- **k <= 1**: The code checks for `k <= 1` and returns 0. This is correct because all numbers are at least 1 (positive), so the product of any subarray is at least 1. Therefore, if k <= 1, no subarray has product < k.\n- **Empty array**: The constraints say `nums.length >= 1`, so no need to handle empty.\n- **Large numbers**: The code uses integer division (`//`) when adjusting the product by dividing by `nums[left]`. This avoids floating point inaccuracies (which might occur with `/`). However, note that the problem states `nums[i]` are integers, so integer division is safe and correct.\n\n### 3. **Complexity**\n- Time: The algorithm traverses the array once with the right pointer, and each element is processed at most twice (once by right and once by left). So it is O(n).\n- Space: Only a few variables are used, so O(1) space.\n\n### 4. **Code Quality**\n- The code is clean and readable.\n- Variable names are meaningful (`left`, `right`, `product`, `count`).\n- The logic is straightforward and efficient.\n\n### 5. **Test Cases**\n- **Example 1**: `nums = [10,5,2,6]`, `k=100`\n  - right=0: product=10, valid -> count += 1 (subarray [10])\n  - right=1: product=50, valid -> count += 2 (subarrays [5] and [10,5])\n  - right=2: product=100 -> too big, so adjust: divide by nums[0]=10 -> product=10, left=1 -> valid? 10 < 100? Yes. Then count += 2 (subarrays [2] and [5,2])\n  - right=3: product=60, valid -> count += 3 (subarrays [6], [2,6], [5,2,6])\n  - Total = 1 + 2 + 2 + 3 = 8 -> correct.\n\n- **Example 2**: `nums = [1,2,3]`, `k=0`\n  - k=0 <=1, so return 0 -> correct.\n\n### 6. **Potential Issues**\n- The original code used `/` (float division) which might cause precision issues for large integers? However, the problem says `nums[i]` are integers, and k is integer. But when we divide, we want integer division. The implemented code correctly uses `//` (integer division) instead of `/`. So no issue.\n\n### Verification Report:\nThe solution is **correct** and efficient. It handles all edge cases and constraints properly. The code quality is good. No changes are needed.\n\nFinal code (as provided):\n```python\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 22206012166,
      "SolvedAt": "2025-11-21T00:43:42.276753+01:00",
      "PromptTokens": 3768,
      "OutputTokens": 1419
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "713",
        "typed_code": "\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        if k <= 1:\n            return 0\n        left = 0\n        product = 1\n        count = 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T03:14:02+01:00"
    }
  }
}