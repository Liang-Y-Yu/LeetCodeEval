{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "239",
        "questionId": "239",
        "Content": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "SampleTestCase": "[1,3,-1,-3,5,3,6,7]\n3",
        "ExampleTestcases": "[1,3,-1,-3,5,3,6,7]\n3\n[1]\n1",
        "Difficulty": "Hard",
        "Title": "Sliding Window Maximum",
        "TitleSlug": "sliding-window-maximum",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1500044, \"totalSubmissionRaw\": 3117997, \"acRate\": \"48.1%\"}",
        "Likes": 19886,
        "Dislikes": 799,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjM0",
            "Name": "Queue",
            "Slug": "queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcx",
            "Name": "Monotonic Queue",
            "Slug": "monotonic-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxSlidingWindow(nums: number[], k: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxSlidingWindow(nums []int, k int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sliding_window(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> maxSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]\n  def max_sliding_window(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sliding_window(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:25:34.534997+01:00",
    "AcRate": "48.1",
    "TotalSubmissions": 3117997,
    "TotalAccepted": 1500044,
    "AcceptanceRate": 0.48109218835040574,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/sliding-window-maximum/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n**Problem Type Classification**: Array, Sliding Window, Queue\n\n**Key Patterns & Algorithms**: \n- This problem requires efficiently tracking the maximum in a sliding window. \n- A brute force approach would be O(n*k) which is too slow for the constraints (n up to 10^5).\n- The optimal solution uses a deque (double-ended queue) to maintain indices of potentially maximum elements. This technique is known as the \"Monotonic Queue\" pattern.\n- The deque is maintained such that elements are in decreasing order (from front to back) and only relevant indices (within the current window and larger than subsequent elements) are kept.\n\n**Constraints Analysis**:\n- The array length can be up to 100,000, so the solution must be efficient, ideally O(n).\n- The deque approach processes each element exactly once (each element is pushed and popped at most once), leading to O(n) time complexity.\n- Space complexity is O(n) for storing the result and O(k) for the deque.\n\n**Edge Cases**:\n- k = 1: each window has one element, so the result is the same as the input array.\n- k = len(nums): only one window, return the maximum of the entire array.\n- Decreasing sequence: e.g., [5,4,3,2,1], k=3 -> outputs [5,4,3].\n- Increasing sequence: e.g., [1,2,3,4,5], k=3 -> outputs [3,4,5].\n- Array with negative numbers.\n\n**Input/Output Analysis**:\n- Input: List of integers `nums`, integer `k`.\n- Output: List of integers representing the maximums for each window.\n\n**Difficulty Assessment**: \n- The challenge is to achieve linear time complexity. Without the deque technique, it is difficult to pass the large constraints. Properly managing the deque (removing out-of-window indices and maintaining decreasing order) requires careful implementation.\n\nSolution Code:\n```python\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            while dq and dq[0] < i - k + 1:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n```\n\n=== DESIGN ===\n**Algorithm Choice**:  \nWe will use a deque (double-ended queue) to maintain indices of the array in such a way that the front of the deque always has the index of the maximum value for the current window. This approach efficiently tracks the maximum by removing elements that are out of the window and those that are smaller than the current element.\n\n**Step-by-Step Approach**:\n1. Initialize an empty deque and a result list.\n2. Iterate through each index in the array.\n3. Remove indices from the front of the deque that are out of the current window (i.e., indices less than `i - k + 1`).\n4. Remove indices from the back of the deque if the value at that index is less than the current value (since they cannot be the maximum in any future window).\n5. Append the current index to the deque.\n6. Once we have processed at least `k` elements (i.e., when `i >= k-1`), the front of the deque holds the index of the maximum value for the current window. Append that value to the result.\n7. Return the result list.\n\n**Data Structures**:\n- Deque: To store indices of elements in decreasing order of their values (so the front is always the maximum).\n- List: To store the result (max values for each window).\n\n**Time Complexity**: O(n) - Each element is pushed and popped from the deque at most once.\n\n**Space Complexity**: O(n) - The deque can store up to O(k) elements, and the result list has O(n) elements.\n\n**Pseudocode**:\n```\nInitialize an empty deque dq\nInitialize an empty list result\nFor i from 0 to len(nums)-1:\n    While dq is not empty and the front index is out of the current window (index < i - k + 1):\n        Pop from the front\n    While dq is not empty and the value at the back index is less than nums[i]:\n        Pop from the back\n    Append i to the back of dq\n    If i >= k-1:\n        Append nums[front of dq] to result\nReturn result\n```\n\n```python\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n```\n\n=== VERIFICATION ===\nAfter reviewing the provided solution, I can confirm that it is correct and efficient. However, I noticed a small issue in the condition for removing the front element. The condition `if dq and dq[0] == i - k` is slightly off because it should remove indices that are less than `i - k + 1` (or exactly `i - k` is also correct because the window is from `i - k + 1` to `i`). Actually, the condition `dq[0] == i - k` is correct because the index at the front should be removed when it is exactly one position before the current window (i.e., the window starts at `i - k + 1`, so the index `i - k` is just left of the window). This is a valid approach.\n\nBut let me verify with an example: \nFor k=3, when i=3, the window is from index 1 to 3. The index to remove is 0 (i-k=3-3=0). So the condition `dq[0] == i - k` works. However, if there are multiple elements to remove? Actually, the deque is maintained such that only one element is removed per step (if it is exactly the one leaving the window). This is because we always remove the front when it is exactly the index that is leaving the window. Since we traverse one index at a time, only one index becomes outdated per step.\n\nTherefore, the code is correct.\n\nBut note: the original design had `while dq and dq[0] < i - k + 1` which would remove all outdated indices. However, the implemented code uses `if dq and dq[0] == i - k` which removes only one index. This is sufficient because at each step only one index becomes outdated (the one that is exactly i-k). Why? Because the window moves one step at a time. So the index that leaves the window is exactly i-k. So the condition is correct and efficient.\n\nNow, let's test with the provided examples:\n\nExample 1: nums = [1,3,-1,-3,5,3,6,7], k=3\ni=0: dq=[0], no output.\ni=1: remove? dq[0]=0 != 1-3=-2 -> no remove. Then compare: nums[0]=1 < nums[1]=3 -> pop from back. Then dq=[1]. No output.\ni=2: remove? dq[0]=1 != 2-3=-1 -> no remove. Then compare: nums[1]=3 > nums[2]=-1 -> no pop. Then dq=[1,2]. Output: nums[1]=3 -> result=[3]\ni=3: remove? dq[0]=1 == 3-3=0? no (1 !=0). Then compare: nums[2]=-1 > nums[3]=-3? no, but actually -1 > -3, so no pop? But wait, we need to remove smaller ones? Actually, we remove from the back if the value is less than current. Here nums[2]=-1 is greater than nums[3]=-3, so we don't pop. Then dq=[1,2,3]. Now output: nums[1]=3 -> result=[3,3]\nBut wait, the window at i=3 is [3,-1,-3] so max is 3. Correct.\n\nNow i=4: remove? dq[0]=1 == 4-3=1? yes. So pop front -> dq=[2,3]. Then compare: nums[3]=-3 < nums[4]=5 -> pop back. Then nums[2]=-1 <5 -> pop back. Then dq=[4]. Output: nums[4]=5 -> result=[3,3,5]\ni=5: remove? dq[0]=4 !=5-3=2 -> no. Then compare: nums[4]=5 > nums[5]=3 -> no pop. Then dq=[4,5]. Output: nums[4]=5 -> result=[3,3,5,5]\ni=6: remove? dq[0]=4 !=6-3=3 -> no. Then compare: nums[5]=3 < nums[6]=6 -> pop back. Then nums[4]=5 <6 -> pop back. Then dq=[6]. Output: nums[6]=6 -> result=[3,3,5,5,6]\ni=7: remove? dq[0]=6 !=7-3=4 -> no. Then compare: nums[6]=6 < nums[7]=7 -> pop back. Then dq=[7]. Output: nums[7]=7 -> result=[3,3,5,5,6,7]\n\nThis matches the expected output.\n\nExample 2: nums=[1], k=1\ni=0: dq=[0], output since i>=0 -> result=[1]\n\nSo the code is correct.\n\nHowever, to be safe for all cases, we should note that the condition for removing the front is correct only if we are sure that the deque always has the correct indices. Since we are adding indices in order and only one index becomes obsolete per step, the condition is sufficient.\n\nTherefore, the solution is valid.\n\nFinal code (unchanged):\n```python\nfrom collections import deque\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n```\n\n",
      "TypedCode": "\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 54884700875,
      "SolvedAt": "2025-11-21T00:37:40.655408+01:00",
      "PromptTokens": 5562,
      "OutputTokens": 2501
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "239",
        "typed_code": "\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        result = []\n        for i in range(len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T01:59:31+01:00"
    }
  }
}