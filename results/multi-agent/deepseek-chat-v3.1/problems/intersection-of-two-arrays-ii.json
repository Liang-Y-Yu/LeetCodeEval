{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "350",
        "questionId": "350",
        "Content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [4,9]\n<strong>Explanation:</strong> [9,4] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n\t<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>\n\t<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n",
        "SampleTestCase": "[1,2,2,1]\n[2,2]",
        "ExampleTestcases": "[1,2,2,1]\n[2,2]\n[4,9,5]\n[9,4,9,8,4]",
        "Difficulty": "Easy",
        "Title": "Intersection of Two Arrays II",
        "TitleSlug": "intersection-of-two-arrays-ii",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.8M\", \"totalAcceptedRaw\": 1649385, \"totalSubmissionRaw\": 2777189, \"acRate\": \"59.4%\"}",
        "Likes": 8065,
        "Dislikes": 1004,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjk=",
            "Name": "Two Pointers",
            "Slug": "two-pointers"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersect = function(nums1, nums2) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function intersect(nums1: number[], nums2: number[]): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] Intersect(int[] nums1, int[] nums2) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func intersect(nums1 []int, nums2 []int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun intersect(nums1: IntArray, nums2: IntArray): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func intersect(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn intersect(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[]}\ndef intersect(nums1, nums2)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[]\n     */\n    function intersect($nums1, $nums2) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> intersect(List<int> nums1, List<int> nums2) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec intersect(nums1 :: [integer], nums2 :: [integer]) :: [integer]\n  def intersect(nums1, nums2) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec intersect(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].\nintersect(Nums1, Nums2) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (intersect nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:21:31.988483+01:00",
    "AcRate": "59.4",
    "TotalSubmissions": 2777189,
    "TotalAccepted": 1649385,
    "AcceptanceRate": 0.5939044839944274,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nProblem Type Classification: Array, Hash Table, Two Pointers\n\nKey Patterns & Algorithms:\n- **Hash Table (Frequency Counting)**: Count the frequency of elements in one array and then check the other array.\n- **Two Pointers**: If the arrays are sorted, use two pointers to traverse both arrays simultaneously.\n- **Binary Search**: For follow-up when one array is large and stored on disk (if sorted).\n\nConstraints Analysis:\n- Array lengths up to 1000, so O(n^2) is acceptable but not ideal.\n- Element values are integers in [0, 1000], so frequency arrays of size 1001 are efficient.\n\nEdge Cases:\n- One array is empty.\n- No common elements.\n- All elements are the same.\n- One array has duplicates and the other doesn't.\n- Arrays with large value ranges but sparse numbers.\n\nInput/Output Analysis:\n- Input: two lists of integers.\n- Output: list of integers representing the intersection with frequency.\n\nDifficulty Assessment: Easy. The problem is straightforward with multiple approaches. The main challenge is optimizing for the follow-up scenarios.\n\nSolution Code:\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Hash Table (Frequency Counting) for general case. This approach efficiently counts the frequency of elements in the first array and then checks the second array to form the intersection with correct multiplicities.\n\n**Step-by-Step Approach**:\n1. Create a frequency dictionary (or array) for the elements in `nums1`.\n2. Iterate through each element in `nums2`.\n3. For each element in `nums2`, if it exists in the frequency dictionary with a count greater than zero, add it to the result and decrement the count.\n4. Return the result list.\n\n**Data Structures**: A dictionary (defaultdict) is used to store the frequency counts. A list is used to collect the result.\n\n**Time Complexity**: O(n + m), where n and m are the lengths of `nums1` and `nums2` respectively. Each array is traversed once.\n\n**Space Complexity**: O(min(n, m)) in the worst case for the result list, and O(n) for the frequency dictionary (if we consider the distinct elements in `nums1`).\n\n**Pseudocode**:\n```\nfunction intersect(nums1, nums2):\n    freq = new defaultdict(int)\n    for each num in nums1:\n        increment freq[num]\n    result = empty list\n    for each num in nums2:\n        if freq[num] > 0:\n            append num to result\n            decrement freq[num]\n    return result\n```\n\nNow, here is the implementation:\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n```\n\n=== VERIFICATION ===\nAfter reviewing the provided solution code, I can confirm that it is correct, efficient, and handles all edge cases appropriately. Below is the verification report:\n\n### Verification Report:\n1. **Correctness**: The code correctly implements the frequency counting algorithm using a dictionary. It accurately tracks the occurrences of each element in `nums1` and then uses that to form the intersection with `nums2` while maintaining the correct multiplicities.\n\n2. **Edge Cases**:\n   - One array is empty: Returns an empty list.\n   - No common elements: Returns an empty list.\n   - All elements are the same: Correctly returns the intersection with the minimum frequency.\n   - One array has duplicates and the other doesn't: Returns only the common elements with the frequency from the array with duplicates if it is in `nums1`, but correctly limits by the frequency in `nums1` (e.g., if `nums1 = [1,1]` and `nums2 = [1]`, returns `[1]`; if `nums1 = [1]` and `nums2 = [1,1]`, returns `[1]`).\n   - Arrays with large value ranges but sparse numbers: The dictionary efficiently handles sparse data.\n\n3. **Complexity**:\n   - Time Complexity: O(n + m), where n is the length of `nums1` and m is the length of `nums2`. This is optimal for the general case.\n   - Space Complexity: O(min(n, m)) for the result list and O(k) for the frequency dictionary (where k is the number of distinct elements in `nums1`). This is efficient.\n\n4. **Code Quality**:\n   - The code is clean, readable, and follows best practices.\n   - Uses `defaultdict` for simplicity and efficiency.\n   - Variable names are meaningful (`freq`, `result`).\n   - The logic is straightforward and easy to understand.\n\n5. **Test Cases**:\n   - Example 1: `nums1 = [1,2,2,1]`, `nums2 = [2,2]` \u2192 Output `[2,2]` (correct).\n   - Example 2: `nums1 = [4,9,5]`, `nums2 = [9,4,9,8,4]` \u2192 Output `[4,9]` (correct, order does not matter).\n\n6. **Potential Issues**:\n   - None identified. The solution is robust and efficient for the given constraints.\n\n### Conclusion:\nThe solution is valid and meets all requirements. No changes are needed.\n\n### Final Code:\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: list, nums2: list) -> list:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n```\n\n",
      "TypedCode": "\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 32114868625,
      "SolvedAt": "2025-11-20T23:56:30.035118+01:00",
      "PromptTokens": 4242,
      "OutputTokens": 1438
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "350",
        "typed_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T03:12:27+01:00"
    }
  }
}