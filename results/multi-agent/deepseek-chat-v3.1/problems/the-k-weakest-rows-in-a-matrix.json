{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1337",
        "questionId": "1463",
        "Content": "<p>You are given an <code>m x n</code> binary matrix <code>mat</code> of <code>1</code>&#39;s (representing soldiers) and <code>0</code>&#39;s (representing civilians). The soldiers are positioned <strong>in front</strong> of the civilians. That is, all the <code>1</code>&#39;s will appear to the <strong>left</strong> of all the <code>0</code>&#39;s in each row.</p>\n\n<p>A row <code>i</code> is <strong>weaker</strong> than a row <code>j</code> if one of the following is true:</p>\n\n<ul>\n\t<li>The number of soldiers in row <code>i</code> is less than the number of soldiers in row <code>j</code>.</li>\n\t<li>Both rows have the same number of soldiers and <code>i &lt; j</code>.</li>\n</ul>\n\n<p>Return <em>the indices of the </em><code>k</code><em> <strong>weakest</strong> rows in the matrix ordered from weakest to strongest</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\n<strong>Output:</strong> [2,0,3]\n<strong>Explanation:</strong> \nThe number of soldiers in each row is: \n- Row 0: 2 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 2 \n- Row 4: 5 \nThe rows ordered from weakest to strongest are [2,0,3,1,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\n<strong>Output:</strong> [0,2]\n<strong>Explanation:</strong> \nThe number of soldiers in each row is: \n- Row 0: 1 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 1 \nThe rows ordered from weakest to strongest are [0,2,3,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>2 &lt;= n, m &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= m</code></li>\n\t<li><code>matrix[i][j]</code> is either 0 or 1.</li>\n</ul>\n",
        "SampleTestCase": "[[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]]\n3",
        "ExampleTestcases": "[[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]]\n3\n[[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]]\n2",
        "Difficulty": "Easy",
        "Title": "The K Weakest Rows in a Matrix",
        "TitleSlug": "the-k-weakest-rows-in-a-matrix",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"411K\", \"totalSubmission\": \"554K\", \"totalAcceptedRaw\": 410989, \"totalSubmissionRaw\": 554044, \"acRate\": \"74.2%\"}",
        "Likes": 4314,
        "Dislikes": 241,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUz",
            "Name": "Matrix",
            "Slug": "matrix"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[][]} mat\n * @param {number} k\n * @return {number[]}\n */\nvar kWeakestRows = function(mat, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function kWeakestRows(mat: number[][], k: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] KWeakestRows(int[][] mat, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func kWeakestRows(mat [][]int, k int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun kWeakestRows(mat: Array<IntArray>, k: Int): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func kWeakestRows(_ mat: [[Int]], _ k: Int) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn k_weakest_rows(mat: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[][]} mat\n# @param {Integer} k\n# @return {Integer[]}\ndef k_weakest_rows(mat, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[][] $mat\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function kWeakestRows($mat, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> kWeakestRows(List<List<int>> mat, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def kWeakestRows(mat: Array[Array[Int]], k: Int): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec k_weakest_rows(mat :: [[integer]], k :: integer) :: [integer]\n  def k_weakest_rows(mat, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec k_weakest_rows(Mat :: [[integer()]], K :: integer()) -> [integer()].\nk_weakest_rows(Mat, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (k-weakest-rows mat k)\n  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:26:51.777522+01:00",
    "AcRate": "74.2",
    "TotalSubmissions": 554044,
    "TotalAccepted": 410989,
    "AcceptanceRate": 0.7417984853188555,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n```\n\n=== DESIGN ===\n**Algorithm Choice**: \nWe will use a binary search to efficiently count the number of soldiers (1's) in each row since the soldiers are all to the left. Then, we will store the count along with the row index. We sort the rows based on the count and then the index. Finally, we return the first k indices.\n\n**Step-by-Step Approach**:\n1. For each row in the matrix, use binary search to find the first occurrence of 0. The index of this first 0 is equal to the number of soldiers (since all 1's are to the left).\n2. Store a tuple (count, index) for each row.\n3. Sort the list of tuples primarily by the count and secondarily by the index.\n4. Extract the first k indices from the sorted list and return them.\n\n**Data Structures**:\n- A list to store tuples (number of soldiers, row index).\n\n**Time Complexity**:\n- Binary search per row: O(log n) for each of the m rows -> O(m log n).\n- Sorting the list of m tuples: O(m log m).\n- Overall: O(m log n + m log m).\n\n**Space Complexity**:\n- O(m) to store the list of tuples.\n\n**Pseudocode**:\n1. Initialize an empty list `rows`.\n2. For each row index `i` and row `row` in `mat`:\n   - Set `left` to 0 and `right` to the number of columns.\n   - While `left` < `right`:\n        - `mid` = (`left` + `right`) // 2\n        - If `row[mid]` is 1, then set `left` = `mid` + 1\n        - Else, set `right` = `mid`\n   - Append (`left`, `i`) to `rows`\n3. Sort `rows` by first element (number of soldiers) and then by second element (index).\n4. Return the first k indices from the sorted `rows`.\n\nNow, the code implementation:\n```python\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n```\n\n=== VERIFICATION ===\n**Verification Report:**\n\nThe provided solution is correct and efficient. Below is a point-by-point verification:\n\n1. **Correctness**: The code correctly implements the designed algorithm. It uses binary search to count soldiers (1's) in each row (which are all left-aligned) and then sorts the rows by soldier count and index.\n\n2. **Edge Cases**: The code handles all edge cases, including:\n   - Rows with all soldiers (e.g., [1,1,1]) \u2192 count = n.\n   - Rows with no soldiers (e.g., [0,0,0]) \u2192 count = 0.\n   - Rows with same soldier count (sorted correctly by index).\n   - k = 0 (but k>=1 per constraints) and k = m (return all rows).\n\n3. **Complexity**: The time complexity is O(m log n + m log m), which is optimal for the problem. The space complexity is O(m) for storing the list of tuples.\n\n4. **Code Quality**: The code is clean, readable, and follows best practices. It uses binary search efficiently and a lambda for sorting.\n\n5. **Test Cases**:\n   - Example 1: \n        mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k=3\n        Expected [2,0,3]: \n        Row0: binary search finds first 0 at index2 \u2192 count=2.\n        Row1: first 0 at index4 \u2192 count=4.\n        Row2: first 0 at index1 \u2192 count=1.\n        Row3: first 0 at index2 \u2192 count=2.\n        Row4: first 0 at index5 (n=5) \u2192 count=5.\n        Sorted: (1,2), (2,0), (2,3), (4,1), (5,4) \u2192 indices [2,0,3] for k=3. Correct.\n   - Example 2:\n        mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k=2\n        Expected [0,2]:\n        Row0: count=1.\n        Row1: count=4.\n        Row2: count=1.\n        Row3: count=1.\n        Sorted: (1,0), (1,2), (1,3), (4,1) \u2192 indices [0,2] for k=2. Correct.\n\n6. **Potential Issues**: None. The solution is optimal and correct.\n\n**Final Code (unchanged, as it is correct):**\n```python\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n```\n\n",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 65000972042,
      "SolvedAt": "2025-11-21T00:46:49.304503+01:00",
      "PromptTokens": 5002,
      "OutputTokens": 1619
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1463",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        rows = []\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            rows.append((left, i))\n        \n        rows.sort(key=lambda x: (x[0], x[1]))\n        return [idx for _, idx in rows[:k]]\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T02:13:46+01:00"
    }
  }
}