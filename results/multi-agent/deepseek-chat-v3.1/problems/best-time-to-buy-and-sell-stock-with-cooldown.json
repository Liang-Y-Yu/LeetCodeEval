{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "309",
        "questionId": "309",
        "Content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n\t<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>\n</ul>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,0,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "SampleTestCase": "[1,2,3,0,2]",
        "ExampleTestcases": "[1,2,3,0,2]\n[1]",
        "Difficulty": "Medium",
        "Title": "Best Time to Buy and Sell Stock with Cooldown",
        "TitleSlug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"711.8K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 711815, \"totalSubmissionRaw\": 1161056, \"acRate\": \"61.3%\"}",
        "Likes": 9930,
        "Dislikes": 347,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxProfit(prices: number[]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int maxProfit(int* prices, int pricesSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxProfit(prices []int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int maxProfit(List<int> prices) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_profit(prices :: [integer]) :: integer\n  def max_profit(prices) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_profit(Prices :: [integer()]) -> integer().\nmax_profit(Prices) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-profit prices)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:23:34.061883+01:00",
    "AcRate": "61.3",
    "TotalSubmissions": 1161056,
    "TotalAccepted": 711815,
    "AcceptanceRate": 0.6130755105696882,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Dynamic Programming with State Machine\n\n**Step-by-Step Approach**:\n1. We track three states for each day: `hold` (holding stock), `sold` (just sold stock), and `rest` (cooling down after sale)\n2. Initialize `hold` with -prices[0] (buying on day 0), `sold` and `rest` with 0\n3. For each subsequent day, update the states:\n   - `hold`: max of previous hold or buying today (from rest state)\n   - `sold`: selling today's held stock (previous hold + price)\n   - `rest`: max of previous rest or previous sold (cooling down)\n4. Final answer is max of `sold` or `rest` (cannot end with holding stock)\n\n**Data Structures**: Three integer variables to track state values\n\n**Time Complexity**: O(n) - single pass through prices\n**Space Complexity**: O(1) - only three variables used\n\n**Pseudocode**:\n```\ninitialize hold = -prices[0], sold = 0, rest = 0\nfor i from 1 to n-1:\n    prev_hold = hold\n    prev_sold = sold\n    hold = max(prev_hold, rest - prices[i])\n    sold = prev_hold + prices[i]\n    rest = max(prev_rest, prev_sold)\nreturn max(sold, rest)\n```\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 21296812875,
      "SolvedAt": "2025-11-20T23:35:03.210988+01:00",
      "PromptTokens": 3679,
      "OutputTokens": 868
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "309",
        "typed_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        hold = -prices[0]\n        sold = 0\n        rest = 0\n        \n        for i in range(1, n):\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n            \n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n        \n        return max(sold, rest)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T02:29:38+01:00"
    }
  }
}