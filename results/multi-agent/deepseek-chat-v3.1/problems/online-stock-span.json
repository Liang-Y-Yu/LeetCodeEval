{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "901",
        "questionId": "937",
        "Content": "<p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>\n\n<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>\n\n<ul>\n\t<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>\n\t<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>\n</ul>\n\n<p>Implement the <code>StockSpanner</code> class:</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> Initializes the object of the class.</li>\n\t<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>Output</strong>\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>Explanation</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.\nstockSpanner.next(85);  // return 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "ExampleTestcases": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "Difficulty": "Medium",
        "Title": "Online Stock Span",
        "TitleSlug": "online-stock-span",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"533.2K\", \"totalSubmission\": \"780.3K\", \"totalAcceptedRaw\": 533155, \"totalSubmissionRaw\": 780342, \"acRate\": \"68.3%\"}",
        "Likes": 7070,
        "Dislikes": 486,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjE1",
            "Name": "Stack",
            "Slug": "stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU0",
            "Name": "Monotonic Stack",
            "Slug": "monotonic-stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class StockSpanner(object):\n\n    def __init__(self):\n        \n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar StockSpanner = function() {\n    \n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    \n};\n\n/** \n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class StockSpanner {\n    constructor() {\n        \n    }\n\n    next(price: number): number {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int Next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.Next(price);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} StockSpanner;\n\n\nStockSpanner* stockSpannerCreate() {\n    \n}\n\nint stockSpannerNext(StockSpanner* obj, int price) {\n    \n}\n\nvoid stockSpannerFree(StockSpanner* obj) {\n    \n}\n\n/**\n * Your StockSpanner struct will be instantiated and called as such:\n * StockSpanner* obj = stockSpannerCreate();\n * int param_1 = stockSpannerNext(obj, price);\n \n * stockSpannerFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type StockSpanner struct {\n    \n}\n\n\nfunc Constructor() StockSpanner {\n    \n}\n\n\nfunc (this *StockSpanner) Next(price int) int {\n    \n}\n\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Next(price);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class StockSpanner() {\n\n    fun next(price: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass StockSpanner {\n\n    init() {\n        \n    }\n    \n    func next(_ price: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner()\n * let ret_1: Int = obj.next(price)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct StockSpanner {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockSpanner {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn next(&self, price: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner::new();\n * let ret_1: i32 = obj.next(price);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class StockSpanner\n    def initialize()\n        \n    end\n\n\n=begin\n    :type price: Integer\n    :rtype: Integer\n=end\n    def next(price)\n        \n    end\n\n\nend\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner.new()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class StockSpanner {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $price\n     * @return Integer\n     */\n    function next($price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * $obj = StockSpanner();\n * $ret_1 = $obj->next($price);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class StockSpanner {\n\n  StockSpanner() {\n    \n  }\n  \n  int next(int price) {\n    \n  }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = StockSpanner();\n * int param1 = obj.next(price);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class StockSpanner() {\n\n    def next(price: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * val obj = new StockSpanner()\n * val param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule StockSpanner do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec next(price :: integer) :: integer\n  def next(price) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockSpanner.init_()\n# param_1 = StockSpanner.next(price)\n\n# StockSpanner.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec stock_spanner_init_() -> any().\nstock_spanner_init_() ->\n  .\n\n-spec stock_spanner_next(Price :: integer()) -> integer().\nstock_spanner_next(Price) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_spanner_init_(),\n%% Param_1 = stock_spanner_next(Price),\n\n%% stock_spanner_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define stock-spanner%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; next : exact-integer? -> exact-integer?\n    (define/public (next price)\n      )))\n\n;; Your stock-spanner% object will be instantiated and called as such:\n;; (define obj (new stock-spanner%))\n;; (define param_1 (send obj next price))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:50:37.88752+01:00",
    "AcRate": "68.3",
    "TotalSubmissions": 780342,
    "TotalAccepted": 533155,
    "AcceptanceRate": 0.683232480117692,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/online-stock-span/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n**Problem Analysis:**\n\n1. **Problem Type Classification**: Stack, Monotonic Stack, Design\n\n2. **Key Patterns & Algorithms**: \n   - The problem requires efficiently finding how many consecutive previous days had prices \u2264 current price.\n   - A monotonic decreasing stack is ideal: we maintain a stack of (price, span) where prices are in decreasing order.\n   - When a new price comes in, we pop all smaller prices from the stack and accumulate their spans.\n\n3. **Constraints Analysis**:\n   - Up to 10^4 calls to `next()`, so O(n) per call would be acceptable, but we can optimize to O(1) amortized.\n   - Using a stack gives O(1) amortized time per operation (each price pushed/popped once).\n\n4. **Edge Cases**:\n   - First call to `next()`.\n   - Continuously increasing prices (e.g., 1, 2, 3, 4).\n   - Continuously decreasing prices (e.g., 4, 3, 2, 1).\n   - Prices with repeated values.\n\n5. **Input/Output Analysis**:\n   - `next(price)` returns the span for that day.\n   - Span includes the current day.\n\n6. **Difficulty Assessment**: Medium. The key is recognizing the monotonic stack pattern to avoid O(n\u00b2) time.\n\n**Solution Code:**\n\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n```\n\n=== DESIGN ===\n**Algorithm Choice**: Monotonic Stack  \nWe use a monotonic decreasing stack to efficiently track the consecutive days with prices less than or equal to the current day. Each element in the stack is a tuple (price, span), where span is the consecutive count for that price.\n\n**Step-by-Step Approach**:\n1. Initialize an empty stack in the constructor.\n2. For each call to `next(price)`:\n   - Start with a span of 1 (for the current day).\n   - While the stack is not empty and the top element's price is <= current price:\n        Pop the top element and add its span to the current span.\n   - Push the current price and its computed span onto the stack.\n   - Return the current span.\n\n**Data Structures**: A list (stack) that holds tuples (price, span).\n\n**Time Complexity**: O(1) amortized per operation. Each price is pushed and popped at most once.\n\n**Space Complexity**: O(n) in the worst case, where n is the number of calls to `next()`.\n\n**Pseudocode**:\n```\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []   # stack of (price, span)\n\n    def next(price):\n        span = 1\n        while stack is not empty and top price <= price:\n            span += pop from stack\n        push (price, span) to stack\n        return span\n```\n\n```python\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n```\n\n=== IMPLEMENTATION ===\n```python\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n```\n\n=== VERIFICATION ===\n\nYour solution is correct. Let's verify it step by step:\n\n**Correctness**: \n- The algorithm uses a monotonic decreasing stack to efficiently compute spans.\n- For each new price, it pops all previous prices that are <= current price and accumulates their spans.\n- This correctly calculates consecutive days with prices <= current day.\n\n**Edge Cases**:\n1. First call: stack is empty, returns 1 (correct).\n2. Continuously increasing prices (e.g., [1,2,3,4]):\n   - next(1): stack=[(1,1)], returns 1\n   - next(2): pops (1,1) since 1<=2, span=1+1=2 \u2192 stack=[(2,2)], returns 2\n   - next(3): pops (2,2), span=1+2=3 \u2192 stack=[(3,3)], returns 3\n   - next(4): pops (3,3), span=1+3=4 \u2192 stack=[(4,4)], returns 4 (correct).\n3. Continuously decreasing prices (e.g., [4,3,2,1]):\n   - next(4): stack=[(4,1)], returns 1\n   - next(3): stack=[(4,1), (3,1)], returns 1\n   - next(2): stack=[(4,1), (3,1), (2,1)], returns 1\n   - next(1): stack=[(4,1), (3,1), (2,1), (1,1)], returns 1 (correct).\n4. Repeated values: [2,2,2]\n   - next(2): stack=[(2,1)], returns 1\n   - next(2): pops (2,1) since 2<=2, span=1+1=2 \u2192 stack=[(2,2)], returns 2\n   - next(2): pops (2,2) since 2<=2, span=1+2=3 \u2192 stack=[(2,3)], returns 3 (correct).\n\n**Complexity**:\n- Time: O(1) amortized per operation (each element pushed/popped once).\n- Space: O(n) worst-case (if prices are strictly decreasing).\n\n**Code Quality**:\n- Clean and readable.\n- Uses appropriate data structure (stack).\n- Efficient algorithm.\n\n**Test with Example**:\nInput: [100,80,60,70,60,75,85]\n- next(100): stack=[(100,1)] \u2192 returns 1\n- next(80): stack=[(100,1),(80,1)] \u2192 returns 1\n- next(60): stack=[(100,1),(80,1),(60,1)] \u2192 returns 1\n- next(70): pops (60,1) since 60<=70, span=1+1=2 \u2192 stack=[(100,1),(80,1),(70,2)] \u2192 returns 2\n- next(60): stack=[(100,1),(80,1),(70,2),(60,1)] \u2192 returns 1\n- next(75): pops (60,1) and (70,2) since 60<=75 and 70<=75, span=1+1+2=4 \u2192 stack=[(100,1),(80,1),(75,4)] \u2192 returns 4\n- next(85): pops (75,4) since 75<=85, and then (80,1) since 80<=85, span=1+4+1=6 \u2192 stack=[(100,1),(85,6)] \u2192 returns 6 (matches).\n\nThe solution is correct and efficient. No changes are needed.\n\nFinal code:\n```python\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n```\n\n",
      "TypedCode": "\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 29371635126,
      "SolvedAt": "2025-11-21T00:21:46.62688+01:00",
      "PromptTokens": 5502,
      "OutputTokens": 1697
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "937",
        "typed_code": "\nclass StockSpanner:\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T02:05:52+01:00"
    }
  }
}