{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1964",
        "questionId": "2096",
        "Content": "<p>You want to build some obstacle courses. You are given a <strong>0-indexed</strong> integer array <code>obstacles</code> of length <code>n</code>, where <code>obstacles[i]</code> describes the height of the <code>i<sup>th</sup></code> obstacle.</p>\n\n<p>For every index <code>i</code> between <code>0</code> and <code>n - 1</code> (<strong>inclusive</strong>), find the length of the <strong>longest obstacle course</strong> in <code>obstacles</code> such that:</p>\n\n<ul>\n\t<li>You choose any number of obstacles between <code>0</code> and <code>i</code> <strong>inclusive</strong>.</li>\n\t<li>You must include the <code>i<sup>th</sup></code> obstacle in the course.</li>\n\t<li>You must put the chosen obstacles in the <strong>same order</strong> as they appear in <code>obstacles</code>.</li>\n\t<li>Every obstacle (except the first) is <strong>taller</strong> than or the <strong>same height</strong> as the obstacle immediately before it.</li>\n</ul>\n\n<p>Return <em>an array</em> <code>ans</code> <em>of length</em> <code>n</code>, <em>where</em> <code>ans[i]</code> <em>is the length of the <strong>longest obstacle course</strong> for index</em> <code>i</code><em> as described above</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [1,2,3,2]\n<strong>Output:</strong> [1,2,3,3]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>1</u>], [1] has length 1.\n- i = 1: [<u>1</u>,<u>2</u>], [1,2] has length 2.\n- i = 2: [<u>1</u>,<u>2</u>,<u>3</u>], [1,2,3] has length 3.\n- i = 3: [<u>1</u>,<u>2</u>,3,<u>2</u>], [1,2,2] has length 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [2,2,1]\n<strong>Output:</strong> [1,2,1]\n<strong>Explanation: </strong>The longest valid obstacle course at each position is:\n- i = 0: [<u>2</u>], [2] has length 1.\n- i = 1: [<u>2</u>,<u>2</u>], [2,2] has length 2.\n- i = 2: [2,2,<u>1</u>], [1] has length 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [3,1,5,6,4,2]\n<strong>Output:</strong> [1,1,2,3,2,2]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>3</u>], [3] has length 1.\n- i = 1: [3,<u>1</u>], [1] has length 1.\n- i = 2: [<u>3</u>,1,<u>5</u>], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [<u>3</u>,1,<u>5</u>,<u>6</u>], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [<u>3</u>,1,5,6,<u>4</u>], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,<u>1</u>,5,6,4,<u>2</u>], [1,2] has length 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[1,2,3,2]",
        "ExampleTestcases": "[1,2,3,2]\n[2,2,1]\n[3,1,5,6,4,2]",
        "Difficulty": "Hard",
        "Title": "Find the Longest Valid Obstacle Course at Each Position",
        "TitleSlug": "find-the-longest-valid-obstacle-course-at-each-position",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"66.7K\", \"totalSubmission\": \"106.6K\", \"totalAcceptedRaw\": 66682, \"totalSubmissionRaw\": 106608, \"acRate\": \"62.5%\"}",
        "Likes": 1880,
        "Dislikes": 74,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI4",
            "Name": "Binary Indexed Tree",
            "Slug": "binary-indexed-tree"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nvar longestObstacleCourseAtEachPosition = function(obstacles) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function longestObstacleCourseAtEachPosition(obstacles: number[]): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] LongestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func longestObstacleCourseAtEachPosition(obstacles []int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun longestObstacleCourseAtEachPosition(obstacles: IntArray): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func longestObstacleCourseAtEachPosition(_ obstacles: [Int]) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn longest_obstacle_course_at_each_position(obstacles: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} obstacles\n# @return {Integer[]}\ndef longest_obstacle_course_at_each_position(obstacles)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $obstacles\n     * @return Integer[]\n     */\n    function longestObstacleCourseAtEachPosition($obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> longestObstacleCourseAtEachPosition(List<int> obstacles) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def longestObstacleCourseAtEachPosition(obstacles: Array[Int]): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec longest_obstacle_course_at_each_position(obstacles :: [integer]) :: [integer]\n  def longest_obstacle_course_at_each_position(obstacles) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec longest_obstacle_course_at_each_position(Obstacles :: [integer()]) -> [integer()].\nlongest_obstacle_course_at_each_position(Obstacles) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (longest-obstacle-course-at-each-position obstacles)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T13:56:35.847686+01:00",
    "AcRate": "62.5",
    "TotalSubmissions": 106608,
    "TotalAccepted": 66682,
    "AcceptanceRate": 0.6254877682725499,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n**Problem Type Classification**: Dynamic Programming, Longest Non-Decreasing Subsequence (LIS variant)\n\n**Key Patterns & Algorithms**: \n- This is a variant of the Longest Increasing Subsequence (LIS) problem, but for non-decreasing sequences (allowing equal heights).\n- The standard LIS solution using dynamic programming with binary search (patience sorting) applies here.\n- For each position `i`, we need the length of the longest non-decreasing subsequence ending at `i`.\n\n**Constraints Analysis**:\n- `n` up to 10^5 rules out O(n\u00b2) DP solutions.\n- Requires an O(n log n) solution using binary search to maintain the smallest possible tail values for each subsequence length.\n\n**Edge Cases**:\n- Single element array.\n- Entire array is non-decreasing.\n- Entire array is strictly decreasing.\n- All elements are equal.\n- Large values (up to 10^7).\n\n**Input/Output Analysis**:\n- Input: List of integers `obstacles`.\n- Output: List of integers `ans` where `ans[i]` is the length of the longest valid subsequence ending at index `i`.\n\n**Difficulty Assessment**:\n- Medium. Requires knowledge of the optimized LIS algorithm with binary search, adapted for non-decreasing sequences.\n\n```python\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, height in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, height)\n            if idx == len(lis):\n                lis.append(height)\n            else:\n                lis[idx] = height\n            ans[i] = idx + 1\n        return ans\n```\n\nNote: The code uses `bisect_right` to handle non-decreasing sequences (allowing equals). This ensures we place duplicates correctly to maintain the smallest possible tail values.\n\n=== DESIGN ===\n\nGiven the problem analysis and requirements, the solution involves using an optimized dynamic programming approach with binary search to efficiently compute the longest non-decreasing subsequence ending at each position.\n\n**Algorithm Choice**:\nWe use the classic Longest Increasing Subsequence (LIS) algorithm with binary search (patience sorting), adapted for non-decreasing sequences. This allows us to achieve O(n log n) time complexity.\n\n**Step-by-Step Approach**:\n1. Initialize an empty list `lis` to keep track of the smallest tail value for subsequences of length `i+1`.\n2. Initialize an answer list `ans` with all ones (each element has at least a subsequence of length 1).\n3. Iterate over each obstacle height:\n   - Use binary search to find the rightmost position `idx` in `lis` where the value is less than or equal to the current height. This is done with `bisect_right`.\n   - If `idx` is at the end of `lis`, it means we can extend the longest subsequence, so append the current height.\n   - Otherwise, update `lis[idx]` to the current height to maintain the smallest tail value for subsequences of length `idx+1`.\n   - The length of the longest subsequence ending at the current index is `idx+1`, which we store in `ans[i]`.\n4. Return `ans`.\n\n**Data Structures**:\n- `lis`: A list that maintains the smallest tail values for increasing subsequences of different lengths.\n- `ans`: A list to store the result for each index.\n\n**Time Complexity**: O(n log n) - Each insertion and binary search operation is O(log n) for n elements.\n**Space Complexity**: O(n) - The `lis` and `ans` lists both use O(n) space.\n\n**Pseudocode**:\n```\nInitialize ans as a list of ones with length n.\nInitialize lis as an empty list.\nFor each index i and height h in obstacles:\n    Find the rightmost index idx in lis such that lis[idx] <= h (using bisect_right).\n    If idx equals the length of lis:\n        Append h to lis.\n    Else:\n        Set lis[idx] = h.\n    Set ans[i] = idx + 1.\nReturn ans.\n```\n\nNow, the implementation:\n```python\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, h in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, h)\n            if idx == len(lis):\n                lis.append(h)\n            else:\n                lis[idx] = h\n            ans[i] = idx + 1\n        return ans\n```\n\n=== IMPLEMENTATION ===\n```python\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, h in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, h)\n            if idx == len(lis):\n                lis.append(h)\n            else:\n                lis[idx] = h\n            ans[i] = idx + 1\n        return ans\n```\n\n=== VERIFICATION ===\nThe solution is correct and meets all requirements. Let's verify it:\n\n1. **Correctness**: The code correctly implements the optimized LIS algorithm for non-decreasing sequences using binary search with `bisect_right`, which handles the \"taller than or the same height\" condition.\n\n2. **Edge Cases**:\n   - Single element: [5] \u2192 [1]\n   - Entirely non-decreasing: [1,2,3,4] \u2192 [1,2,3,4]\n   - Entirely decreasing: [4,3,2,1] \u2192 [1,1,1,1]\n   - All equal: [2,2,2,2] \u2192 [1,2,3,4]\n   - Large values: Handled since binary search works with integers up to 10^7.\n\n3. **Complexity**: O(n log n) time and O(n) space, which is optimal for the constraints.\n\n4. **Code Quality**: The code is clean, readable, and uses appropriate variable names.\n\n5. **Test Cases**:\n   - Example 1: [1,2,3,2] \u2192 [1,2,3,3] \u2705\n   - Example 2: [2,2,1] \u2192 [1,2,1] \u2705\n   - Example 3: [3,1,5,6,4,2] \u2192 [1,1,2,3,2,2] \u2705\n\n6. **Potential Issues**: None found. The use of `bisect_right` is correct for non-decreasing sequences.\n\nFinal code:\n```python\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, h in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, h)\n            if idx == len(lis):\n                lis.append(h)\n            else:\n                lis[idx] = h\n            ans[i] = idx + 1\n        return ans\n```\n\n",
      "TypedCode": "\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, h in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, h)\n            if idx == len(lis):\n                lis.append(h)\n            else:\n                lis[idx] = h\n            ans[i] = idx + 1\n        return ans\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 24742087543,
      "SolvedAt": "2025-11-20T23:53:32.825554+01:00",
      "PromptTokens": 6576,
      "OutputTokens": 1583
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "2096",
        "typed_code": "\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        ans = [1] * n\n        lis = []\n        for i, h in enumerate(obstacles):\n            idx = bisect.bisect_right(lis, h)\n            if idx == len(lis):\n                lis.append(h)\n            else:\n                lis[idx] = h\n            ans[i] = idx + 1\n        return ans\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T02:43:57+01:00"
    }
  }
}