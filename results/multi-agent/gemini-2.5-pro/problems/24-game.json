{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "679",
        "questionId": "679",
        "Content": "<p>You are given an integer array <code>cards</code> of length <code>4</code>. You have four cards, each containing a number in the range <code>[1, 9]</code>. You should arrange the numbers on these cards in a mathematical expression using the operators <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> and the parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> to get the value 24.</p>\n\n<p>You are restricted with the following rules:</p>\n\n<ul>\n\t<li>The division operator <code>&#39;/&#39;</code> represents real division, not integer division.\n\n\t<ul>\n\t\t<li>For example, <code>4 / (1 - 2 / 3) = 4 / (1 / 3) = 12</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Every operation done is between two numbers. In particular, we cannot use <code>&#39;-&#39;</code> as a unary operator.\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 1, 1, 1]</code>, the expression <code>&quot;-1 - 1 - 1 - 1&quot;</code> is <strong>not allowed</strong>.</li>\n\t</ul>\n\t</li>\n\t<li>You cannot concatenate numbers together\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 2, 1, 2]</code>, the expression <code>&quot;12 + 12&quot;</code> is not valid.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <code>true</code> if you can get such expression that evaluates to <code>24</code>, and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [4,1,8,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [1,2,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n",
        "SampleTestCase": "[4,1,8,7]",
        "ExampleTestcases": "[4,1,8,7]\n[1,2,1,2]",
        "Difficulty": "Hard",
        "Title": "24 Game",
        "TitleSlug": "24-game",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"164.2K\", \"totalSubmission\": \"277.3K\", \"totalAcceptedRaw\": 164151, \"totalSubmissionRaw\": 277296, \"acRate\": \"59.2%\"}",
        "Likes": 1872,
        "Dislikes": 288,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjg=",
            "Name": "Math",
            "Slug": "math"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool judgePoint24(vector<int>& cards) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean judgePoint24(int[] cards) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} cards\n * @return {boolean}\n */\nvar judgePoint24 = function(cards) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function judgePoint24(cards: number[]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool JudgePoint24(int[] cards) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool judgePoint24(int* cards, int cardsSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func judgePoint24(cards []int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun judgePoint24(cards: IntArray): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func judgePoint24(_ cards: [Int]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn judge_point24(cards: Vec<i32>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} cards\n# @return {Boolean}\ndef judge_point24(cards)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $cards\n     * @return Boolean\n     */\n    function judgePoint24($cards) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool judgePoint24(List<int> cards) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def judgePoint24(cards: Array[Int]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec judge_point24(cards :: [integer]) :: boolean\n  def judge_point24(cards) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec judge_point24(Cards :: [integer()]) -> boolean().\njudge_point24(Cards) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (judge-point24 cards)\n  (-> (listof exact-integer?) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:06:56.163065+01:00",
    "AcRate": "59.2",
    "TotalSubmissions": 277296,
    "TotalAccepted": 164151,
    "AcceptanceRate": 0.5919703133114073,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/24-game/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and effective way to solve this problem is through a backtracking search. Given the small and fixed number of cards (4), we can explore all possible combinations of operations and numbers without exceeding time limits.\n\nThe core of the solution is a recursive function that takes a list of numbers. In each call, this function tries to reduce the number of elements in the list by one. It does this by picking any two numbers from the list, applying all possible binary operations (+, -, *, /) to them, and then recursively calling itself with a new list containing the result of the operation and the remaining numbers.\n\nThe base case for the recursion is when the list contains only one number. At this point, we check if this number is equal to 24. Since the operations can result in floating-point numbers, we check for equality within a small tolerance (epsilon) to handle precision issues.\n\nThis \"pick two, operate, and recurse\" strategy implicitly handles all possible parenthesizations and permutations of the numbers. For example, picking cards `a` and `b` first explores expressions of the form `(a op b) ...`, while picking `c` and `d` first explores `... (c op d) ...`. By iterating through all pairs at each step, we ensure all groupings are eventually explored.\n\nThe implementation will look like this:\n1.  A main function `judgePoint24` that initializes the process by converting the input integer cards to a list of floats.\n2.  A nested helper function, `solve`, that implements the backtracking logic.\n3.  The `solve` function takes a list of floats.\n4.  If the list has one element, it checks if it's approximately 24.\n5.  Otherwise, it iterates through all unique pairs of numbers `(a, b)` from the list.\n6.  For each pair, it calculates all six possible outcomes: `a+b`, `a-b`, `b-a`, `a*b`, `a/b`, `b/a` (checking for division by zero).\n7.  For each outcome, it makes a recursive call to `solve` with a new list, which includes the outcome and the numbers that were not part of the pair.\n8.  If any recursive call returns `true`, a solution has been found, and we propagate `true` up the call stack. If all possibilities are exhausted without a solution, it returns `false`.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n\n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n\n            # Pick any two numbers from the list\n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    # The other numbers in the list\n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    # Create a set of possible results from the pair (a, b)\n                    # Using a set handles duplicates, e.g., if a = b\n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    # Recurse for each possible result\n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n\n        return solve([float(c) for c in cards])\n\n```\n\n=== DESIGN ===\nAn elegant and effective way to solve this problem is through a backtracking search. Given the small and fixed number of cards (4), we can explore all possible combinations of operations and numbers without exceeding time limits.\nThe core of the solution is a recursive function that takes a list of numbers. In each call, this function tries to reduce the number of elements in the list by one. It does this by picking any two numbers from the list, applying all possible binary operations (+, -, *, /) to them, and then recursively calling itself with a new list containing the result of the operation and the remaining numbers.\nThe base case for the recursion is when the list contains only one number. At this point, we check if this number is equal to 24. Since the operations can result in floating-point numbers, we check for equality within a small tolerance (epsilon) to handle precision issues.\nThis \"pick two, operate, and recurse\" strategy implicitly handles all possible parenthesizations and permutations of the numbers. For example, picking cards `a` and `b` first explores expressions of the form `(a op b) ...`, while picking `c` and `d` first explores `... (c op d) ...`. By iterating through all pairs at each step, we ensure all groupings are eventually explored.\nThe implementation will look like this:\n1.  A main function `judgePoint24` that initializes the process by converting the input integer cards to a list of floats.\n2.  A nested helper function, `solve`, that implements the backtracking logic.\n3.  The `solve` function takes a list of floats.\n4.  If the list has one element, it checks if it's approximately 24.\n5.  Otherwise, it iterates through all unique pairs of numbers `(a, b)` from the list.\n6.  For each pair, it calculates all six possible outcomes: `a+b`, `a-b`, `b-a`, `a*b`, `a/b`, `b/a` (checking for division by zero).\n7.  For each outcome, it makes a recursive call to `solve` with a new list, which includes the outcome and the numbers that were not part of the pair.\n8.  If any recursive call returns `true`, a solution has been found, and we propagate `true` up the call stack. If all possibilities are exhausted without a solution, it returns `false`.\n```python\nfrom typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n        \n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n\n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n            \n        return solve([float(c) for c in cards])\n\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n        \n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n            \n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n            \n        return solve([float(c) for c in cards])\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n        \n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n            \n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n            \n        return solve([float(c) for c in cards])\n\n```\n\n",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n        \n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n            \n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n            \n        return solve([float(c) for c in cards])\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 288087700833,
      "SolvedAt": "2025-11-21T08:08:40.873602+01:00",
      "PromptTokens": 7379,
      "OutputTokens": 38381
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "679",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        epsilon = 1e-6\n        \n        def solve(nums: List[float]) -> bool:\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < epsilon\n            \n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    a = nums[i]\n                    b = nums[j]\n                    \n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    \n                    possible_results = {a + b, a * b, a - b, b - a}\n                    if b != 0:\n                        possible_results.add(a / b)\n                    if a != 0:\n                        possible_results.add(b / a)\n                    \n                    for res in possible_results:\n                        if solve(next_nums + [res]):\n                            return True\n                            \n            return False\n            \n        return solve([float(c) for c in cards])\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:17:55+01:00"
    }
  }
}