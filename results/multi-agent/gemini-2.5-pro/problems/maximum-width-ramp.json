{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "962",
        "questionId": "1002",
        "Content": "<p>A <strong>ramp</strong> in an integer array <code>nums</code> is a pair <code>(i, j)</code> for which <code>i &lt; j</code> and <code>nums[i] &lt;= nums[j]</code>. The <strong>width</strong> of such a ramp is <code>j - i</code>.</p>\n\n<p>Given an integer array <code>nums</code>, return <em>the maximum width of a <strong>ramp</strong> in </em><code>nums</code>. If there is no <strong>ramp</strong> in <code>nums</code>, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,0,8,2,1,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9,8,1,0,1,9,4,0,4,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[6,0,8,2,1,5]",
        "ExampleTestcases": "[6,0,8,2,1,5]\n[9,8,1,0,1,9,4,0,4,1]",
        "Difficulty": "Medium",
        "Title": "Maximum Width Ramp",
        "TitleSlug": "maximum-width-ramp",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"200.1K\", \"totalSubmission\": \"358.7K\", \"totalAcceptedRaw\": 200112, \"totalSubmissionRaw\": 358711, \"acRate\": \"55.8%\"}",
        "Likes": 2811,
        "Dislikes": 96,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjk=",
            "Name": "Two Pointers",
            "Slug": "two-pointers"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE1",
            "Name": "Stack",
            "Slug": "stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU0",
            "Name": "Monotonic Stack",
            "Slug": "monotonic-stack"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int maxWidthRamp(int[] nums) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxWidthRamp(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxWidthRamp = function(nums) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxWidthRamp(nums: number[]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int MaxWidthRamp(int[] nums) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int maxWidthRamp(int* nums, int numsSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxWidthRamp(nums []int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxWidthRamp(nums: IntArray): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxWidthRamp(_ nums: [Int]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_width_ramp(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_width_ramp(nums)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxWidthRamp($nums) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int maxWidthRamp(List<int> nums) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxWidthRamp(nums: Array[Int]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_width_ramp(nums :: [integer]) :: integer\n  def max_width_ramp(nums) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_width_ramp(Nums :: [integer()]) -> integer().\nmax_width_ramp(Nums) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-width-ramp nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:44:49.35849+01:00",
    "AcRate": "55.8",
    "TotalSubmissions": 358711,
    "TotalAccepted": 200112,
    "AcceptanceRate": 0.5578641301772179,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/maximum-width-ramp/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient approach to this problem utilizes a monotonic stack. The brute-force O(N^2) solution is too slow given the constraints, and while an O(N log N) solution involving sorting is possible, the monotonic stack provides a linear O(N) time complexity.\n\nThe core idea is to first identify the best candidates for the starting index `i` of a ramp. A good starting index `i` should have a small `nums[i]`. If we have two indices `i1 < i2` where `nums[i1] <= nums[i2]`, `i1` is always a better or equal candidate for the start of a ramp than `i2`. This is because any ramp `(i2, j)` could be extended to `(i1, j)` (since `nums[i1] <= nums[i2] <= nums[j]`) and `j - i1` would be wider. This suggests that our ideal candidates for `i` are indices that form a monotonically decreasing sequence of values.\n\nThe algorithm proceeds in two passes:\n1.  **First Pass (Build Candidate Stack):** We iterate through `nums` from left to right and build a stack of indices. An index `i` is pushed onto the stack only if `nums[i]` is smaller than the value at the index currently at the top of the stack. This creates a stack of indices `i` where their corresponding `nums[i]` values are strictly decreasing. These are our optimal \"left-side\" candidates for the ramp.\n\n2.  **Second Pass (Find Maximum Width):** We iterate through `nums` from right to left with an index `j`. For each `j`, we check if `nums[j]` can form a ramp with the candidates in our stack. Since we want to maximize the width `j - i`, we compare `nums[j]` with the `nums[i]` for `i` at the top of the stack. If `nums[i] <= nums[j]`, we have found a valid ramp. We calculate its width and pop `i` from the stack. We pop because for this specific `i`, the current `j` is the best possible (rightmost) partner. We continue this process with the new top of the stack until `nums[j]` is smaller than the value for the candidate at the top, or the stack is empty.\n\nBy processing `j` from right to left, and pairing it with the smallest suitable `i` from our candidate stack, we ensure that we find the maximum possible width. This two-pass approach results in O(N) time complexity and O(N) space complexity for the stack.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        \n        # This stack will store indices of candidates for the start of a ramp.\n        # These candidates form a monotonically decreasing subsequence of values.\n        s = []\n        for i, num in enumerate(nums):\n            if not s or num < nums[s[-1]]:\n                s.append(i)\n\n        max_width = 0\n        # Iterate from the right to find the end of the ramp `j`.\n        # For each `j`, check for a valid ramp with candidates from the stack.\n        for j in range(len(nums) - 1, -1, -1):\n            while s and nums[s[-1]] <= nums[j]:\n                # A valid ramp (i, j) is found.\n                # `s[-1]` is the best candidate `i` so far for this `j`.\n                i = s.pop()\n                max_width = max(max_width, j - i)\n            \n            # Optimization: If the stack of candidates is empty, no wider\n            # ramp can be found by decreasing j, so we can stop early.\n            if not s:\n                break\n                \n        return max_width\n\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stack = []\n        n = len(nums)\n\n        # First pass: Build a stack of candidate indices for the ramp's start.\n        # These indices correspond to a monotonically decreasing sequence of values in nums.\n        for i in range(n):\n            if not stack or nums[i] < nums[stack[-1]]:\n                stack.append(i)\n\n        max_width = 0\n        # Second pass: Iterate from the right of the array to find the ramp's end.\n        for j in range(n - 1, -1, -1):\n            # For a given j, find the best i from our candidates.\n            # Best i means smallest index i for which nums[i] <= nums[j].\n            # The indices in the stack are increasing, but their corresponding values form a\n            # decreasing sequence. We check from the top of the stack.\n            while stack and nums[stack[-1]] <= nums[j]:\n                # A valid ramp (i, j) is found.\n                i = stack.pop()\n                width = j - i\n                max_width = max(max_width, width)\n                # We pop the index i because for this i, the current j is the\n                # best possible (rightmost) partner. We don't need to check this i again.\n                # The next element in the stack (if any) is an index smaller than the\n                # one we just popped, which could give an even wider ramp with the same j.\n            \n            # Optimization: If the stack of candidates is empty, no more ramps can be found\n            # by decreasing j, because we have exhausted all candidate start points.\n            if not stack:\n                break\n                \n        return max_width\n```\n\n=== IMPLEMENTATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stack = []\n        n = len(nums)\n        for i in range(n):\n            if not stack or nums[i] < nums[stack[-1]]:\n                stack.append(i)\n        \n        max_width = 0\n        for j in range(n - 1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[j]:\n                i = stack.pop()\n                width = j - i\n                max_width = max(max_width, width)\n            \n            if not stack:\n                break\n                \n        return max_width\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stack = []\n        n = len(nums)\n        # First pass: Build a stack of candidate indices for the ramp's start.\n        # These indices correspond to a monotonically decreasing sequence of values in nums.\n        for i in range(n):\n            if not stack or nums[i] < nums[stack[-1]]:\n                stack.append(i)\n        \n        max_width = 0\n        # Second pass: Iterate from the right of the array to find the ramp's end.\n        for j in range(n - 1, -1, -1):\n            # For a given j, find the best i from our candidates.\n            # Best i means smallest index i for which nums[i] <= nums[j].\n            while stack and nums[stack[-1]] <= nums[j]:\n                # A valid ramp (i, j) is found.\n                i = stack.pop()\n                width = j - i\n                max_width = max(max_width, width)\n                # We pop the index i because for this i, the current j is the\n                # best possible (rightmost) partner.\n            \n            # Optimization: If the stack of candidates is empty, no more ramps can be found\n            # by decreasing j.\n            if not stack:\n                break\n                \n        return max_width\n```\n\n",
      "TypedCode": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stack = []\n        n = len(nums)\n        for i in range(n):\n            if not stack or nums[i] < nums[stack[-1]]:\n                stack.append(i)\n        \n        max_width = 0\n        for j in range(n - 1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[j]:\n                i = stack.pop()\n                width = j - i\n                max_width = max(max_width, width)\n            \n            if not stack:\n                break\n                \n        return max_width\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 290781450083,
      "SolvedAt": "2025-11-21T13:33:36.83295+01:00",
      "PromptTokens": 6144,
      "OutputTokens": 37409
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1002",
        "typed_code": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stack = []\n        n = len(nums)\n        for i in range(n):\n            if not stack or nums[i] < nums[stack[-1]]:\n                stack.append(i)\n        \n        max_width = 0\n        for j in range(n - 1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[j]:\n                i = stack.pop()\n                width = j - i\n                max_width = max(max_width, width)\n            \n            if not stack:\n                break\n                \n        return max_width\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:44:48+01:00"
    }
  }
}