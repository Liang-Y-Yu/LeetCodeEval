{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "424",
        "questionId": "424",
        "Content": "<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>\n\n<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABAB&quot;, k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;AABABBA&quot;, k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.\nThe substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only uppercase English letters.</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "SampleTestCase": "\"ABAB\"\n2",
        "ExampleTestcases": "\"ABAB\"\n2\n\"AABABBA\"\n1",
        "Difficulty": "Medium",
        "Title": "Longest Repeating Character Replacement",
        "TitleSlug": "longest-repeating-character-replacement",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1330577, \"totalSubmissionRaw\": 2279045, \"acRate\": \"58.4%\"}",
        "Likes": 12451,
        "Dislikes": 713,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int characterReplacement(String s, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function characterReplacement(s: string, k: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int CharacterReplacement(string s, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int characterReplacement(char* s, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func characterReplacement(s string, k int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun characterReplacement(s: String, k: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn character_replacement(s: String, k: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef character_replacement(s, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function characterReplacement($s, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int characterReplacement(String s, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def characterReplacement(s: String, k: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec character_replacement(s :: String.t, k :: integer) :: integer\n  def character_replacement(s, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec character_replacement(S :: unicode:unicode_binary(), K :: integer()) -> integer().\ncharacter_replacement(S, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (character-replacement s k)\n  (-> string? exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:17:47.343352+01:00",
    "AcRate": "58.4",
    "TotalSubmissions": 2279045,
    "TotalAccepted": 1330577,
    "AcceptanceRate": 0.583830946734268,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/longest-repeating-character-replacement/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution to this problem uses the **sliding window** technique. The core idea is to maintain a window `[left, right]` over the string and expand it by moving the `right` pointer. We keep track of the character frequencies within this window.\n\nA window is considered \"valid\" if the number of characters we need to change to make the entire window a single character is no more than `k`. For a window of length `L` where the most frequent character appears `max_f` times, the number of changes required is `L - max_f`. Thus, the condition for a valid window is `L - max_f <= k`.\n\nOur algorithm iterates through the string with the `right` pointer, expanding the window. At each step, we update the frequency count of the new character and also the frequency of the most common character seen so far in any window (`max_freq`).\n\nIf the current window `[left, right]` becomes invalid (i.e., `(right - left + 1) - max_freq > k`), we shrink it by moving the `left` pointer to the right. This maintains a window that is always \"almost\" valid.\n\nA key optimization is that we don't need to re-calculate `max_freq` precisely when the window shrinks. We only care about finding a window *longer* than the one we've already found. A longer window can only be valid if its `max_freq` is also larger. Therefore, we can use the historical maximum frequency encountered, which simplifies the logic and preserves the `O(N)` time complexity.\n\nThe length of the current window is `right - left + 1`. We track the maximum length this window achieves throughout the process, which will be our final answer. The space complexity is constant, `O(1)`, as we only need an array of size 26 to store character frequencies.\n\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            window_len = right - left + 1\n            \n            if (window_len - max_freq) > k:\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            \n        return result\n```\n\n=== DESIGN ===\nBased on the problem analysis, here is the high-level algorithmic design.\n\n### **Solution Design**\n\n**1. Algorithm Choice**\nThe problem is best solved using a **Sliding Window** algorithm. This approach is highly efficient for finding the longest substring (or subarray) that satisfies a given condition. By maintaining a \"window\" over the string and intelligently expanding and shrinking it, we can check all potential substrings in a single pass, avoiding redundant calculations.\n\n**2. Step-by-Step Approach**\n1.  Initialize a `left` pointer to 0 and a `result` variable to 0, which will store the length of the longest valid substring found.\n2.  Initialize a data structure (e.g., an array of size 26) to store the frequency of characters within the current window `[left, right]`. Also, initialize a variable `max_freq` to 0, which will track the frequency of the most common character in any window encountered so far.\n3.  Iterate through the string with a `right` pointer from 0 to the end of the string.\n4.  For each character `s[right]`, expand the window by including this character:\n    a. Increment the frequency count for `s[right]`.\n    b. Update `max_freq = max(max_freq, new count of s[right])`.\n5.  Check if the current window is \"valid\". A window is valid if the number of characters we need to replace is at most `k`. This number is calculated as `window_length - max_freq`.\n6.  If `(right - left + 1) - max_freq > k`, the window is invalid. We must shrink it from the left until it becomes valid again:\n    a. Decrement the frequency count of the character `s[left]`.\n    b. Move the `left` pointer one position to the right (`left += 1`).\n7.  After each step (and potential shrink), the current window `[left, right]` is the longest valid window *ending at `right`*. Update the overall maximum length: `result = max(result, right - left + 1)`.\n8.  After the loop finishes, `result` holds the maximum length found across all windows. Return `result`.\n\n**3. Data Structures**\n*   **Integer Array (size 26):** To serve as a frequency map for the 26 uppercase English letters. This provides O(1) time for updating and retrieving character counts.\n*   **Integer Pointers/Variables:**\n    *   `left`, `right`: To define the boundaries of the sliding window.\n    *   `max_freq`: To store the highest frequency of any single character seen in a window so far.\n    *   `result`: To maintain the maximum valid window length found.\n\n**4. Time Complexity**\nThe algorithm involves a single pass through the string. Both the `right` and `left` pointers only move forward. Each character of the string is visited at most twice (once by `right` and once by `left`). All operations inside the loop are constant time. Therefore, the time complexity is **O(N)**, where N is the length of the string `s`.\n\n**5. Space Complexity**\nThe space required is for the frequency map, which is an array of size 26. This size is constant and does not depend on the input string's length. Thus, the space complexity is **O(1)**.\n\n**6. Pseudocode**\n```pseudocode\nfunction characterReplacement(s, k):\n    n = length of s\n    counts = new array of size 26, initialized to 0\n    left = 0\n    max_freq = 0\n    result = 0\n\n    for right from 0 to n-1:\n        // Expand the window to the right\n        char_right_idx = get_char_index(s[right])\n        counts[char_right_idx] = counts[char_right_idx] + 1\n        max_freq = max(max_freq, counts[char_right_idx])\n\n        // Calculate the number of characters to replace\n        replacements_needed = (right - left + 1) - max_freq\n\n        // If the window is invalid, shrink it from the left\n        if replacements_needed > k:\n            char_left_idx = get_char_index(s[left])\n            counts[char_left_idx] = counts[char_left_idx] - 1\n            left = left + 1\n        \n        // Update the maximum length found so far\n        result = max(result, right - left + 1)\n        \n    return result\n```\n\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            # The number of characters to change is the window length minus the\n            # count of the most frequent character.\n            # window_len = right - left + 1\n            if (right - left + 1) - max_freq > k:\n                # Shrink the window from the left\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            # The current window size is a candidate for the answer.\n            # We track the maximum size seen.\n            result = max(result, right - left + 1)\n            \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            if (right - left + 1) - max_freq > k:\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            \n        return result\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            if (right - left + 1) - max_freq > k:\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            \n        return result\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            if (right - left + 1) - max_freq > k:\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            \n        return result\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 368316790708,
      "SolvedAt": "2025-11-21T19:30:13.758815+01:00",
      "PromptTokens": 7069,
      "OutputTokens": 44689
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "424",
        "typed_code": "\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        counts = [0] * 26\n        left = 0\n        max_freq = 0\n        result = 0\n        \n        for right in range(len(s)):\n            char_idx = ord(s[right]) - ord('A')\n            counts[char_idx] += 1\n            max_freq = max(max_freq, counts[char_idx])\n            \n            if (right - left + 1) - max_freq > k:\n                left_char_idx = ord(s[left]) - ord('A')\n                counts[left_char_idx] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:40:14+01:00"
    }
  }
}