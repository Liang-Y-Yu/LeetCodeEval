{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "901",
        "questionId": "937",
        "Content": "<p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>\n\n<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>\n\n<ul>\n\t<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>\n\t<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>\n</ul>\n\n<p>Implement the <code>StockSpanner</code> class:</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> Initializes the object of the class.</li>\n\t<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>Output</strong>\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>Explanation</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.\nstockSpanner.next(85);  // return 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "ExampleTestcases": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "Difficulty": "Medium",
        "Title": "Online Stock Span",
        "TitleSlug": "online-stock-span",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"533.2K\", \"totalSubmission\": \"780.3K\", \"totalAcceptedRaw\": 533155, \"totalSubmissionRaw\": 780342, \"acRate\": \"68.3%\"}",
        "Likes": 7070,
        "Dislikes": 486,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjE1",
            "Name": "Stack",
            "Slug": "stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU0",
            "Name": "Monotonic Stack",
            "Slug": "monotonic-stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class StockSpanner(object):\n\n    def __init__(self):\n        \n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar StockSpanner = function() {\n    \n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    \n};\n\n/** \n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class StockSpanner {\n    constructor() {\n        \n    }\n\n    next(price: number): number {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int Next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.Next(price);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} StockSpanner;\n\n\nStockSpanner* stockSpannerCreate() {\n    \n}\n\nint stockSpannerNext(StockSpanner* obj, int price) {\n    \n}\n\nvoid stockSpannerFree(StockSpanner* obj) {\n    \n}\n\n/**\n * Your StockSpanner struct will be instantiated and called as such:\n * StockSpanner* obj = stockSpannerCreate();\n * int param_1 = stockSpannerNext(obj, price);\n \n * stockSpannerFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type StockSpanner struct {\n    \n}\n\n\nfunc Constructor() StockSpanner {\n    \n}\n\n\nfunc (this *StockSpanner) Next(price int) int {\n    \n}\n\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Next(price);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class StockSpanner() {\n\n    fun next(price: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass StockSpanner {\n\n    init() {\n        \n    }\n    \n    func next(_ price: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner()\n * let ret_1: Int = obj.next(price)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct StockSpanner {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockSpanner {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn next(&self, price: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner::new();\n * let ret_1: i32 = obj.next(price);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class StockSpanner\n    def initialize()\n        \n    end\n\n\n=begin\n    :type price: Integer\n    :rtype: Integer\n=end\n    def next(price)\n        \n    end\n\n\nend\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner.new()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class StockSpanner {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $price\n     * @return Integer\n     */\n    function next($price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * $obj = StockSpanner();\n * $ret_1 = $obj->next($price);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class StockSpanner {\n\n  StockSpanner() {\n    \n  }\n  \n  int next(int price) {\n    \n  }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = StockSpanner();\n * int param1 = obj.next(price);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class StockSpanner() {\n\n    def next(price: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * val obj = new StockSpanner()\n * val param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule StockSpanner do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec next(price :: integer) :: integer\n  def next(price) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockSpanner.init_()\n# param_1 = StockSpanner.next(price)\n\n# StockSpanner.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec stock_spanner_init_() -> any().\nstock_spanner_init_() ->\n  .\n\n-spec stock_spanner_next(Price :: integer()) -> integer().\nstock_spanner_next(Price) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_spanner_init_(),\n%% Param_1 = stock_spanner_next(Price),\n\n%% stock_spanner_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define stock-spanner%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; next : exact-integer? -> exact-integer?\n    (define/public (next price)\n      )))\n\n;; Your stock-spanner% object will be instantiated and called as such:\n;; (define obj (new stock-spanner%))\n;; (define param_1 (send obj next price))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:50:37.88752+01:00",
    "AcRate": "68.3",
    "TotalSubmissions": 780342,
    "TotalAccepted": 533155,
    "AcceptanceRate": 0.683232480117692,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/online-stock-span/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution to this problem uses a **monotonic stack**. The goal is to calculate the span, which is the number of consecutive previous days where the price was less than or equal to the current day's price. A naive approach of iterating backward for each new price would be too slow (O(N^2) for N calls), so we need a more optimized method.\n\nA monotonic stack, in this case, will store pairs of `(price, span)` and will be maintained in a strictly decreasing order of prices. When a new price arrives, we can efficiently find its span by looking at the top of the stack.\n\nHere's the logic for each `next(price)` call:\n1. Initialize a `span` counter for the current day to 1 (for the day itself).\n2. Look at the element at the top of the stack. This element represents the most recent day (or block of days) with a price greater than the days that followed it.\n3. While the stack is not empty and the current `price` is greater than or equal to the price at the top of the stack, we know that the current day's span includes the span of that top element.\n4. We add the popped element's span to our current `span` and pop it from the stack. We repeat this process, effectively \"consuming\" all previous consecutive days with prices less than or equal to the current day's price. The clever part is that each element on the stack already has its own span pre-calculated, allowing us to jump back in history by more than one day at a time.\n5. Once the loop terminates, either the stack is empty (meaning the current price is the highest so far) or the price at the top of the stack is greater than the current price.\n6. We then push the current `(price, calculated_span)` pair onto the stack. This maintains the state for future calls and upholds the monotonic (decreasing price) property of the stack.\n7. Finally, we return the calculated `span`.\n\nThis approach ensures that each price/span pair is pushed onto the stack exactly once and popped at most once over the entire series of calls. This results in an amortized time complexity of O(1) for each `next` call, making the total time complexity O(N) for N calls, which is highly efficient.\n\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        current_span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            prev_price, prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        self.stack.append((price, current_span))\n        \n        return current_span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n```\n\n=== DESIGN ===\nAn elegant and efficient solution to this problem uses a **monotonic stack**. The goal is to calculate the span, which is the number of consecutive previous days where the price was less than or equal to the current day's price. A naive approach of iterating backward for each new price would be too slow (O(N^2) for N calls), so we need a more optimized method.\n\nA monotonic stack, in this case, will store pairs of `(price, span)` and will be maintained in a strictly decreasing order of prices. When a new price arrives, we can efficiently find its span by looking at the top of the stack.\n\nHere's the logic for each `next(price)` call:\n1. Initialize a `span` counter for the current day to 1 (for the day itself).\n2. Look at the element at the top of the stack. This element represents the most recent day (or block of days) with a price greater than the days that followed it.\n3. While the stack is not empty and the current `price` is greater than or equal to the price at the top of the stack, we know that the current day's span includes the span of that top element.\n4. We add the popped element's span to our current `span` and pop it from the stack. We repeat this process, effectively \"consuming\" all previous consecutive days with prices less than or equal to the current day's price. The clever part is that each element on the stack already has its own span pre-calculated, allowing us to jump back in history by more than one day at a time.\n5. Once the loop terminates, either the stack is empty (meaning the current price is the highest so far) or the price at the top of the stack is greater than the current price.\n6. We then push the current `(price, calculated_span)` pair onto the stack. This maintains the state for future calls and upholds the monotonic (decreasing price) property of the stack.\n7. Finally, we return the calculated `span`.\n\nThis approach ensures that each price/span pair is pushed onto the stack exactly once and popped at most once over the entire series of calls. This results in an amortized time complexity of O(1) for each `next` call, making the total time complexity O(N) for N calls, which is highly efficient.\n\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        # The stack will store tuples of (price, span)\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        # The span for the current day starts at 1 (for the day itself)\n        current_span = 1\n        \n        # While the stack is not empty and the price at the top of the stack\n        # is less than or equal to the current price\n        while self.stack and self.stack[-1][0] <= price:\n            # We can extend the current span by the span of the previous, smaller element.\n            # Pop the weaker element as it is now \"hidden\" by the current price.\n            prev_price, prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        # Push the current price and its calculated span onto the stack.\n        # This maintains the monotonic (decreasing price) property.\n        self.stack.append((price, current_span))\n        \n        return current_span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n```\n\n=== IMPLEMENTATION ===\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        current_span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            prev_price, prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        self.stack.append((price, current_span))\n        \n        return current_span\n```\n\n=== VERIFICATION ===\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        # The stack will store tuples of (price, span)\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        # The span for the current day starts at 1 (for the day itself)\n        current_span = 1\n        \n        # While the stack is not empty and the price at the top of the stack\n        # is less than or equal to the current price\n        while self.stack and self.stack[-1][0] <= price:\n            # We can extend the current span by the span of the previous, smaller element.\n            # Pop that element as its span is now incorporated into the current one.\n            # We don't need its price, just its span.\n            _ , prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        # Push the current price and its calculated span onto the stack.\n        # This maintains the monotonic (decreasing price) property of the stack.\n        self.stack.append((price, current_span))\n        \n        return current_span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n```\n\n",
      "TypedCode": "\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        current_span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            prev_price, prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        self.stack.append((price, current_span))\n        \n        return current_span\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 130967951208,
      "SolvedAt": "2025-11-21T15:10:13.793941+01:00",
      "PromptTokens": 7524,
      "OutputTokens": 15007
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "937",
        "typed_code": "\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        current_span = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            prev_price, prev_span = self.stack.pop()\n            current_span += prev_span\n            \n        self.stack.append((price, current_span))\n        \n        return current_span\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:08:58+01:00"
    }
  }
}