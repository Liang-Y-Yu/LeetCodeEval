{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "502",
        "questionId": "502",
        "Content": "<p>Suppose LeetCode will start its <strong>IPO</strong> soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the <strong>IPO</strong>. Since it has limited resources, it can only finish at most <code>k</code> distinct projects before the <strong>IPO</strong>. Help LeetCode design the best way to maximize its total capital after finishing at most <code>k</code> distinct projects.</p>\n\n<p>You are given <code>n</code> projects where the <code>i<sup>th</sup></code> project has a pure profit <code>profits[i]</code> and a minimum capital of <code>capital[i]</code> is needed to start it.</p>\n\n<p>Initially, you have <code>w</code> capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.</p>\n\n<p>Pick a list of <strong>at most</strong> <code>k</code> distinct projects from given projects to <strong>maximize your final capital</strong>, and return <em>the final maximized capital</em>.</p>\n\n<p>The answer is guaranteed to fit in a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "SampleTestCase": "2\n0\n[1,2,3]\n[0,1,1]",
        "ExampleTestcases": "2\n0\n[1,2,3]\n[0,1,1]\n3\n0\n[1,2,3]\n[0,1,2]",
        "Difficulty": "Hard",
        "Title": "IPO",
        "TitleSlug": "ipo",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"294.2K\", \"totalSubmission\": \"553.3K\", \"totalAcceptedRaw\": 294220, \"totalSubmissionRaw\": 553286, \"acRate\": \"53.2%\"}",
        "Likes": 4106,
        "Dislikes": 279,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number} k\n * @param {number} w\n * @param {number[]} profits\n * @param {number[]} capital\n * @return {number}\n */\nvar findMaximizedCapital = function(k, w, profits, capital) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findMaximizedCapital(k: number, w: number, profits: number[], capital: number[]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int FindMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findMaximizedCapital(k int, w int, profits []int, capital []int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findMaximizedCapital(k: Int, w: Int, profits: IntArray, capital: IntArray): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findMaximizedCapital(_ k: Int, _ w: Int, _ profits: [Int], _ capital: [Int]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer} k\n# @param {Integer} w\n# @param {Integer[]} profits\n# @param {Integer[]} capital\n# @return {Integer}\ndef find_maximized_capital(k, w, profits, capital)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer $k\n     * @param Integer $w\n     * @param Integer[] $profits\n     * @param Integer[] $capital\n     * @return Integer\n     */\n    function findMaximizedCapital($k, $w, $profits, $capital) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int findMaximizedCapital(int k, int w, List<int> profits, List<int> capital) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findMaximizedCapital(k: Int, w: Int, profits: Array[Int], capital: Array[Int]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_maximized_capital(k :: integer, w :: integer, profits :: [integer], capital :: [integer]) :: integer\n  def find_maximized_capital(k, w, profits, capital) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_maximized_capital(K :: integer(), W :: integer(), Profits :: [integer()], Capital :: [integer()]) -> integer().\nfind_maximized_capital(K, W, Profits, Capital) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-maximized-capital k w profits capital)\n  (-> exact-integer? exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:14:00.079234+01:00",
    "AcRate": "53.2",
    "TotalSubmissions": 553286,
    "TotalAccepted": 294220,
    "AcceptanceRate": 0.5317683801867389,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/ipo/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and effective way to solve this problem is by using a greedy approach, optimized with a combination of sorting and a priority queue (max-heap).\n\nAt each step, we want to choose a project that gives us the maximum possible profit. However, we are constrained by our current capital. The set of projects we can afford grows as our capital increases. This suggests the following strategy:\n\n1.  Identify all projects that are currently affordable with our capital `w`.\n2.  From this set of affordable projects, choose the one with the highest profit.\n3.  Add this profit to our capital.\n4.  Repeat this process for `k` projects.\n\nTo implement this efficiently:\n-   We can sort the projects by their capital requirement. This allows us to iterate through them just once. As our capital `w` increases, we can check for newly affordable projects without re-scanning the entire list.\n-   A max-heap is the ideal data structure to keep track of the profits of all affordable projects and quickly retrieve the maximum one.\n\nHere is the step-by-step algorithm:\n\n1.  Combine the `capital` and `profits` arrays into pairs and sort them based on the capital required.\n2.  Initialize a pointer to the start of this sorted list of projects and an empty max-heap to store profits.\n3.  Loop `k` times:\n    a.  Add all projects that have now become affordable (i.e., `capital <= w`) to the max-heap. We can do this by advancing our pointer through the sorted list.\n    b.  If the max-heap is empty, it means there are no affordable projects to choose from, so we cannot continue. We break the loop.\n    c.  If the heap is not empty, we extract the maximum profit (the top of the max-heap), add it to our capital `w`, and proceed to the next iteration.\n4.  After the loop finishes (either by completing `k` projects or running out of options), the final value of `w` is the maximized capital.\n\nThis approach has a time complexity of O(N log N + K log N) due to the initial sort and the heap operations, which is efficient enough for the given constraints.\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n\n        # Max-heap to store profits of affordable projects.\n        # Python's heapq is a min-heap, so we store negative profits.\n        max_heap = []\n        project_idx = 0\n\n        # We can perform at most k projects.\n        for _ in range(k):\n            # Add all projects that we can afford with current capital w to the max-heap.\n            while project_idx < n and projects[project_idx][0] <= w:\n                # Push the negative profit to simulate a max-heap.\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            # If the max-heap is empty, it means there are no affordable projects left.\n            if not max_heap:\n                break\n            \n            # Choose the most profitable project from the affordable ones.\n            # The top of the max-heap gives the largest profit.\n            w += -heapq.heappop(max_heap)\n\n        return w\n```\n\n=== DESIGN ===\nAn elegant and effective way to solve this problem is by using a greedy approach, optimized with a combination of sorting and a priority queue (max-heap).\nAt each step, we want to choose a project that gives us the maximum possible profit. However, we are constrained by our current capital. The set of projects we can afford grows as our capital increases. This suggests the following strategy:\n1.  Identify all projects that are currently affordable with our capital `w`.\n2.  From this set of affordable projects, choose the one with the highest profit.\n3.  Add this profit to our capital.\n4.  Repeat this process for `k` projects.\nTo implement this efficiently:\n-   We can sort the projects by their capital requirement. This allows us to iterate through them just once. As our capital `w` increases, we can check for newly affordable projects without re-scanning the entire list.\n-   A max-heap is the ideal data structure to keep track of the profits of all affordable projects and quickly retrieve the maximum one.\n\n**1. Algorithm Choice**\nThe chosen algorithm is a greedy approach. The core idea is to make the locally optimal choice at each step: select the most profitable project among all currently affordable ones. This strategy is implemented efficiently using sorting and a max-heap.\n\n**2. Step-by-Step Approach**\n1.  **Combine and Sort**: Create a single data structure containing pairs of `(capital, profit)` for each project. Sort this list of projects primarily by their required capital in ascending order. This allows us to process projects in an order of increasing affordability.\n2.  **Initialize**: Set up an empty max-heap to store the profits of projects we can afford but haven't started yet. Also, use a pointer, say `project_idx`, to keep track of the next project to consider from the sorted list.\n3.  **Iterate and Select**: Loop `k` times, as we can undertake at most `k` projects. In each iteration:\n    a.  **Find Affordable Projects**: Go through the sorted projects list starting from `project_idx`. For every project whose capital requirement is less than or equal to the current capital `w`, add its profit to the max-heap. Increment `project_idx` accordingly.\n    b.  **Check for Feasibility**: If the max-heap is empty, it means there are no affordable projects we can start. In this case, we cannot do any more projects, so we break the loop.\n    c.  **Choose Best Project**: If the max-heap is not empty, extract the maximum profit from it. This represents choosing the most profitable project available.\n    d.  **Update Capital**: Add the extracted profit to the current capital `w`.\n4.  **Return Result**: After the loop finishes (either by completing `k` projects or by running out of affordable options), the final value of `w` represents the maximum possible capital. Return `w`.\n\n**3. Data Structures**\n*   **List of Tuples**: A list of `(capital, profit)` tuples is used to associate each project's profit with its capital requirement. This is essential for sorting.\n*   **Max-Heap (Priority Queue)**: A max-heap is used to maintain the profits of all affordable projects. It provides efficient O(log N) access to the maximum profit, which is crucial for the greedy selection step. In Python, this is typically implemented using the `heapq` module (a min-heap) by storing negative profit values.\n\n**4. Time Complexity**\n*   The initial sorting of `N` projects takes **O(N log N)**.\n*   The main loop runs at most `k` times.\n*   Inside the loop, the `while` loop iterates through the projects list. Over all `k` iterations, each of the `N` projects is considered and pushed to the heap exactly once. Each push operation takes O(log N) time. Thus, the total time for all pushes is **O(N log N)**.\n*   Each of the `k` iterations involves one pop operation from the heap, which takes O(log N) time. The total time for all pops is **O(k log N)**.\n*   Therefore, the overall time complexity is **O(N log N + k log N)**.\n\n**5. Space Complexity**\n*   Storing the `N` projects in a list requires **O(N)** space.\n*   The max-heap can, in the worst-case scenario, store the profits of all `N` projects. This also requires **O(N)** space.\n*   Therefore, the total space complexity is **O(N)**.\n\n**6. Pseudocode**\n```pseudocode\nfunction findMaximizedCapital(k, w, profits, capital):\n    n = length of profits\n    \n    // Combine profits and capital, then sort by capital\n    projects = create a list of (capital, profit) pairs\n    sort projects based on capital in ascending order\n    \n    // Initialize a max-heap for profits and a project pointer\n    max_heap_profits = new MaxHeap()\n    project_idx = 0\n    \n    // Perform up to k projects\n    repeat k times:\n        // Add all affordable projects' profits to the heap\n        while project_idx < n AND projects[project_idx].capital <= w:\n            max_heap_profits.push(projects[project_idx].profit)\n            project_idx = project_idx + 1\n        \n        // If no affordable projects, we can't continue\n        if max_heap_profits is empty:\n            break\n            \n        // Select the most profitable project, add its profit to capital\n        max_profit = max_heap_profits.pop()\n        w = w + max_profit\n        \n    // Return the final capital\n    return w\n```\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        max_heap = []\n        project_idx = 0\n        \n        for _ in range(k):\n            while project_idx < n and projects[project_idx][0] <= w:\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            if not max_heap:\n                break\n            \n            w += -heapq.heappop(max_heap)\n            \n        return w\n```\n\n=== IMPLEMENTATION ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        max_heap = []\n        project_idx = 0\n        \n        for _ in range(k):\n            while project_idx < n and projects[project_idx][0] <= w:\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            if not max_heap:\n                break\n            \n            w += -heapq.heappop(max_heap)\n            \n        return w\n```\n\n=== VERIFICATION ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        max_heap = []\n        project_idx = 0\n        \n        for _ in range(k):\n            while project_idx < n and projects[project_idx][0] <= w:\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            if not max_heap:\n                break\n            \n            w += -heapq.heappop(max_heap)\n            \n        return w\n```\n\n",
      "TypedCode": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        max_heap = []\n        project_idx = 0\n        \n        for _ in range(k):\n            while project_idx < n and projects[project_idx][0] <= w:\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            if not max_heap:\n                break\n            \n            w += -heapq.heappop(max_heap)\n            \n        return w\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 171613770041,
      "SolvedAt": "2025-11-21T12:03:03.913823+01:00",
      "PromptTokens": 8912,
      "OutputTokens": 21718
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "502",
        "typed_code": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        max_heap = []\n        project_idx = 0\n        \n        for _ in range(k):\n            while project_idx < n and projects[project_idx][0] <= w:\n                heapq.heappush(max_heap, -projects[project_idx][1])\n                project_idx += 1\n            \n            if not max_heap:\n                break\n            \n            w += -heapq.heappop(max_heap)\n            \n        return w\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:38:57+01:00"
    }
  }
}