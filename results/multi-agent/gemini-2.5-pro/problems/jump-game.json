{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "55",
        "questionId": "55",
        "Content": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array&#39;s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>\n\n<p>Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,0,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[2,3,1,1,4]",
        "ExampleTestcases": "[2,3,1,1,4]\n[3,2,1,0,4]",
        "Difficulty": "Medium",
        "Title": "Jump Game",
        "TitleSlug": "jump-game",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"7.3M\", \"totalAcceptedRaw\": 2921059, \"totalSubmissionRaw\": 7279248, \"acRate\": \"40.1%\"}",
        "Likes": 21245,
        "Dislikes": 1451,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function canJump(nums: number[]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool CanJump(int[] nums) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool canJump(int* nums, int numsSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func canJump(nums []int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun canJump(nums: IntArray): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_jump(nums)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canJump($nums) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool canJump(List<int> nums) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def canJump(nums: Array[Int]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec can_jump(nums :: [integer]) :: boolean\n  def can_jump(nums) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec can_jump(Nums :: [integer()]) -> boolean().\ncan_jump(Nums) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (can-jump nums)\n  (-> (listof exact-integer?) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:36:09.506795+01:00",
    "AcRate": "40.1",
    "TotalSubmissions": 7279248,
    "TotalAccepted": 2921059,
    "AcceptanceRate": 0.401285819634116,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/jump-game/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n```\n\n=== DESIGN ===\nAn elegant and efficient way to solve this problem is using a greedy approach. The core idea is to iterate through the array, keeping track of the furthest index we can possibly reach.\n\n**1. Algorithm Choice**\nA greedy algorithm is the most suitable choice. At each position, we make the locally optimal choice of trying to jump as far as possible. This approach avoids the complexity of exploring all possible jump paths (like with recursion or BFS/DFS), leading to a much faster solution. We maintain a single variable, `max_reach`, which represents the farthest index we can get to from any of the positions we have visited so far.\n\n**2. Step-by-Step Approach**\n1.  Initialize a variable `max_reach` to 0. This variable will store the maximum reachable index from the start.\n2.  Iterate through the `nums` array using an index `i` from 0 to the end.\n3.  For each index `i`, we first check if it's reachable. The current index `i` is reachable only if it is less than or equal to the `max_reach` calculated from previous positions. If `i > max_reach`, it means we've encountered a gap that we cannot jump over, so we can never reach the end. In this case, we return `false`.\n4.  If the current index `i` is reachable, we calculate the furthest we can jump from this position, which is `i + nums[i]`.\n5.  We then update `max_reach` to be the maximum of its current value and this new potential reach (`i + nums[i]`). This greedy choice ensures `max_reach` always reflects the best possible outcome so far.\n6.  If the loop completes without ever returning `false`, it means we were able to sequentially reach every index up to the end of the array. Therefore, the last index is reachable, and we return `true`.\n\n**3. Data Structures**\n-   The input `nums` is provided as a list (or array) of integers.\n-   A single integer variable, `max_reach`, is used to store the furthest reachable index. No other complex data structures are needed.\n\n**4. Time Complexity**\nThe algorithm involves a single pass through the `nums` array. For each element, we perform a constant number of operations (a comparison, an addition, and finding the maximum). Thus, the time complexity is linear in the size of the array, which is **O(n)**, where n is the number of elements in `nums`.\n\n**5. Space Complexity**\nThe algorithm uses a fixed amount of extra space (the `max_reach` variable and the loop index). This space usage does not grow with the input size. Therefore, the space complexity is constant, **O(1)**.\n\n**6. Pseudocode**\n```\nfunction canJump(nums):\n  // max_reach stores the farthest index we can reach.\n  max_reach = 0\n  n = length of nums\n\n  // Iterate through each index of the array.\n  for i from 0 to n-1:\n    // If the current index is beyond our max reach, we are stuck.\n    if i > max_reach:\n      return false\n    \n    // Update max_reach with the furthest we can get from the current position.\n    max_reach = max(max_reach, i + nums[i])\n  \n  // If the loop completes, it means the last index was reachable.\n  return true\n```\n\n```python\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        Determines if the last index of the array can be reached.\n\n        This solution employs a greedy algorithm. It iterates through the array,\n        maintaining a variable `max_reach` that tracks the farthest index\n        reachable from any position visited so far.\n\n        Algorithm:\n        1. Initialize `max_reach = 0`.\n        2. Iterate through the array with index `i` and `jump = nums[i]`.\n        3. At each index `i`, check if `i` is reachable. If `i > max_reach`,\n           it means there's a gap and we cannot proceed. Return `False`.\n        4. If `i` is reachable, update `max_reach` to the maximum of its\n           current value and the new farthest point we can jump to from `i`,\n           which is `i + jump`.\n        5. If the loop finishes, it means every index was reachable in sequence,\n           implying the last index is also reachable. Return `True`.\n        \"\"\"\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n\n```\n\n=== IMPLEMENTATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            # If the current index is not reachable, we can't go further.\n            if i > max_reach:\n                return False\n            # Update the maximum reach based on the jump from the current index.\n            max_reach = max(max_reach, i + jump)\n        # If the loop completes, it means every index was reachable in sequence.\n        return True\n```\n\n",
      "TypedCode": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 237359765667,
      "SolvedAt": "2025-11-21T12:16:40.26558+01:00",
      "PromptTokens": 4786,
      "OutputTokens": 28618
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "55",
        "typed_code": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:46:54+01:00"
    }
  }
}