{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "239",
        "questionId": "239",
        "Content": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "SampleTestCase": "[1,3,-1,-3,5,3,6,7]\n3",
        "ExampleTestcases": "[1,3,-1,-3,5,3,6,7]\n3\n[1]\n1",
        "Difficulty": "Hard",
        "Title": "Sliding Window Maximum",
        "TitleSlug": "sliding-window-maximum",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 1500044, \"totalSubmissionRaw\": 3117997, \"acRate\": \"48.1%\"}",
        "Likes": 19886,
        "Dislikes": 799,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjM0",
            "Name": "Queue",
            "Slug": "queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcx",
            "Name": "Monotonic Queue",
            "Slug": "monotonic-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxSlidingWindow(nums: number[], k: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxSlidingWindow(nums []int, k int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sliding_window(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> maxSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]\n  def max_sliding_window(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sliding_window(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:25:34.534997+01:00",
    "AcRate": "48.1",
    "TotalSubmissions": 3117997,
    "TotalAccepted": 1500044,
    "AcceptanceRate": 0.48109218835040574,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/sliding-window-maximum/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and highly efficient approach to this problem is using a **monotonic decreasing deque**. The key idea is to maintain a double-ended queue (`deque`) of indices from the input array `nums`. This deque has two critical properties:\n\n1.  **Window Confinement**: The deque only stores indices that fall within the current sliding window.\n2.  **Monotonicity**: The indices in the deque correspond to values in `nums` that are strictly decreasing. For any two indices `i` and `j` in the deque, if `i` comes before `j`, then `nums[i] > nums[j]`.\n\nThis structure ensures that the index of the maximum element in the current window is always at the front (left side) of the deque.\n\nHere is a step-by-step breakdown of the algorithm as it iterates through the input array `nums` with index `i`:\n\n1.  **Clean Up the Front**: Before processing the current element `nums[i]`, we check the index at the front of the deque (`q[0]`). If this index is `i - k`, it means the element it points to has just slid out of the window `[i - k + 1, i]`. We must remove it from the front of the deque using `popleft()`.\n\n2.  **Maintain Monotonicity**: We then look at the current element `nums[i]`. To maintain the decreasing property, we remove all indices from the back (right side) of the deque whose corresponding values in `nums` are less than or equal to `nums[i]`. These smaller or equal older elements can never be the maximum in any future window that includes the current, larger element `nums[i]`, so they are discarded.\n\n3.  **Add the Current Element**: After ensuring the deque's monotonic property, we add the current index `i` to the back.\n\n4.  **Record the Maximum**: Once the loop index `i` has reached or surpassed `k - 1`, the first full window has been formed. For this and all subsequent windows, the maximum element is `nums[q[0]]` (the element at the front of our maintained deque). We append this maximum value to our result list.\n\nThis process is repeated for all elements in `nums`. Since each element's index is added to and removed from the deque at most once, the overall time complexity is **O(N)**, where N is the number of elements in `nums`. The space complexity is **O(k)**, as the deque stores at most `k` indices.\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Finds the maximum value in a sliding window of size k across an array.\n        This solution uses a monotonic decreasing deque to achieve O(N) time complexity.\n        \"\"\"\n        \n        result = []\n        # The deque stores indices of elements in the current window.\n        # It's maintained such that the corresponding values are in decreasing order.\n        q = collections.deque()\n\n        for i, current_num in enumerate(nums):\n            # 1. Remove indices from the front that are no longer in the window.\n            # The window is from [i - k + 1, i]. The element at index i-k just fell out.\n            if q and q[0] == i - k:\n                q.popleft()\n\n            # 2. Maintain the monotonic decreasing property of the deque.\n            # Remove indices from the back if their values are less than or equal to\n            # the current value, as they can no longer be the maximum.\n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n            \n            # 3. Add the current element's index to the deque.\n            q.append(i)\n\n            # 4. If the window has reached size k, the maximum is at the front of the deque.\n            # This condition is met for the first time at index k-1.\n            if i >= k - 1:\n                result.append(nums[q[0]])\n        \n        return result\n\n```\n\n=== DESIGN ===\nAn elegant and highly efficient approach to this problem is using a monotonic decreasing deque. The key idea is to maintain a double-ended queue (`deque`) of indices from the input array `nums`. This deque has two critical properties:\n\n1.  **Window Confinement**: The deque only stores indices that fall within the current sliding window.\n2.  **Monotonicity**: The indices in the deque correspond to values in `nums` that are strictly decreasing. For any two indices `i` and `j` in the deque, if `i` comes before `j`, then `nums[i] > nums[j]`.\n\nThis structure ensures that the index of the maximum element in the current window is always at the front (left side) of the deque.\n\nHere is a step-by-step breakdown of the algorithm as it iterates through the input array `nums` with index `i`:\n\n1.  **Clean Up the Front**: Before processing the current element `nums[i]`, we check the index at the front of the deque (`q[0]`). If this index is `i - k`, it means the element it points to has just slid out of the window `[i - k + 1, i]`. We must remove it from the front of the deque using `popleft()`.\n\n2.  **Maintain Monotonicity**: We then look at the current element `nums[i]`. To maintain the decreasing property, we remove all indices from the back (right side) of the deque whose corresponding values in `nums` are less than or equal to `nums[i]`. These smaller or equal older elements can never be the maximum in any future window that includes the current, larger element `nums[i]`, so they are discarded.\n\n3.  **Add the Current Element**: After ensuring the deque's monotonic property, we add the current index `i` to the back.\n\n4.  **Record the Maximum**: Once the loop index `i` has reached or surpassed `k - 1`, the first full window has been formed. For this and all subsequent windows, the maximum element is `nums[q[0]]` (the element at the front of our maintained deque). We append this maximum value to our result list.\n\nThis process is repeated for all elements in `nums`. Since each element's index is added to and removed from the deque at most once, the overall time complexity is **O(N)**, where N is the number of elements in `nums`. The space complexity is **O(k)**, as the deque stores at most `k` indices.\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()\n\n        for i, current_num in enumerate(nums):\n            # Remove index from the left of the deque if it's out of the window.\n            # The window is from [i - k + 1, i]. The element at i-k is the one falling out.\n            if q and q[0] == i - k:\n                q.popleft()\n\n            # Maintain the monotonic decreasing property of the deque.\n            # Remove indices from the right of the deque if their corresponding values\n            # are less than or equal to the current number.\n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n\n            # Append the current element's index to the deque.\n            q.append(i)\n\n            # If the window has at least k elements, the maximum is at the front of the deque.\n            # The first full window is formed at index k-1.\n            if i >= k - 1:\n                output.append(nums[q[0]])\n\n        return output\n```\n\n=== IMPLEMENTATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()\n        \n        for i, current_num in enumerate(nums):\n            # Remove index from the left of the deque if it's out of the window.\n            # The window is from [i - k + 1, i]. The element at i-k is the one falling out.\n            if q and q[0] == i - k:\n                q.popleft()\n\n            # Maintain the monotonic decreasing property of the deque.\n            # Remove indices from the right of the deque if their corresponding values\n            # are less than or equal to the current number.\n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n\n            # Append the current element's index to the deque.\n            q.append(i)\n\n            # If the window has at least k elements, the maximum is at the front of the deque.\n            # The first full window is formed at index k-1.\n            if i >= k - 1:\n                output.append(nums[q[0]])\n                \n        return output\n\n```\n\n=== VERIFICATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()\n        \n        for i, current_num in enumerate(nums):\n            if q and q[0] == i - k:\n                q.popleft()\n            \n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n            \n            q.append(i)\n            \n            if i >= k - 1:\n                output.append(nums[q[0]])\n                \n        return output\n```\n\n",
      "TypedCode": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()\n        \n        for i, current_num in enumerate(nums):\n            # Remove index from the left of the deque if it's out of the window.\n            # The window is from [i - k + 1, i]. The element at i-k is the one falling out.\n            if q and q[0] == i - k:\n                q.popleft()\n\n            # Maintain the monotonic decreasing property of the deque.\n            # Remove indices from the right of the deque if their corresponding values\n            # are less than or equal to the current number.\n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n\n            # Append the current element's index to the deque.\n            q.append(i)\n\n            # If the window has at least k elements, the maximum is at the front of the deque.\n            # The first full window is formed at index k-1.\n            if i >= k - 1:\n                output.append(nums[q[0]])\n                \n        return output\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 291263816750,
      "SolvedAt": "2025-11-21T17:09:48.270548+01:00",
      "PromptTokens": 7588,
      "OutputTokens": 31924
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "239",
        "typed_code": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()\n        \n        for i, current_num in enumerate(nums):\n            # Remove index from the left of the deque if it's out of the window.\n            # The window is from [i - k + 1, i]. The element at i-k is the one falling out.\n            if q and q[0] == i - k:\n                q.popleft()\n\n            # Maintain the monotonic decreasing property of the deque.\n            # Remove indices from the right of the deque if their corresponding values\n            # are less than or equal to the current number.\n            while q and nums[q[-1]] <= current_num:\n                q.pop()\n\n            # Append the current element's index to the deque.\n            q.append(i)\n\n            # If the window has at least k elements, the maximum is at the front of the deque.\n            # The first full window is formed at index k-1.\n            if i >= k - 1:\n                output.append(nums[q[0]])\n                \n        return output\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:07:14+01:00"
    }
  }
}