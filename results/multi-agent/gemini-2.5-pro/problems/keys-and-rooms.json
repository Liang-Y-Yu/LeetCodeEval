{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "841",
        "questionId": "871",
        "Content": "<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>\n\n<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>\n\n<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1],[2],[3],[]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "SampleTestCase": "[[1],[2],[3],[]]",
        "ExampleTestcases": "[[1],[2],[3],[]]\n[[1,3],[3,0,1],[2],[0]]",
        "Difficulty": "Medium",
        "Title": "Keys and Rooms",
        "TitleSlug": "keys-and-rooms",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"636.9K\", \"totalSubmission\": \"846.9K\", \"totalAcceptedRaw\": 636945, \"totalSubmissionRaw\": 846890, \"acRate\": \"75.2%\"}",
        "Likes": 6575,
        "Dislikes": 297,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjIx",
            "Name": "Depth-First Search",
            "Slug": "depth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIy",
            "Name": "Breadth-First Search",
            "Slug": "breadth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI0",
            "Name": "Graph",
            "Slug": "graph"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def canVisitAllRooms(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function(rooms) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function canVisitAllRooms(rooms: number[][]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool CanVisitAllRooms(IList<IList<int>> rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func canVisitAllRooms(rooms [][]int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun canVisitAllRooms(rooms: List<List<Int>>): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func canVisitAllRooms(_ rooms: [[Int]]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn can_visit_all_rooms(rooms: Vec<Vec<i32>>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[][]} rooms\n# @return {Boolean}\ndef can_visit_all_rooms(rooms)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[][] $rooms\n     * @return Boolean\n     */\n    function canVisitAllRooms($rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool canVisitAllRooms(List<List<int>> rooms) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def canVisitAllRooms(rooms: List[List[Int]]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec can_visit_all_rooms(rooms :: [[integer]]) :: boolean\n  def can_visit_all_rooms(rooms) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec can_visit_all_rooms(Rooms :: [[integer()]]) -> boolean().\ncan_visit_all_rooms(Rooms) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (can-visit-all-rooms rooms)\n  (-> (listof (listof exact-integer?)) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:56:10.326741+01:00",
    "AcRate": "75.2",
    "TotalSubmissions": 846890,
    "TotalAccepted": 636945,
    "AcceptanceRate": 0.752098855813624,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/keys-and-rooms/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and effective way to solve this problem is to model it as a graph traversal. The rooms represent the nodes of the graph, and the keys found in a room represent directed edges to other nodes. The problem then becomes: can all nodes in the graph be reached starting from node 0?\n\nThis is a classic reachability problem, which can be solved using either Breadth-First Search (BFS) or Depth-First Search (DFS). Both algorithms will explore all the rooms accessible from the starting room 0.\n\nThe solution below uses a BFS approach:\n1.  Initialize a `visited` set to keep track of the rooms that have been entered. Add room 0 to this set, as it is the starting point.\n2.  Initialize a `queue` for the BFS traversal and add room 0 to it.\n3.  While the `queue` is not empty, dequeue a room to visit.\n4.  For the current room, iterate through all the keys it contains. Each key corresponds to a new room we can now potentially visit.\n5.  If a key unlocks a room that has not been visited yet, mark that new room as visited and add it to the queue to explore later.\n6.  After the traversal is complete, all rooms reachable from room 0 will be in the `visited` set.\n7.  The final step is to check if the number of visited rooms is equal to the total number of rooms (`n`). If they are equal, it means every room was reachable; otherwise, some rooms were inaccessible.\n\nThis approach efficiently explores the graph in O(V + E) time, where V is the number of rooms and E is the total number of keys, which is well within the given constraints.\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \"\"\"\n        Determines if all rooms can be visited starting from room 0.\n\n        This problem is modeled as a graph traversal. Rooms are nodes, and keys are\n        directed edges. We need to check if all nodes are reachable from node 0.\n        A Breadth-First Search (BFS) is used to find all reachable rooms.\n\n        Args:\n            rooms: A list of lists, where rooms[i] contains the keys found in room i.\n\n        Returns:\n            True if all rooms can be visited, False otherwise.\n        \"\"\"\n        n = len(rooms)\n        if n == 0:\n            return True\n\n        # A set to keep track of all visited rooms. Room 0 is initially unlocked.\n        visited = {0}\n\n        # A queue for BFS, starting with room 0.\n        queue = collections.deque([0])\n\n        while queue:\n            # Get the next room to visit from the queue.\n            current_room = queue.popleft()\n\n            # For each key (which represents the next room to visit)\n            # in the current room...\n            for next_room in rooms[current_room]:\n                # If we haven't visited this new room yet...\n                if next_room not in visited:\n                    # Mark it as visited.\n                    visited.add(next_room)\n                    # Add it to the queue to explore its keys later.\n                    queue.append(next_room)\n        \n        # If the number of visited rooms equals the total number of rooms,\n        # it means all rooms were accessible.\n        return len(visited) == n\n\n```\n\n=== DESIGN ===\nHere is the design for the solution:\n\n### 1. Algorithm Choice\nThe problem of determining if all rooms can be visited from a starting room (room 0) is a graph reachability problem. The rooms are the nodes, and the keys are the directed edges. A Depth-First Search (DFS) algorithm is an excellent choice for this, as it systematically explores all reachable nodes from the starting point. An iterative DFS approach using an explicit stack is chosen for its robustness against deep recursion paths and its straightforward implementation.\n\n### 2. Step-by-Step Approach\n1.  Initialize a `visited` set to keep track of the rooms that have been entered. Add the starting room, 0, to this set.\n2.  Initialize a `stack` data structure for the DFS traversal. Push the starting room, 0, onto the stack.\n3.  Begin a loop that continues as long as the `stack` is not empty.\n4.  In each iteration, pop a room from the top of the stack. Let's call this the `current_room`.\n5.  For each `key` found in the `current_room` (i.e., for each neighbor in the graph), check if the room it unlocks has been visited.\n6.  If the room corresponding to the `key` is not in the `visited` set, it's a new room we can access. Mark it by adding it to the `visited` set and push it onto the `stack` to be explored later.\n7.  After the loop terminates, all rooms reachable from room 0 will have been added to the `visited` set.\n8.  The solution is to check if the number of rooms in the `visited` set is equal to the total number of rooms. If they are equal, it means all rooms were accessible, and we return `true`. Otherwise, we return `false`.\n\n### 3. Data Structures\n*   **Set (`visited`)**: To store the indices of the rooms that have been visited. A set provides efficient O(1) average time complexity for insertion and lookup operations.\n*   **List as a Stack (`stack`)**: A list will be used to implement the stack for the iterative DFS traversal. Rooms to be visited are `appended` (pushed) and `popped` from the end.\n\n### 4. Time Complexity\nThe algorithm traverses each room and each key at most once. Let `n` be the number of rooms (vertices) and `m` be the total number of keys (edges). The time complexity will be **O(n + m)**.\n\n### 5. Space Complexity\n*   The `visited` set can store up to `n` elements in the worst case.\n*   The `stack` can also store up to `n` elements in the worst case (for a graph that is a single path).\n*   Therefore, the total space complexity will be **O(n)**.\n\n### 6. Pseudocode\n```pseudocode\nfunction canVisitAllRooms(rooms):\n    n = length of rooms\n    visited = new Set()\n    add 0 to visited\n\n    stack = new Stack()\n    push 0 onto stack\n\n    while stack is not empty:\n        current_room = pop from stack\n\n        for each key in rooms[current_room]:\n            if key is not in visited:\n                add key to visited\n                push key onto stack\n    \n    return size of visited == n\n```\n\nHere is the Python implementation based on the design:\n```python\nimport collections\nfrom typing import List\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = {0}\n        stack = [0]\n\n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if key not in visited:\n                    visited.add(key)\n                    stack.append(key)\n        \n        return len(visited) == len(rooms)\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = {0}\n        stack = [0]\n        \n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if key not in visited:\n                    visited.add(key)\n                    stack.append(key)\n        \n        return len(visited) == len(rooms)\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = {0}\n        stack = [0]\n        \n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if key not in visited:\n                    visited.add(key)\n                    stack.append(key)\n        \n        return len(visited) == len(rooms)\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = {0}\n        stack = [0]\n        \n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if key not in visited:\n                    visited.add(key)\n                    stack.append(key)\n        \n        return len(visited) == len(rooms)\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 180459157873,
      "SolvedAt": "2025-11-21T12:19:40.730797+01:00",
      "PromptTokens": 7127,
      "OutputTokens": 21971
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "871",
        "typed_code": "\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = {0}\n        stack = [0]\n        \n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if key not in visited:\n                    visited.add(key)\n                    stack.append(key)\n        \n        return len(visited) == len(rooms)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:31:16+01:00"
    }
  }
}