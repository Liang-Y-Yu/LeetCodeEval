{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1696",
        "questionId": "1814",
        "Content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>You are initially standing at index <code>0</code>. In one move, you can jump at most <code>k</code> steps forward without going outside the boundaries of the array. That is, you can jump from index <code>i</code> to any index in the range <code>[i + 1, min(n - 1, i + k)]</code> <strong>inclusive</strong>.</p>\n\n<p>You want to reach the last index of the array (index <code>n - 1</code>). Your <strong>score</strong> is the <strong>sum</strong> of all <code>nums[j]</code> for each index <code>j</code> you visited in the array.</p>\n\n<p>Return <em>the <strong>maximum score</strong> you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [<u>1</u>,<u>-1</u>,-2,<u>4</u>,-7,<u>3</u>], k = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [<u>10</u>,-5,-2,<u>4</u>,0,<u>3</u>], k = 3\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[1,-1,-2,4,-7,3]\n2",
        "ExampleTestcases": "[1,-1,-2,4,-7,3]\n2\n[10,-5,-2,4,0,3]\n3\n[1,-5,-20,4,-1,3,-6,-3]\n2",
        "Difficulty": "Medium",
        "Title": "Jump Game VI",
        "TitleSlug": "jump-game-vi",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"123.8K\", \"totalSubmission\": \"267.8K\", \"totalAcceptedRaw\": 123813, \"totalSubmissionRaw\": 267849, \"acRate\": \"46.2%\"}",
        "Likes": 3534,
        "Dislikes": 124,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjM0",
            "Name": "Queue",
            "Slug": "queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcx",
            "Name": "Monotonic Queue",
            "Slug": "monotonic-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int maxResult(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int maxResult(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxResult(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxResult = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxResult(nums: number[], k: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int MaxResult(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int maxResult(int* nums, int numsSize, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxResult(nums []int, k int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxResult(nums: IntArray, k: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxResult(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef max_result(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxResult($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int maxResult(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxResult(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_result(nums :: [integer], k :: integer) :: integer\n  def max_result(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_result(Nums :: [integer()], K :: integer()) -> integer().\nmax_result(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-result nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:08:37.712228+01:00",
    "AcRate": "46.2",
    "TotalSubmissions": 267849,
    "TotalAccepted": 123813,
    "AcceptanceRate": 0.46224925237727227,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/jump-game-vi/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution to this problem uses dynamic programming combined with a monotonic deque to optimize the calculation.\n\nThe problem can be modeled with a dynamic programming approach. Let `dp[i]` be the maximum score to reach index `i`. To compute `dp[i]`, we must have jumped from some previous index `j`, where `i - k <= j < i`. The score `dp[i]` would then be `nums[i]` plus the maximum score among all possible prior positions `j`. This gives the recurrence relation:\n\n`dp[i] = nums[i] + max(dp[j])` for `i - k <= j < i`.\n\nA naive implementation of this would take O(k) time to find the maximum for each `i`, leading to an overall time complexity of O(n*k), which is too slow given the constraints.\n\nThe key observation is that finding `max(dp[j])` over a sliding window `[i - k, i - 1]` is a classic \"Sliding Window Maximum\" problem. This can be solved efficiently in amortized O(1) time per step using a monotonic deque.\n\nThe deque will store pairs of `(score, index)`. We maintain the deque such that the scores are in strictly decreasing order. This ensures that the front of the deque always contains the pair with the maximum score within the current window.\n\nThe algorithm proceeds as follows:\n1. Initialize a deque and add the starting information, `(nums[0], 0)`, representing the score and index at the start.\n2. Iterate from `i = 1` to `n - 1`:\n   a. **Prune the deque**: Remove elements from the front of the deque whose indices are no longer in the valid window `[i - k, i - 1]`.\n   b. **Calculate current score**: The maximum score in the window is at the front of the deque (`dq[0][0]`). The score to reach index `i` is `nums[i] + dq[0][0]`.\n   c. **Maintain monotonicity**: To keep the deque's scores decreasing, remove all elements from the back of the deque that have a score less than or equal to the current score. A new index `i` with a higher or equal score makes the older, smaller-scoring indices obsolete for future calculations.\n   d. **Add to deque**: Add the new pair `(current_score, i)` to the back of the deque.\n3. After iterating through all indices, the final score for reaching index `n - 1` will be the last score calculated. This happens to be the score of the element at the back of the deque.\n\nThis approach has a time complexity of O(n) because each index is added to and removed from the deque at most once. The space complexity is O(k) for the deque.\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        # The deque stores tuples of (score, index).\n        # It is maintained to be monotonically decreasing based on the score.\n        dq = collections.deque([(nums[0], 0)])\n        \n        for i in range(1, n):\n            # Remove indices from the front that are outside the current window of size k.\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n            \n            # The maximum score from a reachable previous index is at the front of the deque.\n            current_score = nums[i] + dq[0][0]\n            \n            # Maintain the monotonic (decreasing) property of the deque.\n            # Remove from the back any elements with scores less than or equal to the current score.\n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n            \n            dq.append((current_score, i))\n            \n        # The last element added to the deque corresponds to the last index n-1.\n        # Its score is the maximum score to reach the end.\n        return dq[-1][0]\n\n```\n\n=== DESIGN ===\nAn elegant and efficient solution to this problem uses dynamic programming combined with a monotonic deque to optimize the calculation.\n\nThe problem can be modeled with a dynamic programming approach. Let `dp[i]` be the maximum score to reach index `i`. To compute `dp[i]`, we must have jumped from some previous index `j`, where `i - k <= j < i`. The score `dp[i]` would then be `nums[i]` plus the maximum score among all possible prior positions `j`. This gives the recurrence relation:\n`dp[i] = nums[i] + max(dp[j])` for `i - k <= j < i`.\n\nA naive implementation of this would take O(k) time to find the maximum for each `i`, leading to an overall time complexity of O(n*k), which is too slow given the constraints.\n\nThe key observation is that finding `max(dp[j])` over a sliding window `[i - k, i - 1]` is a classic \"Sliding Window Maximum\" problem. This can be solved efficiently in amortized O(1) time per step using a monotonic deque.\n\nThe deque will store pairs of `(score, index)`. We maintain the deque such that the scores are in strictly decreasing order. This ensures that the front of the deque always contains the pair with the maximum score within the current window.\n\nThe algorithm proceeds as follows:\n1. Initialize a deque and add the starting information, `(nums[0], 0)`, representing the score and index at the start.\n2. Iterate from `i = 1` to `n - 1`:\n   a. **Prune the deque**: Remove elements from the front of the deque whose indices are no longer in the valid window `[i - k, i - 1]`.\n   b. **Calculate current score**: The maximum score in the window is at the front of the deque (`dq[0][0]`). The score to reach index `i` is `nums[i] + dq[0][0]`.\n   c. **Maintain monotonicity**: To keep the deque's scores decreasing, remove all elements from the back of the deque that have a score less than or equal to the current score. A new index `i` with a higher or equal score makes the older, smaller-scoring indices obsolete for future calculations.\n   d. **Add to deque**: Add the new pair `(current_score, i)` to the back of the deque.\n3. After iterating through all indices, the final score for reaching index `n - 1` will be the last score calculated, which corresponds to the element at the back of the deque.\n\nThis approach has a time complexity of O(n) because each index is added to and removed from the deque at most once. The space complexity is O(k) for the deque, as it stores at most `k` elements corresponding to the window size.\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dq = collections.deque([(nums[0], 0)])\n\n        for i in range(1, n):\n            # Prune the deque by removing elements from the front that are out of the window [i-k, i-1]\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n\n            # Calculate the score to reach index i. The max score from the previous\n            # reachable indices is at the front of the monotonic deque.\n            current_score = nums[i] + dq[0][0]\n\n            # Maintain the monotonically decreasing property of the deque by score.\n            # Remove elements from the back that have scores less than or equal to the current one.\n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n\n            # Add the new score and index to the deque.\n            dq.append((current_score, i))\n            \n        # The last element added to the deque corresponds to the maximum score at index n-1.\n        return dq[-1][0]\n\n```\n\n=== IMPLEMENTATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dq = collections.deque([(nums[0], 0)])\n\n        for i in range(1, n):\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n            \n            current_score = nums[i] + dq[0][0]\n            \n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n            \n            dq.append((current_score, i))\n            \n        return dq[-1][0]\n```\n\n=== VERIFICATION ===\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dq = collections.deque([(nums[0], 0)])\n\n        for i in range(1, n):\n            # Prune the deque by removing elements from the front that are out of the window [i-k, i-1].\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n\n            # Calculate the score to reach index i. The max score from the previous\n            # reachable indices is at the front of the monotonic deque.\n            current_score = nums[i] + dq[0][0]\n\n            # Maintain the monotonically decreasing property of the deque by score.\n            # Remove elements from the back that have scores less than or equal to the current one.\n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n\n            # Add the new score and index to the deque.\n            dq.append((current_score, i))\n\n        # The last element added to the deque corresponds to the maximum score at index n-1.\n        return dq[-1][0]\n```\n\n",
      "TypedCode": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dq = collections.deque([(nums[0], 0)])\n\n        for i in range(1, n):\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n            \n            current_score = nums[i] + dq[0][0]\n            \n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n            \n            dq.append((current_score, i))\n            \n        return dq[-1][0]\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 363723349501,
      "SolvedAt": "2025-11-21T12:12:42.899999+01:00",
      "PromptTokens": 7630,
      "OutputTokens": 46867
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1814",
        "typed_code": "\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dq = collections.deque([(nums[0], 0)])\n\n        for i in range(1, n):\n            while dq and dq[0][1] < i - k:\n                dq.popleft()\n            \n            current_score = nums[i] + dq[0][0]\n            \n            while dq and dq[-1][0] <= current_score:\n                dq.pop()\n            \n            dq.append((current_score, i))\n            \n        return dq[-1][0]\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:25:39+01:00"
    }
  }
}