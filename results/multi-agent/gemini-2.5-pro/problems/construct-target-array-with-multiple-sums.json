{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1354",
        "questionId": "1479",
        "Content": "<p>You are given an array <code>target</code> of n integers. From a starting array <code>arr</code> consisting of <code>n</code> 1&#39;s, you may perform the following procedure :</p>\n\n<ul>\n\t<li>let <code>x</code> be the sum of all elements currently in your array.</li>\n\t<li>choose index <code>i</code>, such that <code>0 &lt;= i &lt; n</code> and set the value of <code>arr</code> at index <code>i</code> to <code>x</code>.</li>\n\t<li>You may repeat this procedure as many times as needed.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to construct the</em> <code>target</code> <em>array from</em> <code>arr</code><em>, otherwise, return</em> <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [9,3,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,1,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Impossible to create target array from [1,1,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [8,5]\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[9,3,5]",
        "ExampleTestcases": "[9,3,5]\n[1,1,1,2]\n[8,5]",
        "Difficulty": "Hard",
        "Title": "Construct Target Array With Multiple Sums",
        "TitleSlug": "construct-target-array-with-multiple-sums",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"71.5K\", \"totalSubmission\": \"196.7K\", \"totalAcceptedRaw\": 71522, \"totalSubmissionRaw\": 196703, \"acRate\": \"36.4%\"}",
        "Likes": 2078,
        "Dislikes": 171,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool isPossible(vector<int>& target) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean isPossible(int[] target) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def isPossible(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} target\n * @return {boolean}\n */\nvar isPossible = function(target) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function isPossible(target: number[]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool IsPossible(int[] target) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool isPossible(int* target, int targetSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func isPossible(target []int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun isPossible(target: IntArray): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func isPossible(_ target: [Int]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn is_possible(target: Vec<i32>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} target\n# @return {Boolean}\ndef is_possible(target)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $target\n     * @return Boolean\n     */\n    function isPossible($target) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool isPossible(List<int> target) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def isPossible(target: Array[Int]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec is_possible(target :: [integer]) :: boolean\n  def is_possible(target) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec is_possible(Target :: [integer()]) -> boolean().\nis_possible(Target) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (is-possible target)\n  (-> (listof exact-integer?) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:25:47.226174+01:00",
    "AcRate": "36.4",
    "TotalSubmissions": 196703,
    "TotalAccepted": 71522,
    "AcceptanceRate": 0.36360401214013005,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/construct-target-array-with-multiple-sums/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution can be designed by working backward from the `target` array to the initial array of ones.\n\nThe forward process involves a choice at each step (which element to update), leading to a prohibitively large search space. However, the reverse process is deterministic. If the current array was formed by updating an element `arr[i]` to the sum of the previous array, then `arr[i]` must be the largest element in the current array. This is because all elements are positive, so the sum of an array is always greater than any of its individual elements.\n\nThis insight allows for a greedy, backward-working algorithm:\n1.  Start with the `target` array.\n2.  In each step, identify the largest element, `max_val`.\n3.  Calculate the sum of the other elements, `rest_sum`.\n4.  The value that `max_val` replaced must have been `prev_val = max_val - rest_sum`.\n5.  Replace `max_val` with `prev_val` in the array and repeat the process.\n\nThe goal is to reach the starting array `[1, 1, ..., 1]`. If at any point we derive a non-positive number or get into an invalid state, the `target` is not constructible.\n\nTo make this efficient, two optimizations are key:\n*   **Max-Heap**: Finding the largest element repeatedly is slow with linear scans (`O(n)`). A max-heap (priority queue) can retrieve the maximum element in `O(log n)` time.\n*   **Modular Arithmetic**: If `max_val` is much larger than `rest_sum`, we would subtract `rest_sum` many times. This sequence of operations `max_val, max_val - rest_sum, max_val - 2*rest_sum, ...` can be sped up by using the modulo operator. The new value will be `max_val % rest_sum`.\n\nThe algorithm is as follows:\n1.  Handle edge cases: if `n=1`, the target must be `[1]`.\n2.  Use a max-heap to store the numbers from `target` and keep track of their sum.\n3.  Repeatedly:\n    a. Extract the largest element, `max_val`, from the heap.\n    b. If `max_val` is 1, all elements must be 1, so we have successfully reached the start state.\n    c. Calculate `rest_sum = total_sum - max_val`.\n    d. Check for impossible conditions:\n        - If `rest_sum` is 1, we can always reduce `max_val` to 1, so it's possible.\n        - If `rest_sum` is 0 (for n>1) or `max_val <= rest_sum`, the previous value would be non-positive, which is impossible.\n        - The new value is `prev_val = max_val % rest_sum`. If `prev_val` becomes 0 (and `rest_sum != 1`), this path is impossible because it implies `max_val` is a multiple of `rest_sum`, which eventually leads to a state where the max element equals the rest sum.\n    e. Update the sum and push `prev_val` back into the heap.\n4. If the loop completes, it means we have reached `[1, 1, ..., 1]`, so return `true`.\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        # Python's heapq is a min-heap, so we use negative values for a max-heap\n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            # If rest_sum is 1, we can always reduce the largest element to 1\n            if rest_sum == 1:\n                return True\n            \n            # If rest_sum is 0 (for n>1) or largest <= rest_sum,\n            # the previous value would be non-positive.\n            if rest_sum == 0 or largest <= rest_sum:\n                return False\n                \n            prev_val = largest % rest_sum\n            \n            # If prev_val is 0, it means largest is a multiple of rest_sum.\n            # This is only recoverable if rest_sum was 1 (handled above).\n            if prev_val == 0:\n                return False\n                \n            total_sum = rest_sum + prev_val\n            heapq.heappush(pq, -prev_val)\n            \n        return True\n\n```\n\n=== DESIGN ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        # Python's heapq is a min-heap, so we use negative values for a max-heap\n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        # Loop backwards from target. The loop continues as long as the largest\n        # element is not 1. If the largest is 1, all elements must be 1.\n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            # If rest_sum is 1, it means all other elements are 1's.\n            # We can always reduce the 'largest' element to 1 by repeatedly\n            # subtracting 1 (which is the rest_sum). So, it's possible.\n            if rest_sum == 1:\n                return True\n            \n            # The previous value that was replaced must be `largest - rest_sum`.\n            # This previous value must have been at least 1.\n            # So, `largest - rest_sum >= 1`, which means `largest > rest_sum`.\n            # If `largest <= rest_sum`, the state is impossible.\n            # Also, if `rest_sum` is 0 (for n > 1), it's impossible to form\n            # a positive number `largest`.\n            if largest <= rest_sum or rest_sum == 0:\n                return False\n                \n            # The new value is `prev_val = largest % rest_sum`.\n            # This is an optimization for `prev_val = largest - k * rest_sum`.\n            prev_val = largest % rest_sum\n            \n            # If `prev_val` is 0, it means `largest` is a multiple of `rest_sum`.\n            # This would imply that at some point, the largest element was `rest_sum`,\n            # leading to the impossible state `largest == rest_sum` (unless rest_sum was 1).\n            if prev_val == 0:\n                return False\n                \n            # Update the total sum for the new virtual array state\n            total_sum = rest_sum + prev_val\n            # Push the previous value back into the heap\n            heapq.heappush(pq, -prev_val)\n            \n        # If the loop completes, all elements have been reduced to 1.\n        return True\n```\n\n=== IMPLEMENTATION ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            if rest_sum == 1:\n                return True\n            \n            if largest <= rest_sum or rest_sum == 0:\n                return False\n                \n            prev_val = largest % rest_sum\n            \n            if prev_val == 0:\n                return False\n                \n            total_sum = rest_sum + prev_val\n            heapq.heappush(pq, -prev_val)\n            \n        return True\n```\n\n=== VERIFICATION ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        # Python's heapq is a min-heap, so we store negative values to simulate a max-heap.\n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        # We work backwards from the target. The loop continues as long as the largest\n        # element is not 1. If the largest element is 1, all elements must be 1.\n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            # If rest_sum is 1, it means all other elements have been reduced to 1.\n            # We can always reduce the 'largest' element down to 1 by repeatedly\n            # subtracting 1 (which is the rest_sum). Thus, the target is constructible.\n            if rest_sum == 1:\n                return True\n            \n            # The value that was replaced to create 'largest' must be `largest - rest_sum`.\n            # Since all elements must be at least 1, `largest - rest_sum >= 1`, which\n            # implies `largest > rest_sum`.\n            # If `largest <= rest_sum`, the state is impossible.\n            # Also, `rest_sum` cannot be 0 if n > 1, because all target[i] >= 1.\n            # This check handles cases like [1, 1, 2] -> largest=2, rest=2 -> impossible.\n            if largest <= rest_sum or rest_sum == 0:\n                return False\n                \n            # The new value is `prev_val = largest % rest_sum`.\n            # This is an optimization for repeatedly subtracting `rest_sum`.\n            prev_val = largest % rest_sum\n            \n            # If prev_val becomes 0, it means `largest` is a multiple of `rest_sum`.\n            # This is only possible if `rest_sum` was 1 (which is handled above).\n            # Otherwise, it implies that at some earlier state, the largest element was\n            # equal to the sum of the rest, which is an impossible state.\n            if prev_val == 0:\n                return False\n                \n            # Update the total sum for the new virtual array state and\n            # push the previous value back into the heap.\n            total_sum = rest_sum + prev_val\n            heapq.heappush(pq, -prev_val)\n            \n        # If the loop completes, it means all elements have been successfully reduced to 1.\n        return True\n```\n\n",
      "TypedCode": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            if rest_sum == 1:\n                return True\n            \n            if largest <= rest_sum or rest_sum == 0:\n                return False\n                \n            prev_val = largest % rest_sum\n            \n            if prev_val == 0:\n                return False\n                \n            total_sum = rest_sum + prev_val\n            heapq.heappush(pq, -prev_val)\n            \n        return True\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 390216358332,
      "SolvedAt": "2025-11-21T09:51:32.472388+01:00",
      "PromptTokens": 7582,
      "OutputTokens": 46368
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1479",
        "typed_code": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        n = len(target)\n        if n == 1:\n            return target[0] == 1\n        \n        total_sum = sum(target)\n        \n        pq = [-val for val in target]\n        heapq.heapify(pq)\n        \n        while pq[0] != -1:\n            largest = -heapq.heappop(pq)\n            rest_sum = total_sum - largest\n            \n            if rest_sum == 1:\n                return True\n            \n            if largest <= rest_sum or rest_sum == 0:\n                return False\n                \n            prev_val = largest % rest_sum\n            \n            if prev_val == 0:\n                return False\n                \n            total_sum = rest_sum + prev_val\n            heapq.heappush(pq, -prev_val)\n            \n        return True\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:39:49+01:00"
    }
  }
}