{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "857",
        "questionId": "887",
        "Content": "<p>There are <code>n</code> workers. You are given two integer arrays <code>quality</code> and <code>wage</code> where <code>quality[i]</code> is the quality of the <code>i<sup>th</sup></code> worker and <code>wage[i]</code> is the minimum wage expectation for the <code>i<sup>th</sup></code> worker.</p>\n\n<p>We want to hire exactly <code>k</code> workers to form a <strong>paid group</strong>. To hire a group of <code>k</code> workers, we must pay them according to the following rules:</p>\n\n<ol>\n\t<li>Every worker in the paid group must be paid at least their minimum wage expectation.</li>\n\t<li>In the group, each worker&#39;s pay must be directly proportional to their quality. This means if a worker&rsquo;s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.</li>\n</ol>\n\n<p>Given the integer <code>k</code>, return <em>the least amount of money needed to form a paid group satisfying the above conditions</em>. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> quality = [10,20,5], wage = [70,50,30], k = 2\n<strong>Output:</strong> 105.00000\n<strong>Explanation:</strong> We pay 70 to 0<sup>th</sup> worker and 35 to 2<sup>nd</sup> worker.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n<strong>Output:</strong> 30.66667\n<strong>Explanation:</strong> We pay 4 to 0<sup>th</sup> worker, 13.33333 to 2<sup>nd</sup> and 3<sup>rd</sup> workers separately.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == quality.length == wage.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[10,20,5]\n[70,50,30]\n2",
        "ExampleTestcases": "[10,20,5]\n[70,50,30]\n2\n[3,1,10,10,1]\n[4,8,2,2,7]\n3",
        "Difficulty": "Hard",
        "Title": "Minimum Cost to Hire K Workers",
        "TitleSlug": "minimum-cost-to-hire-k-workers",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"155.1K\", \"totalSubmission\": \"244K\", \"totalAcceptedRaw\": 155088, \"totalSubmissionRaw\": 243955, \"acRate\": \"63.6%\"}",
        "Likes": 3030,
        "Dislikes": 405,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, k):\n        \"\"\"\n        :type quality: List[int]\n        :type wage: List[int]\n        :type k: int\n        :rtype: float\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} k\n * @return {number}\n */\nvar mincostToHireWorkers = function(quality, wage, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function mincostToHireWorkers(quality: number[], wage: number[], k: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public double MincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func mincostToHireWorkers(quality []int, wage []int, k int) float64 {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun mincostToHireWorkers(quality: IntArray, wage: IntArray, k: Int): Double {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func mincostToHireWorkers(_ quality: [Int], _ wage: [Int], _ k: Int) -> Double {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} quality\n# @param {Integer[]} wage\n# @param {Integer} k\n# @return {Float}\ndef mincost_to_hire_workers(quality, wage, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $quality\n     * @param Integer[] $wage\n     * @param Integer $k\n     * @return Float\n     */\n    function mincostToHireWorkers($quality, $wage, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  double mincostToHireWorkers(List<int> quality, List<int> wage, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def mincostToHireWorkers(quality: Array[Int], wage: Array[Int], k: Int): Double = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec mincost_to_hire_workers(quality :: [integer], wage :: [integer], k :: integer) :: float\n  def mincost_to_hire_workers(quality, wage, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec mincost_to_hire_workers(Quality :: [integer()], Wage :: [integer()], K :: integer()) -> float().\nmincost_to_hire_workers(Quality, Wage, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (mincost-to-hire-workers quality wage k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? flonum?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:54:44.803768+01:00",
    "AcRate": "63.6",
    "TotalSubmissions": 243955,
    "TotalAccepted": 155088,
    "AcceptanceRate": 0.6357238015207722,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution can be designed by focusing on the core payment rules.\n\nLet's analyze the rules. For a group of `k` workers, every worker `i` in the group must be paid `pay[i]`.\n1.  `pay[i] >= wage[i]`\n2.  `pay[i] / quality[i] = R` (a constant ratio `R` for the entire group)\n\nFrom rule 2, we can say `pay[i] = R * quality[i]`.\nSubstituting this into rule 1 gives: `R * quality[i] >= wage[i]`, which rearranges to `R >= wage[i] / quality[i]`.\n\nThis inequality must hold for all workers in the group. Therefore, the group's ratio `R` must be at least the maximum of the individual `wage/quality` ratios of its members. To minimize cost, we should choose the smallest possible `R`, which is `R = max(wage[i] / quality[i])` for all workers `i` in the group.\n\nThe total cost for the group is `sum(pay[i]) = sum(R * quality[i]) = R * sum(quality[i])`.\n\nThis leads to the core strategy:\n1.  For any potential group, the cost is determined by the worker with the highest `wage/quality` ratio (the \"captain\") and the sum of qualities of all `k` members.\n2.  We can iterate through each worker, treating them as the \"captain\" for a potential group. Let's say we pick worker `j` as the captain. The group's ratio will be `R_j = wage[j] / quality[j]`.\n3.  Any other worker `i` can join this group only if their own ratio is less than or equal to `R_j`, i.e., `wage[i] / quality[i] <= R_j`.\n4.  To make the group cost `R_j * sum(qualities)` as small as possible, we need to pick `k` workers from the eligible pool (all workers with ratio `<= R_j`) that have the smallest possible sum of qualities.\n\nThis can be implemented efficiently:\n1.  Calculate the `wage/quality` ratio for each worker.\n2.  Sort the workers based on this ratio in ascending order.\n3.  Iterate through the sorted workers. For each worker `i`, we consider them the \"captain\". The pool of eligible candidates for their group are all workers from `0` to `i` in the sorted list.\n4.  From this pool, we need to find the `k` workers with the smallest qualities. A max-heap of size `k` is the perfect data structure for this.\n5.  As we iterate, we add the current worker's quality to a running sum and to the max-heap. If the heap size exceeds `k`, we remove the largest quality (the top of the max-heap) and subtract it from our sum.\n6.  Whenever the heap contains exactly `k` qualities, we have a valid group. The cost is `current_worker_ratio * quality_sum`. We keep track of the minimum cost found across all such valid groups.\n\nThis approach has a time complexity of `O(N log N)` due to sorting and `O(N log K)` for heap operations, leading to a total of `O(N log N)`. The space complexity is `O(N)` to store the worker data and `O(K)` for the heap.\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        max_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(max_heap, -q)\n            \n            if len(max_heap) > k:\n                quality_sum += heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n```\n\n=== DESIGN ===\nAn elegant and efficient solution can be designed by focusing on the core payment rules.\n\nLet's analyze the rules. For a group of `k` workers, every worker `i` in the group must be paid `pay[i]`.\n\n1.  `pay[i] >= wage[i]`\n2.  `pay[i] / quality[i] = R` (a constant ratio `R` for the entire group)\n\nFrom rule 2, we can say `pay[i] = R * quality[i]`.\nSubstituting this into rule 1 gives: `R * quality[i] >= wage[i]`, which rearranges to `R >= wage[i] / quality[i]`.\n\nThis inequality must hold for all workers in the group. Therefore, the group's ratio `R` must be at least the maximum of the individual `wage/quality` ratios of its members. To minimize cost, we should choose the smallest possible `R`, which is `R = max(wage[i] / quality[i])` for all workers `i` in the group.\n\nThe total cost for the group is `sum(pay[i]) = sum(R * quality[i]) = R * sum(quality[i])`.\nThis leads to the core strategy: iterate through each worker, consider them as the one setting the ratio `R` (the \"captain\"), and for that `R`, find the `k` eligible workers with the minimum sum of qualities.\n\n### 1. Algorithm Choice\nA greedy approach combined with a priority queue is ideal. We sort all workers by their `wage/quality` ratio and iterate through them. A max-heap is used to efficiently maintain the set of `k` workers with the smallest qualities among those considered so far.\n\n### 2. Step-by-Step Approach\n1.  For each worker, calculate their `wage/quality` ratio. Store this ratio along with their `quality` in a list of worker profiles.\n2.  Sort this list of workers in ascending order based on their `wage/quality` ratio.\n3.  Initialize a variable `min_cost` to infinity, `quality_sum` to zero, and an empty max-heap `qualities_heap` to store qualities.\n4.  Iterate through the sorted workers, processing one worker `(ratio, quality)` at a time.\n5.  In each iteration, add the current worker's `quality` to `quality_sum` and push it onto the `qualities_heap`.\n6.  If the number of workers in the `qualities_heap` exceeds `k`, remove the worker with the largest quality. This is done by popping from the max-heap. The popped quality should also be subtracted from `quality_sum`.\n7.  If the number of workers in the `qualities_heap` is exactly `k`, it signifies a valid group. Calculate the total cost for this group as `current_cost = ratio * quality_sum`. The `ratio` is from the current worker, who has the highest ratio in the current pool.\n8.  Update `min_cost` with the minimum value between the existing `min_cost` and the `current_cost`.\n9.  After iterating through all workers, `min_cost` will hold the minimum cost to form a valid group of `k` workers.\n\n### 3. Data Structures\n*   **List of Tuples/Objects**: To store worker information `(wage/quality_ratio, quality)`. An `O(N)` space is required.\n*   **Max-Heap (Priority Queue)**: To maintain the `k` smallest qualities of the workers considered so far. Its size will be at most `k`. In Python, this can be implemented with the `heapq` module (a min-heap) by storing the negative of the qualities. `O(K)` space is required.\n\n### 4. Time Complexity\n*   **Worker Profile Creation**: `O(N)`\n*   **Sorting**: Sorting `N` workers by their ratio takes `O(N log N)`.\n*   **Iteration and Heap Operations**: We iterate through `N` workers. For each worker, we perform one heap push (`O(log K)`) and at most one heap pop (`O(log K)`). This part takes `O(N log K)`.\n*   **Total Time Complexity**: `O(N log N + N log K)`. Since `K <= N`, this simplifies to `O(N log N)`.\n\n### 5. Space Complexity\n*   **Worker List**: `O(N)` to store the ratios and qualities.\n*   **Heap**: `O(K)` to store the `k` smallest qualities.\n*   **Total Space Complexity**: `O(N + K)`, which simplifies to `O(N)` as `K <= N`.\n\n### 6. Pseudocode\n```\nfunction mincostToHireWorkers(quality, wage, k):\n  n = length of quality\n  workers = an empty list\n\n  for i from 0 to n-1:\n    ratio = wage[i] / quality[i]\n    q = quality[i]\n    add (ratio, q) to workers\n\n  sort workers based on ratio in ascending order\n\n  min_cost = infinity\n  quality_sum = 0\n  qualities_heap = new max-heap\n\n  for each (ratio, q) in workers:\n    quality_sum = quality_sum + q\n    push q onto qualities_heap\n\n    if size of qualities_heap > k:\n      largest_q = pop from qualities_heap\n      quality_sum = quality_sum - largest_q\n\n    if size of qualities_heap == k:\n      current_cost = ratio * quality_sum\n      min_cost = min(min_cost, current_cost)\n\n  return min_cost\n```\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        qualities_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(qualities_heap, -q)\n            \n            if len(qualities_heap) > k:\n                # Adding a negative number is equivalent to subtracting the positive one.\n                quality_sum += heapq.heappop(qualities_heap)\n            \n            if len(qualities_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n```\n\n=== IMPLEMENTATION ===\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        qualities_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(qualities_heap, -q)\n            \n            if len(qualities_heap) > k:\n                quality_sum += heapq.heappop(qualities_heap)\n            \n            if len(qualities_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n```\n\n=== VERIFICATION ===\nAn elegant and efficient solution can be designed by focusing on the core payment rules.\nLet's analyze the rules. For a group of `k` workers, every worker `i` in the group must be paid `pay[i]`.\n1.  `pay[i] >= wage[i]`\n2.  `pay[i] / quality[i] = R` (a constant ratio `R` for the entire group)\nFrom rule 2, we can say `pay[i] = R * quality[i]`.\nSubstituting this into rule 1 gives: `R * quality[i] >= wage[i]`, which rearranges to `R >= wage[i] / quality[i]`.\nThis inequality must hold for all workers in the group. Therefore, the group's ratio `R` must be at least the maximum of the individual `wage/quality` ratios of its members. To minimize cost, we should choose the smallest possible `R`, which is `R = max(wage[i] / quality[i])` for all workers `i` in the group.\nThe total cost for the group is `sum(pay[i]) = sum(R * quality[i]) = R * sum(quality[i])`.\nThis leads to the core strategy: iterate through each worker, consider them as the one setting the ratio `R` (the \"captain\"), and for that `R`, find the `k` eligible workers with the minimum sum of qualities.\n### 1. Algorithm Choice\nA greedy approach combined with a priority queue is ideal. We sort all workers by their `wage/quality` ratio and iterate through them. A max-heap is used to efficiently maintain the set of `k` workers with the smallest qualities among those considered so far.\n### 2. Step-by-Step Approach\n1.  For each worker, calculate their `wage/quality` ratio. Store this ratio along with their `quality` in a list of worker profiles.\n2.  Sort this list of workers in ascending order based on their `wage/quality` ratio.\n3.  Initialize a variable `min_cost` to infinity, `quality_sum` to zero, and an empty max-heap `qualities_heap` to store qualities.\n4.  Iterate through the sorted workers, processing one worker `(ratio, quality)` at a time.\n5.  In each iteration, add the current worker's `quality` to `quality_sum` and push it onto the `qualities_heap`.\n6.  If the number of workers in the `qualities_heap` exceeds `k`, remove the worker with the largest quality. This is done by popping from the max-heap. The popped quality should also be subtracted from `quality_sum`.\n7.  If the number of workers in the `qualities_heap` is exactly `k`, it signifies a valid group. Calculate the total cost for this group as `current_cost = ratio * quality_sum`. The `ratio` is from the current worker, who has the highest ratio in the current pool.\n8.  Update `min_cost` with the minimum value between the existing `min_cost` and the `current_cost`.\n9.  After iterating through all workers, `min_cost` will hold the minimum cost to form a valid group of `k` workers.\n### 3. Data Structures\n*   **List of Tuples/Objects**: To store worker information `(wage/quality_ratio, quality)`. An `O(N)` space is required.\n*   **Max-Heap (Priority Queue)**: To maintain the `k` smallest qualities of the workers considered so far. Its size will be at most `k`. In Python, this can be implemented with the `heapq` module (a min-heap) by storing the negative of the qualities. `O(K)` space is required.\n### 4. Time Complexity\n*   **Worker Profile Creation**: `O(N)`\n*   **Sorting**: Sorting `N` workers by their ratio takes `O(N log N)`.\n*   **Iteration and Heap Operations**: We iterate through `N` workers. For each worker, we perform one heap push (`O(log K)`) and at most one heap pop (`O(log K)`). This part takes `O(N log K)`.\n*   **Total Time Complexity**: `O(N log N + N log K)`. Since `K <= N`, this simplifies to `O(N log N)`.\n### 5. Space Complexity\n*   **Worker List**: `O(N)` to store the ratios and qualities.\n*   **Heap**: `O(K)` to store the `k` smallest qualities.\n*   **Total Space Complexity**: `O(N + K)`, which simplifies to `O(N)` as `K <= N`.\n### 6. Pseudocode\n```\nfunction mincostToHireWorkers(quality, wage, k):\n  n = length of quality\n  workers = an empty list\n  for i from 0 to n-1:\n    ratio = wage[i] / quality[i]\n    q = quality[i]\n    add (ratio, q) to workers\n  sort workers based on ratio in ascending order\n  min_cost = infinity\n  quality_sum = 0\n  qualities_heap = new max-heap\n  for each (ratio, q) in workers:\n    quality_sum = quality_sum + q\n    push q onto qualities_heap\n    if size of qualities_heap > k:\n      largest_q = pop from qualities_heap\n      quality_sum = quality_sum - largest_q\n    if size of qualities_heap == k:\n      current_cost = ratio * quality_sum\n      min_cost = min(min_cost, current_cost)\n  return min_cost\n```\n### Verification Report\n\n1.  **Correctness**: The provided code correctly implements the greedy algorithm. The logic of sorting workers by their wage-to-quality ratio and iterating through them to form groups is sound. Using a max-heap to maintain the `k` smallest qualities ensures that for each potential pay ratio, the minimal quality sum is used, thus correctly finding the minimum cost. The implementation details, such as using a min-heap with negative values to simulate a max-heap, are accurate.\n\n2.  **Edge Cases**: The algorithm handles edge cases appropriately. If `k=1`, the cost is `min(wages)`, which the algorithm correctly computes. If `k=n`, there's only one possible group, and its cost is calculated correctly on the last iteration. Constraints `quality[i] >= 1` prevent division by zero. The algorithm does not break for minimum or maximum values of `n` and `k`.\n\n3.  **Complexity**: The time complexity is `O(N log N)` due to sorting, and the space complexity is `O(N)` for storing worker data. This is efficient and meets typical constraints for `N` up to 10^4.\n\n4.  **Code Quality**: The code is clean, readable, and Pythonic. It uses list comprehensions and standard library modules (`heapq`) effectively. Variable names are clear and descriptive.\n\n5.  **Test Cases**: The logic was walked through with both example cases, and it produces the correct outputs (105.0 and 30.66667).\n\n6.  **Potential Issues**: No bugs or logical errors were found. The use of floating-point numbers for ratios is inherent to the problem and is handled correctly. The solution is robust and correct.\n\n**Conclusion**: The provided analysis and implementation are correct, efficient, and well-structured. The solution is valid.\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        qualities_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(qualities_heap, -q)\n            \n            if len(qualities_heap) > k:\n                quality_sum += heapq.heappop(qualities_heap)\n            \n            if len(qualities_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n```\n\n",
      "TypedCode": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        qualities_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(qualities_heap, -q)\n            \n            if len(qualities_heap) > k:\n                quality_sum += heapq.heappop(qualities_heap)\n            \n            if len(qualities_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 371042572624,
      "SolvedAt": "2025-11-21T13:58:59.821734+01:00",
      "PromptTokens": 9297,
      "OutputTokens": 43614
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "887",
        "typed_code": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        workers = sorted([(w / q, q) for q, w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        quality_sum = 0\n        qualities_heap = []\n        \n        for ratio, q in workers:\n            quality_sum += q\n            heapq.heappush(qualities_heap, -q)\n            \n            if len(qualities_heap) > k:\n                quality_sum += heapq.heappop(qualities_heap)\n            \n            if len(qualities_heap) == k:\n                min_cost = min(min_cost, ratio * quality_sum)\n                \n        return min_cost\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T21:38:41+01:00"
    }
  }
}