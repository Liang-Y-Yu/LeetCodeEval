{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "556",
        "questionId": "556",
        "Content": "<p>Given a positive integer <code>n</code>, find <em>the smallest integer which has exactly the same digits existing in the integer</em> <code>n</code> <em>and is greater in value than</em> <code>n</code>. If no such positive integer exists, return <code>-1</code>.</p>\n\n<p><strong>Note</strong> that the returned integer should fit in <strong>32-bit integer</strong>, if there is a valid answer but it does not fit in <strong>32-bit integer</strong>, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 12\n<strong>Output:</strong> 21\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 21\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "SampleTestCase": "12",
        "ExampleTestcases": "12\n21",
        "Difficulty": "Medium",
        "Title": "Next Greater Element III",
        "TitleSlug": "next-greater-element-iii",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"199.2K\", \"totalSubmission\": \"569.9K\", \"totalAcceptedRaw\": 199186, \"totalSubmissionRaw\": 569904, \"acRate\": \"35.0%\"}",
        "Likes": 3891,
        "Dislikes": 491,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjg=",
            "Name": "Math",
            "Slug": "math"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjk=",
            "Name": "Two Pointers",
            "Slug": "two-pointers"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int nextGreaterElement(int n) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int nextGreaterElement(int n) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def nextGreaterElement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number} n\n * @return {number}\n */\nvar nextGreaterElement = function(n) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function nextGreaterElement(n: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int NextGreaterElement(int n) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int nextGreaterElement(int n) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func nextGreaterElement(n int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun nextGreaterElement(n: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func nextGreaterElement(_ n: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn next_greater_element(n: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer} n\n# @return {Integer}\ndef next_greater_element(n)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function nextGreaterElement($n) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int nextGreaterElement(int n) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def nextGreaterElement(n: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec next_greater_element(n :: integer) :: integer\n  def next_greater_element(n) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec next_greater_element(N :: integer()) -> integer().\nnext_greater_element(N) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (next-greater-element n)\n  (-> exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:11:30.552081+01:00",
    "AcRate": "35.0",
    "TotalSubmissions": 569904,
    "TotalAccepted": 199186,
    "AcceptanceRate": 0.3495079873101435,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/next-greater-element-iii/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn elegant and efficient solution to this problem involves understanding it as finding the next lexicographically greater permutation of the digits of the input number `n`. The standard algorithm for this is as follows:\n\n1.  **Convert to a Sequence**: First, convert the integer `n` into a sequence of its digits, which is most easily handled as a list of characters or strings. This allows for mutable operations on the digits.\n\n2.  **Find the Pivot**: Traverse the sequence of digits from right to left. The first digit `s[i]` that is smaller than the digit to its right, `s[i+1]`, is our \"pivot\". This is the rightmost digit that is part of an ascent (e.g., in `12431`, the pivot is `2` because `2 < 4`). If no such digit is found, it means the entire sequence is in descending order (e.g., `321`), which is the largest possible permutation. In this case, no greater element exists, and we should return -1.\n\n3.  **Find the Successor**: After finding the pivot at index `i`, we need to find its \"successor\". The successor is the smallest digit in the suffix of the sequence (to the right of the pivot, i.e., `s[i+1:]`) that is still greater than the pivot digit `s[i]`. We can find this by scanning the suffix from right to left and picking the first digit larger than the pivot.\n\n4.  **Swap**: Swap the pivot digit `s[i]` with its successor digit. This ensures the new number is greater than the original. For example, if `n` is `12431`, after finding pivot `2` and successor `3`, we swap them to get `13421`.\n\n5.  **Sort the Suffix**: After the swap, the suffix to the right of the pivot's original position (`s[i+1:]`) is guaranteed to be in a non-increasing (descending) order. To make the resulting number the *smallest* possible greater number, this suffix must be rearranged into its smallest possible permutation, which is an ascending order. This can be achieved by simply reversing the suffix. Following our example with `13421`, reversing the suffix `421` gives `124`, resulting in the final arrangement `13124`.\n\n6.  **Convert Back and Validate**: Finally, join the modified sequence of digits back into a string, convert it to an integer, and check if it exceeds the 32-bit signed integer limit (`2^31 - 1`). If it does, return -1; otherwise, return the resulting number.\n\nThis approach is efficient, with a time complexity of O(D) and space complexity of O(D), where D is the number of digits in `n`. Given that `n` fits in a 32-bit integer, D is at most 10, making this solution extremely fast.\n\n```python\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        s = list(str(n))\n        num_digits = len(s)\n\n        # Step 1: Find the rightmost digit that is smaller than the digit to its right.\n        # This is the 'pivot'.\n        pivot_idx = num_digits - 2\n        while pivot_idx >= 0 and s[pivot_idx] >= s[pivot_idx + 1]:\n            pivot_idx -= 1\n\n        # If no such pivot exists, the number is already the largest permutation.\n        if pivot_idx < 0:\n            return -1\n\n        # Step 2: Find the smallest digit to the right of the pivot that is \n        # larger than the pivot. This is the 'successor'.\n        successor_idx = num_digits - 1\n        while s[successor_idx] <= s[pivot_idx]:\n            successor_idx -= 1\n        \n        # Step 3: Swap the pivot and the successor.\n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n\n        # Step 4: Reverse the part of the sequence to the right of the pivot's position.\n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n\n        # Step 5: Convert back to an integer and check against the 32-bit limit.\n        result_num = int(\"\".join(s))\n        \n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n\n```\n\n=== DESIGN ===\nAn elegant and efficient solution to this problem involves understanding it as finding the next lexicographically greater permutation of the digits of the input number `n`. The standard algorithm for this is as follows:\n1.  **Convert to a Sequence**: First, convert the integer `n` into a sequence of its digits, which is most easily handled as a list of characters or strings. This allows for mutable operations on the digits.\n2.  **Find the Pivot**: Traverse the sequence of digits from right to left. The first digit `s[i]` that is smaller than the digit to its right, `s[i+1]`, is our \"pivot\". This is the rightmost digit that is part of an ascent (e.g., in `12431`, the pivot is `2` because `2 < 4`). If no such digit is found, it means the entire sequence is in descending order (e.g., `321`), which is the largest possible permutation. In this case, no greater element exists, and we should return -1.\n3.  **Find the Successor**: After finding the pivot at index `i`, we need to find its \"successor\". The successor is the smallest digit in the suffix of the sequence (to the right of the pivot, i.e., `s[i+1:]`) that is still greater than the pivot digit `s[i]`. We can find this by scanning the suffix from right to left and picking the first digit larger than the pivot.\n4.  **Swap**: Swap the pivot digit `s[i]` with its successor digit. This ensures the new number is greater than the original. For example, if `n` is `12431`, after finding pivot `2` and successor `3`, we swap them to get `13421`.\n5.  **Sort the Suffix**: After the swap, the suffix to the right of the pivot's original position (`s[i+1:]`) is guaranteed to be in a non-increasing (descending) order. To make the resulting number the *smallest* possible greater number, this suffix must be rearranged into its smallest possible permutation, which is an ascending order. This can be achieved by simply reversing the suffix. Following our example with `13421`, reversing the suffix `421` gives `124`, resulting in the final arrangement `13124`.\n6.  **Convert Back and Validate**: Finally, join the modified sequence of digits back into a string, convert it to an integer, and check if it exceeds the 32-bit signed integer limit (`2^31 - 1`). If it does, return -1; otherwise, return the resulting number.\nThis approach is efficient, with a time complexity of O(D) and space complexity of O(D), where D is the number of digits in `n`. Given that `n` fits in a 32-bit integer, D is at most 10, making this solution extremely fast.\n```python\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        # 1. Convert to a mutable sequence of digits (list of characters).\n        s = list(str(n))\n        num_digits = len(s)\n\n        # 2. Find the pivot: the rightmost digit smaller than the digit to its right.\n        pivot_idx = -1\n        for i in range(num_digits - 2, -1, -1):\n            if s[i] < s[i+1]:\n                pivot_idx = i\n                break\n\n        # 3. If no pivot is found, the digits are in descending order (largest permutation).\n        if pivot_idx == -1:\n            return -1\n\n        # 4. Find the successor: the smallest digit to the right of the pivot that's\n        #    greater than the pivot.\n        successor_idx = -1\n        for j in range(num_digits - 1, pivot_idx, -1):\n            if s[j] > s[pivot_idx]:\n                successor_idx = j\n                break\n        \n        # 5. Swap the pivot and its successor.\n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n\n        # 6. Sort the suffix: reverse the part of the sequence to the right of the pivot.\n        # This makes the suffix the smallest possible permutation.\n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n\n        # 7. Convert back to an integer and validate.\n        result_str = \"\".join(s)\n        result_num = int(result_str)\n\n        # Check against the 32-bit signed integer limit.\n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        s = list(str(n))\n        num_digits = len(s)\n        \n        pivot_idx = -1\n        for i in range(num_digits - 2, -1, -1):\n            if s[i] < s[i+1]:\n                pivot_idx = i\n                break\n        \n        if pivot_idx == -1:\n            return -1\n            \n        successor_idx = -1\n        for j in range(num_digits - 1, pivot_idx, -1):\n            if s[j] > s[pivot_idx]:\n                successor_idx = j\n                break\n        \n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n        \n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n        \n        result_num = int(\"\".join(s))\n        \n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        s = list(str(n))\n        num_digits = len(s)\n        \n        pivot_idx = -1\n        for i in range(num_digits - 2, -1, -1):\n            if s[i] < s[i+1]:\n                pivot_idx = i\n                break\n        \n        if pivot_idx == -1:\n            return -1\n            \n        successor_idx = -1\n        for j in range(num_digits - 1, pivot_idx, -1):\n            if s[j] > s[pivot_idx]:\n                successor_idx = j\n                break\n        \n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n        \n        # Reverse the suffix starting from the pivot's next position\n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n        \n        result_num = int(\"\".join(s))\n        \n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n```\n\n",
      "TypedCode": "\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        s = list(str(n))\n        num_digits = len(s)\n        \n        pivot_idx = -1\n        for i in range(num_digits - 2, -1, -1):\n            if s[i] < s[i+1]:\n                pivot_idx = i\n                break\n        \n        if pivot_idx == -1:\n            return -1\n            \n        successor_idx = -1\n        for j in range(num_digits - 1, pivot_idx, -1):\n            if s[j] > s[pivot_idx]:\n                successor_idx = j\n                break\n        \n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n        \n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n        \n        result_num = int(\"\".join(s))\n        \n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 252556876375,
      "SolvedAt": "2025-11-21T14:48:02.154462+01:00",
      "PromptTokens": 7641,
      "OutputTokens": 29837
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "556",
        "typed_code": "\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        s = list(str(n))\n        num_digits = len(s)\n        \n        pivot_idx = -1\n        for i in range(num_digits - 2, -1, -1):\n            if s[i] < s[i+1]:\n                pivot_idx = i\n                break\n        \n        if pivot_idx == -1:\n            return -1\n            \n        successor_idx = -1\n        for j in range(num_digits - 1, pivot_idx, -1):\n            if s[j] > s[pivot_idx]:\n                successor_idx = j\n                break\n        \n        s[pivot_idx], s[successor_idx] = s[successor_idx], s[pivot_idx]\n        \n        s[pivot_idx + 1:] = s[pivot_idx + 1:][::-1]\n        \n        result_num = int(\"\".join(s))\n        \n        MAX_INT = 2**31 - 1\n        if result_num > MAX_INT:\n            return -1\n        \n        return result_num\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:48:31+01:00"
    }
  }
}