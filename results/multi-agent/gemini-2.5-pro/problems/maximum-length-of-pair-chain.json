{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "646",
        "questionId": "646",
        "Content": "<p>You are given an array of <code>n</code> pairs <code>pairs</code> where <code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> and <code>left<sub>i</sub> &lt; right<sub>i</sub></code>.</p>\n\n<p>A pair <code>p2 = [c, d]</code> <strong>follows</strong> a pair <code>p1 = [a, b]</code> if <code>b &lt; c</code>. A <strong>chain</strong> of pairs can be formed in this fashion.</p>\n\n<p>Return <em>the length longest chain which can be formed</em>.</p>\n\n<p>You do not need to use up all the given intervals. You can select pairs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[2,3],[3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [3,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[7,8],[4,5]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
        "SampleTestCase": "[[1,2],[2,3],[3,4]]",
        "ExampleTestcases": "[[1,2],[2,3],[3,4]]\n[[1,2],[7,8],[4,5]]",
        "Difficulty": "Medium",
        "Title": "Maximum Length of Pair Chain",
        "TitleSlug": "maximum-length-of-pair-chain",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"297.1K\", \"totalSubmission\": \"484.5K\", \"totalAcceptedRaw\": 297114, \"totalSubmissionRaw\": 484500, \"acRate\": \"61.3%\"}",
        "Likes": 4836,
        "Dislikes": 137,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int findLongestChain(int[][] pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findLongestChain(self, pairs):\n        \"\"\"\n        :type pairs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[][]} pairs\n * @return {number}\n */\nvar findLongestChain = function(pairs) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findLongestChain(pairs: number[][]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int FindLongestChain(int[][] pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int findLongestChain(int** pairs, int pairsSize, int* pairsColSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findLongestChain(pairs [][]int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findLongestChain(pairs: Array<IntArray>): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findLongestChain(_ pairs: [[Int]]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_longest_chain(pairs: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[][]} pairs\n# @return {Integer}\ndef find_longest_chain(pairs)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[][] $pairs\n     * @return Integer\n     */\n    function findLongestChain($pairs) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int findLongestChain(List<List<int>> pairs) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findLongestChain(pairs: Array[Array[Int]]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_longest_chain(pairs :: [[integer]]) :: integer\n  def find_longest_chain(pairs) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_longest_chain(Pairs :: [[integer()]]) -> integer().\nfind_longest_chain(Pairs) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-longest-chain pairs)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:08:39.29473+01:00",
    "AcRate": "61.3",
    "TotalSubmissions": 484500,
    "TotalAccepted": 297114,
    "AcceptanceRate": 0.6132383900928793,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/maximum-length-of-pair-chain/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\nAn analysis of the problem as requested, followed by the code solution.\n\n### 1. Problem Type Classification\nThis problem falls into the category of **Greedy Algorithms** and **Dynamic Programming**. It is a classic optimization problem that seeks to find the maximum number of compatible items from a set, which is structurally similar to the \"Activity Selection Problem\".\n\n### 2. Key Patterns & Algorithms\nThe problem can be solved using two primary algorithmic patterns:\n\n*   **Greedy Approach (most optimal)**: The key insight is to make a greedy choice at each step. The best greedy strategy here is to always select the next pair that *finishes earliest*. By sorting the pairs based on their end points (`righti`), we can iterate through them and pick a pair if it starts after the previously picked pair has finished. This approach ensures that by finishing as early as possible, we maximize the \"room\" for subsequent pairs in the chain.\n\n*   **Dynamic Programming (alternative)**: An alternative approach is to use dynamic programming. If we first sort the pairs by their start times (`lefti`), we can define `dp[i]` as the length of the longest chain ending with the `i`-th pair. The recurrence relation would be:\n    `dp[i] = 1 + max({dp[j]})` for all `j < i` where `pairs[j][1] < pairs[i][0]`.\n    The base case is `dp[i] = 1`. The final answer is the maximum value in the `dp` array. This approach has a time complexity of `O(n^2)`.\n\nThe greedy approach is more efficient and elegant.\n\n### 3. Constraints Analysis\n*   `n` (number of pairs) is up to 1000.\n*   Coordinates are between -1000 and 1000.\n\nBased on `n <= 1000`:\n*   An `O(n^2)` solution (like the DP approach) would involve about `1000 * 1000 = 10^6` operations, which is well within typical time limits (~10^8 ops/sec).\n*   An `O(n log n)` solution (like the greedy approach, dominated by sorting) would be even faster and is the preferred target.\n*   Space complexity of `O(n)` (for the DP table) or `O(log n)` to `O(n)` (for sorting in the greedy approach) is acceptable.\n\n### 4. Edge Cases\n*   **n = 1**: A single pair constitutes a chain of length 1.\n*   **No valid chains > 1**: e.g., `[[1,10],[2,5],[3,6]]`. The algorithm should correctly return 1.\n*   **All pairs form a chain**: e.g., `[[1,2],[3,4],[5,6]]`.\n*   **Duplicate pairs**: e.g., `[[1,2],[1,2],[3,4]]`. The logic should handle them correctly (the second `[1,2]` would be skipped).\n*   **Negative coordinates**: The logic `b < c` works irrespective of the sign of the numbers.\n\n### 5. Input/Output Analysis\n*   **Input**: `pairs: List[List[int]]`, where `pairs[i] = [lefti, righti]`.\n*   **Output**: A single `int` representing the length of the longest chain.\n\n### 6. Difficulty Assessment\nThe problem is of **Medium** difficulty. The main challenge lies in recognizing that it can be modeled as an interval scheduling problem and identifying the correct greedy strategy (sorting by end points). For those unfamiliar with this pattern, deriving the greedy choice can be non-trivial. The DP solution is more methodical to derive but less efficient.\n\n---\n```python\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda p: p[1])\n        \n        count = 0\n        current_end = float('-inf')\n        \n        for left, right in pairs:\n            if left > current_end:\n                count += 1\n                current_end = right\n                \n        return count\n```\n\n=== DESIGN ===\nAn elegant and efficient solution can be designed using a greedy approach, which is often effective for optimization problems involving intervals.\n\n### 1. Algorithm Choice\nThe chosen algorithm is a **Greedy Algorithm**. This problem is analogous to the classic \"Activity Selection Problem\". The optimal greedy strategy is to always prioritize the pair that finishes the earliest. By sorting the pairs based on their end points, we can iterate through them and make a locally optimal choice (picking the next non-conflicting pair) that leads to a globally optimal solution (the longest chain). This approach has a time complexity of O(n log n), which is superior to the O(n^2) dynamic programming alternative.\n\n### 2. Step-by-Step Approach\n1.  **Sort**: The most critical step is to sort the `pairs` array. The sorting key must be the second element of each pair (`righti`), in ascending order. This arranges the pairs so that those finishing earliest are considered first.\n2.  **Initialize**:\n    *   Initialize a counter for the chain length, `chain_length`, to 0.\n    *   Initialize a variable `current_chain_end` to track the end point of the last pair added to the chain. Starting it with `float('-inf')` ensures that the first pair in the sorted list is always selected.\n3.  **Iterate and Select**:\n    *   Iterate through each `pair` in the sorted list.\n    *   For each `pair = [left, right]`, check if its start value (`left`) is strictly greater than `current_chain_end`.\n    *   If `left > current_chain_end`, this pair can be added to the chain without conflict.\n    *   When a valid pair is found, increment `chain_length` by 1 and update `current_chain_end` to the end value (`right`) of this new pair.\n4.  **Return Result**: After iterating through all pairs, the final value of `chain_length` represents the length of the longest possible chain.\n\n### 3. Data Structures\n*   **List of Lists (`List[List[int]]`)**: The input `pairs` array, which will be sorted.\n*   **Integer Variables**:\n    *   `chain_length`: To store the length of the constructed chain.\n    *   `current_chain_end`: To maintain the end point of the last selected pair.\n\n### 4. Time Complexity\n*   **O(n log n)**: The runtime is dominated by the initial sorting of the `n` pairs. The single pass that follows takes O(n) time. Thus, the total complexity is O(n log n).\n\n### 5. Space Complexity\n*   **O(n)** or **O(log n)**: The space complexity depends on the sorting algorithm implementation. Python's `Timsort` may use up to O(n) auxiliary space in the worst case. Aside from the sort, the algorithm uses only a constant amount of extra space (O(1)).\n\n### 6. Pseudocode\n```\nFUNCTION findLongestChain(pairs):\n    // 1. Sort the pairs based on their end points\n    SORT pairs in ascending order using the second element of each pair as the key\n\n    // 2. Initialize state variables\n    chain_length = 0\n    // Use a value smaller than any possible pair start\n    last_end_point = -INFINITY\n\n    // 3. Iterate through sorted pairs to build the chain\n    FOR EACH pair in pairs:\n        current_start = pair[0]\n        current_end = pair[1]\n\n        // If the current pair can start after the previous one ended\n        IF current_start > last_end_point:\n            // Add this pair to our chain\n            chain_length = chain_length + 1\n            // Update the end point of the chain\n            last_end_point = current_end\n        END IF\n    END FOR\n\n    // 4. Return the final length\n    RETURN chain_length\n```\n\n```python\nfrom typing import List\n\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        # Sort the pairs based on their end points (the second element).\n        # This is the core of the greedy strategy.\n        pairs.sort(key=lambda p: p[1])\n        \n        chain_length = 0\n        # Initialize the end of the current chain to a very small number.\n        current_end = float('-inf')\n        \n        # Iterate through the sorted pairs to build the longest chain.\n        for left, right in pairs:\n            # If the current pair's start is greater than the end of the\n            # last pair in our chain, it can be added.\n            if left > current_end:\n                # Add this pair to the chain.\n                chain_length += 1\n                # Update the end of the chain to the current pair's end.\n                current_end = right\n                \n        return chain_length\n\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda p: p[1])\n        \n        chain_length = 0\n        current_chain_end = float('-inf')\n        \n        for left, right in pairs:\n            if left > current_chain_end:\n                chain_length += 1\n                current_chain_end = right\n                \n        return chain_length\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        # Sort the pairs based on their end points (the second element).\n        # This is the core of the greedy strategy, as it prioritizes\n        # pairs that finish earliest, leaving maximal room for subsequent pairs.\n        pairs.sort(key=lambda p: p[1])\n        \n        # Initialize the length of the chain.\n        chain_length = 0\n        \n        # Initialize the end of the last pair in the chain to a value\n        # guaranteed to be less than any possible pair's start time.\n        current_chain_end = float('-inf')\n        \n        # Iterate through the sorted pairs to greedily build the longest chain.\n        for left, right in pairs:\n            # If the current pair's start is strictly greater than the end of the\n            # last pair in our chain, it means this pair does not overlap and\n            # can be added to the chain.\n            if left > current_chain_end:\n                # Add this valid pair to the chain by incrementing the length.\n                chain_length += 1\n                # Update the end of the chain to the end of the current pair.\n                current_chain_end = right\n                \n        return chain_length\n```\n\n",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda p: p[1])\n        \n        chain_length = 0\n        current_chain_end = float('-inf')\n        \n        for left, right in pairs:\n            if left > current_chain_end:\n                chain_length += 1\n                current_chain_end = right\n                \n        return chain_length\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 195574199333,
      "SolvedAt": "2025-11-21T13:06:07.369262+01:00",
      "PromptTokens": 7649,
      "OutputTokens": 25029
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "646",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda p: p[1])\n        \n        chain_length = 0\n        current_chain_end = float('-inf')\n        \n        for left, right in pairs:\n            if left > current_chain_end:\n                chain_length += 1\n                current_chain_end = right\n                \n        return chain_length\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:58:17+01:00"
    }
  }
}