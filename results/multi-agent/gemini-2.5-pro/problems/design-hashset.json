{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "705",
        "questionId": "816",
        "Content": "<p>Design a HashSet without using any built-in hash table libraries.</p>\n\n<p>Implement <code>MyHashSet</code> class:</p>\n\n<ul>\n\t<li><code>void add(key)</code> Inserts the value <code>key</code> into the HashSet.</li>\n\t<li><code>bool contains(key)</code> Returns whether the value <code>key</code> exists in the HashSet or not.</li>\n\t<li><code>void remove(key)</code> Removes the value <code>key</code> in the HashSet. If <code>key</code> does not exist in the HashSet, do nothing.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>Explanation</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>, <code>remove</code>, and <code>contains</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"MyHashSet\",\"add\",\"add\",\"contains\",\"contains\",\"add\",\"contains\",\"remove\",\"contains\"]\n[[],[1],[2],[1],[3],[2],[2],[2],[2]]",
        "ExampleTestcases": "[\"MyHashSet\",\"add\",\"add\",\"contains\",\"contains\",\"add\",\"contains\",\"remove\",\"contains\"]\n[[],[1],[2],[1],[3],[2],[2],[2],[2]]",
        "Difficulty": "Easy",
        "Title": "Design HashSet",
        "TitleSlug": "design-hashset",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"535.1K\", \"totalSubmission\": \"793.2K\", \"totalAcceptedRaw\": 535134, \"totalSubmissionRaw\": 793245, \"acRate\": \"67.5%\"}",
        "Likes": 3985,
        "Dislikes": 324,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjc=",
            "Name": "Linked List",
            "Slug": "linked-list"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDY1",
            "Name": "Hash Function",
            "Slug": "hash-function"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class MyHashSet {\npublic:\n    MyHashSet() {\n        \n    }\n    \n    void add(int key) {\n        \n    }\n    \n    void remove(int key) {\n        \n    }\n    \n    bool contains(int key) {\n        \n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj->add(key);\n * obj->remove(key);\n * bool param_3 = obj->contains(key);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void add(int key) {\n        \n    }\n    \n    public void remove(int key) {\n        \n    }\n    \n    public boolean contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class MyHashSet:\n\n    def __init__(self):\n        \n\n    def add(self, key: int) -> None:\n        \n\n    def remove(self, key: int) -> None:\n        \n\n    def contains(self, key: int) -> bool:\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class MyHashSet(object):\n\n    def __init__(self):\n        \n\n    def add(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def remove(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def contains(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar MyHashSet = function() {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.add = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.remove = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {boolean}\n */\nMyHashSet.prototype.contains = function(key) {\n    \n};\n\n/** \n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class MyHashSet {\n    constructor() {\n        \n    }\n\n    add(key: number): void {\n        \n    }\n\n    remove(key: number): void {\n        \n    }\n\n    contains(key: number): boolean {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void Add(int key) {\n        \n    }\n    \n    public void Remove(int key) {\n        \n    }\n    \n    public bool Contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.Add(key);\n * obj.Remove(key);\n * bool param_3 = obj.Contains(key);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} MyHashSet;\n\n\nMyHashSet* myHashSetCreate() {\n    \n}\n\nvoid myHashSetAdd(MyHashSet* obj, int key) {\n    \n}\n\nvoid myHashSetRemove(MyHashSet* obj, int key) {\n    \n}\n\nbool myHashSetContains(MyHashSet* obj, int key) {\n    \n}\n\nvoid myHashSetFree(MyHashSet* obj) {\n    \n}\n\n/**\n * Your MyHashSet struct will be instantiated and called as such:\n * MyHashSet* obj = myHashSetCreate();\n * myHashSetAdd(obj, key);\n \n * myHashSetRemove(obj, key);\n \n * bool param_3 = myHashSetContains(obj, key);\n \n * myHashSetFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type MyHashSet struct {\n    \n}\n\n\nfunc Constructor() MyHashSet {\n    \n}\n\n\nfunc (this *MyHashSet) Add(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Remove(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Contains(key int) bool {\n    \n}\n\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(key);\n * obj.Remove(key);\n * param_3 := obj.Contains(key);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class MyHashSet() {\n\n    fun add(key: Int) {\n        \n    }\n\n    fun remove(key: Int) {\n        \n    }\n\n    fun contains(key: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass MyHashSet {\n\n    init() {\n        \n    }\n    \n    func add(_ key: Int) {\n        \n    }\n    \n    func remove(_ key: Int) {\n        \n    }\n    \n    func contains(_ key: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * let ret_3: Bool = obj.contains(key)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct MyHashSet {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyHashSet {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, key: i32) {\n        \n    }\n    \n    fn remove(&self, key: i32) {\n        \n    }\n    \n    fn contains(&self, key: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet::new();\n * obj.add(key);\n * obj.remove(key);\n * let ret_3: bool = obj.contains(key);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class MyHashSet\n    def initialize()\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def add(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def remove(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Boolean\n=end\n    def contains(key)\n        \n    end\n\n\nend\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet.new()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class MyHashSet {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function add($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function remove($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return Boolean\n     */\n    function contains($key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * $obj = MyHashSet();\n * $obj->add($key);\n * $obj->remove($key);\n * $ret_3 = $obj->contains($key);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class MyHashSet {\n\n  MyHashSet() {\n    \n  }\n  \n  void add(int key) {\n    \n  }\n  \n  void remove(int key) {\n    \n  }\n  \n  bool contains(int key) {\n    \n  }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * bool param3 = obj.contains(key);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class MyHashSet() {\n\n    def add(key: Int): Unit = {\n        \n    }\n\n    def remove(key: Int): Unit = {\n        \n    }\n\n    def contains(key: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * val obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * val param_3 = obj.contains(key)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule MyHashSet do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(key :: integer) :: any\n  def add(key) do\n    \n  end\n\n  @spec remove(key :: integer) :: any\n  def remove(key) do\n    \n  end\n\n  @spec contains(key :: integer) :: boolean\n  def contains(key) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MyHashSet.init_()\n# MyHashSet.add(key)\n# MyHashSet.remove(key)\n# param_3 = MyHashSet.contains(key)\n\n# MyHashSet.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec my_hash_set_init_() -> any().\nmy_hash_set_init_() ->\n  .\n\n-spec my_hash_set_add(Key :: integer()) -> any().\nmy_hash_set_add(Key) ->\n  .\n\n-spec my_hash_set_remove(Key :: integer()) -> any().\nmy_hash_set_remove(Key) ->\n  .\n\n-spec my_hash_set_contains(Key :: integer()) -> boolean().\nmy_hash_set_contains(Key) ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_hash_set_init_(),\n%% my_hash_set_add(Key),\n%% my_hash_set_remove(Key),\n%% Param_3 = my_hash_set_contains(Key),\n\n%% my_hash_set_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define my-hash-set%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add key)\n      )\n    ; remove : exact-integer? -> void?\n    (define/public (remove key)\n      )\n    ; contains : exact-integer? -> boolean?\n    (define/public (contains key)\n      )))\n\n;; Your my-hash-set% object will be instantiated and called as such:\n;; (define obj (new my-hash-set%))\n;; (send obj add key)\n;; (send obj remove key)\n;; (define param_3 (send obj contains key))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:59:26.643462+01:00",
    "AcRate": "67.5",
    "TotalSubmissions": 793245,
    "TotalAccepted": 535134,
    "AcceptanceRate": 0.6746137700206115,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "multi",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/design-hashset/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification",
      "Answer": "=== ANALYSIS ===\n```python\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)\n```\n\n=== DESIGN ===\nMyHashSet uses a hashing strategy with separate chaining to handle collisions. A large array, called `buckets`, is initialized. Each key is passed through a hash function (a simple modulo operation) to map it to an index in this `buckets` array. Since multiple keys might map to the same index (a collision), each slot in the `buckets` array holds another data structure, a list, to store all keys that hash to that index.\n\n**Initialization (`__init__`)**:\nA list of a fixed `size` (e.g., 1000) is created. Each element of this list is an empty list, representing a bucket.\n\n**Add (`add(key)`)**:\n1.  The key is hashed to find its bucket index.\n2.  The corresponding bucket (a list) is retrieved.\n3.  To maintain the \"set\" property of uniqueness, we first check if the key already exists in the bucket's list.\n4.  If the key is not present, it is appended to the list.\n\n**Remove (`remove(key)`)**:\n1.  The key is hashed to find its bucket index.\n2.  The bucket list is retrieved.\n3.  We attempt to remove the key from this list. A `try-except` block is used to gracefully handle cases where the key does not exist, fulfilling the requirement to \"do nothing\".\n\n**Contains (`contains(key)`)**:\n1.  The key is hashed to find its bucket index.\n2.  The bucket list is retrieved.\n3.  We perform a search (using Python's `in` operator) on the list to check for the key's existence and return the boolean result.\n\nThis design has an average time complexity of O(N/K) for all operations, where N is the number of elements and K is the number of buckets, which simplifies to O(1) with a good load factor. The space complexity is O(N+K).\n\n```python\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n\n```\n\n=== IMPLEMENTATION ===\n```python\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)\n```\n\n=== VERIFICATION ===\n```python\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n```\n\n",
      "TypedCode": "\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 188000123042,
      "SolvedAt": "2025-11-21T10:47:34.792996+01:00",
      "PromptTokens": 5645,
      "OutputTokens": 21556
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "816",
        "typed_code": "\nclass MyHashSet:\n\n    def __init__(self):\n        self.size = 1000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass\n\n    def contains(self, key: int) -> bool:\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        return key in bucket\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-21T20:49:21+01:00"
    }
  }
}