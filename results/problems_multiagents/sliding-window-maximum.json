{"Question":{"Data":{"Question":{"questionFrontendId":"239","questionId":"239","Content":"<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n","SampleTestCase":"[1,3,-1,-3,5,3,6,7]\n3","ExampleTestcases":"[1,3,-1,-3,5,3,6,7]\n3\n[1]\n1","Difficulty":"Hard","Title":"Sliding Window Maximum","TitleSlug":"sliding-window-maximum","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 1395909, \"totalSubmissionRaw\": 2920544, \"acRate\": \"47.8%\"}","Likes":19514,"Dislikes":769,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjM0","Name":"Queue","Slug":"queue"},{"Id":"VG9waWNUYWdOb2RlOjU1ODIx","Name":"Sliding Window","Slug":"sliding-window"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"},{"Id":"VG9waWNUYWdOb2RlOjYxMDcx","Name":"Monotonic Queue","Slug":"monotonic-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<int> maxSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxSlidingWindow(nums []int, k int) []int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sliding_window(nums, k)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sliding_window(Nums, K) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]\n  def max_sliding_window(nums, k) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:18:40.554905234+02:00","AcRate":"47.8","TotalSubmissions":2920544,"TotalAccepted":1395909,"AcceptanceRate":0.477961982425192,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/sliding-window-maximum/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:  # quick response for empty input\n            return []\n        if k == 1:  # quick response when k is 1\n            return nums\n\n        deq = deque()\n        max_indices = []\n\n        def clean_deque(i):\n            # Remove indexes of elements not in the sliding window anymore\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            \n            # Remove from deque indexes the elements which are smaller\n            # than the current element nums[i]\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n\n        # Initialize the deque and output for the first sliding window\n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            # Keep track of the max value in the first window\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n\n        # Process the rest of the array\n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n\n        return max_indices\n```\n\n=== DESIGN ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        max_indices = []\n        \n        def clean_deque(i):\n            # Remove the index of the element that is out of the current sliding window range\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            \n            # Remove indexes from deque for elements which are smaller than nums[i]\n            # Since they are not useful in future max comparisons, as nums[i] is greater\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        # Initialize the deque and output for the first window\n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            # If a current num is greater than the first deque element, update the deque\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n        \n        # Process the rest of the array\n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n        \n        return max_indices\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        max_indices = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n        \n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n        \n        return max_indices\n```\n\n=== VERIFICATION ===\nHere is the verification report for the provided implementation:\n\n1. **Correctness**: \n   - The code correctly implements the sliding window maximum algorithm using a deque to maintain the indices of potential maximum elements within the current window.\n   - The use of `clean_deque` function ensures that the deque only contains indices of elements that may contribute to the maximum in future windows.\n\n2. **Edge Cases**: \n   - The code correctly checks for edge cases such as when `k` equals 1, where the result is simply the original list.\n   - It handles the case when the input list is empty by returning an empty list immediately.\n   \n3. **Complexity**:\n   - The code operates efficiently with a time complexity of O(n), where n is the length of the list due to each element being processed a constant number of times.\n   - Space complexity is O(k) due to the deque potentially holding up to `k` indices.\n\n4. **Code Quality**:\n   - The code is well-structured and readable. It follows good practices by separating the logic into a function `clean_deque`.\n   - The use of comments within the helper function clarifies its purpose.\n\n5. **Test Cases**:\n   - When tested against the provided examples, the solution produces the expected outputs.\n   - For example, for `nums = [1,3,-1,-3,5,3,6,7]` and `k = 3`, output is `[3,3,5,5,6,7]`.\n\n6. **Potential Issues**:\n   - There are no logical errors or bugs in the code.\n   - The code is efficient and meets the problem requirements without any issues.\n\nOverall, the solution correctly solves the problem within the defined constraints and handles all edge cases adequately. It adheres to good coding practices for readability and efficiency.\n\nHere is the verified code:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        max_indices = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n        \n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n        \n        return max_indices\n```\n\n","TypedCode":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        max_indices = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n        \n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n        \n        return max_indices\n","Model":"se-gpt-4o","Latency":16299887910,"SolvedAt":"2025-08-07T09:48:15.515371021+02:00","PromptTokens":4608,"OutputTokens":1443}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"239","typed_code":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        max_indices = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(nums[deq[0]])\n        \n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(nums[deq[0]])\n        \n        return max_indices\n"},"SubmissionId":1726613960,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T10:20:35.149424897+02:00"}}}
