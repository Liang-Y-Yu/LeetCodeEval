{"Question":{"Data":{"Question":{"questionFrontendId":"1268","questionId":"1397","Content":"<p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p>\n\n<p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>\n\n<p>Return <em>a list of lists of the suggested products after each character of </em><code>searchWord</code><em> is typed</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;\n<strong>Output:</strong> [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]\n<strong>Explanation:</strong> products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;].\nAfter typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;].\nAfter typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> products = [&quot;havana&quot;], searchWord = &quot;havana&quot;\n<strong>Output:</strong> [[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]\n<strong>Explanation:</strong> The only word &quot;havana&quot; will be always suggested while typing the search word.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= products.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= products[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(products[i].length) &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>All the strings of <code>products</code> are <strong>unique</strong>.</li>\n\t<li><code>products[i]</code> consists of lowercase English letters.</li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>\n\t<li><code>searchWord</code> consists of lowercase English letters.</li>\n</ul>\n","SampleTestCase":"[\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"]\n\"mouse\"","ExampleTestcases":"[\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"]\n\"mouse\"\n[\"havana\"]\n\"havana\"","Difficulty":"Medium","Title":"Search Suggestions System","TitleSlug":"search-suggestions-system","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"402K\", \"totalSubmission\": \"617.8K\", \"totalAcceptedRaw\": 401986, \"totalSubmissionRaw\": 617757, \"acRate\": \"65.1%\"}","Likes":5017,"Dislikes":260,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjEx","Name":"Binary Search","Slug":"binary-search"},{"Id":"VG9waWNUYWdOb2RlOjI3","Name":"Trie","Slug":"trie"},{"Id":"VG9waWNUYWdOb2RlOjYxMDQ5","Name":"Sorting","Slug":"sorting"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** suggestedProducts(char** products, int productsSize, char* searchWord, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<IList<string>> SuggestedProducts(string[] products, string searchWord) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string[]} products\n * @param {string} searchWord\n * @return {string[][]}\n */\nvar suggestedProducts = function(products, searchWord) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function suggestedProducts(products: string[], searchWord: string): string[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String[] $products\n     * @param String $searchWord\n     * @return String[][]\n     */\n    function suggestedProducts($products, $searchWord) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func suggestedProducts(_ products: [String], _ searchWord: String) -> [[String]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun suggestedProducts(products: Array<String>, searchWord: String): List<List<String>> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<String>> suggestedProducts(List<String> products, String searchWord) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func suggestedProducts(products []string, searchWord string) [][]string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String[]} products\n# @param {String} search_word\n# @return {String[][]}\ndef suggested_products(products, search_word)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def suggestedProducts(products: Array[String], searchWord: String): List[List[String]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn suggested_products(products: Vec<String>, search_word: String) -> Vec<Vec<String>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (suggested-products products searchWord)\n  (-> (listof string?) string? (listof (listof string?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec suggested_products(Products :: [unicode:unicode_binary()], SearchWord :: unicode:unicode_binary()) -> [[unicode:unicode_binary()]].\nsuggested_products(Products, SearchWord) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec suggested_products(products :: [String.t], search_word :: String.t) :: [[String.t]]\n  def suggested_products(products, search_word) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:17:50.440944884+02:00","AcRate":"65.1","TotalSubmissions":617757,"TotalAccepted":401986,"AcceptanceRate":0.6507186482710839,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/search-suggestions-system/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            suggestions = []\n            for product in products:\n                if product.startswith(prefix):\n                    suggestions.append(product)\n                if len(suggestions) == 3:\n                    break\n            result.append(suggestions)\n        \n        return result\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        # Sort products lexicographically\n        products.sort()\n        # Initialize the result list\n        result = []\n        # Initialize prefix as empty\n        prefix = \"\"\n        \n        for char in searchWord:\n            # Build up the prefix\n            prefix += char\n            # Perform binary search to find the first product which has the current prefix\n            low, high = 0, len(products)\n            while low < high:\n                mid = (low + high) // 2\n                if products[mid] < prefix:\n                    low = mid + 1\n                else:\n                    high = mid\n            \n            # Collect up to three products that match the prefix\n            suggestions = []\n            for i in range(low, min(low + 3, len(products))):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                else:\n                    break\n            \n            # Append the suggestions to the result\n            result.append(suggestions)\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            low, high = 0, len(products)\n            while low < high:\n                mid = (low + high) // 2\n                if products[mid] < prefix:\n                    low = mid + 1\n                else:\n                    high = mid\n            \n            suggestions = []\n            for i in range(low, min(low + 3, len(products))):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                else:\n                    break\n            \n            result.append(suggestions)\n        \n        return result\n```\n\n=== VERIFICATION ===\nHere's the expanded code snippet implementing the solution based on the provided analysis. The solution follows the design using binary search for efficiency and handles the constraints effectively:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        # Sort products lexicographically\n        products.sort()\n        # Initialize the result list\n        result = []\n        # Initialize prefix as empty\n        prefix = \"\"\n        \n        for char in searchWord:\n            # Build up the prefix\n            prefix += char\n            # Perform binary search to find the first product which has the current prefix\n            low, high = 0, len(products)\n            while low < high:\n                mid = (low + high) // 2\n                if products[mid] < prefix:\n                    low = mid + 1\n                else:\n                    high = mid\n            \n            # Collect up to three products that match the prefix\n            suggestions = []\n            for i in range(low, min(low + 3, len(products))):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                else:\n                    break\n            \n            # Append the suggestions to the result\n            result.append(suggestions)\n        \n        return result\n```\n\nVerification Report:\n\n1. **Correctness**: The code correctly implements the algorithm using binary search which efficiently locates the start of potential suggestions, followed by checking up to three products that start with the prefix.\n\n2. **Edge Cases**: The code handles edge cases well, such as when `searchWord` is longer than any product word or when no product matches the prefix at all.\n\n3. **Complexity**: The code follows a time complexity of O(N log N + M log N + K) where N is the number of products (due to sorting), M is the length of the searchWord, and K is the maximum number of suggestions per prefix check. This is efficient given the constraints.\n\n4. **Code Quality**: The code is clean, readable, and follows best practices. There is use of appropriate variable names and logical structuring of loops and conditionals.\n\n5. **Test Cases**: The provided examples in the problem statement were verified against the code, and the code produced correct outputs as expected.\n\n6. **Potential Issues**: There are no present issues or logical errors in the code. It is implemented as per the design, and it efficiently uses binary search for suggestion retrieval.\n\nThe solution appears to meet all requirements and effectively solves the problem while adhering to the constraints and expected efficiency.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            low, high = 0, len(products)\n            while low < high:\n                mid = (low + high) // 2\n                if products[mid] < prefix:\n                    low = mid + 1\n                else:\n                    high = mid\n            \n            suggestions = []\n            for i in range(low, min(low + 3, len(products))):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                else:\n                    break\n            \n            result.append(suggestions)\n        \n        return result\n","Model":"se-gpt-4o","Latency":13275305477,"SolvedAt":"2025-08-07T09:47:39.350455818+02:00","PromptTokens":3898,"OutputTokens":1021}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"1397","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        result = []\n        prefix = \"\"\n        \n        for char in searchWord:\n            prefix += char\n            low, high = 0, len(products)\n            while low < high:\n                mid = (low + high) // 2\n                if products[mid] < prefix:\n                    low = mid + 1\n                else:\n                    high = mid\n            \n            suggestions = []\n            for i in range(low, min(low + 3, len(products))):\n                if products[i].startswith(prefix):\n                    suggestions.append(products[i])\n                else:\n                    break\n            \n            result.append(suggestions)\n        \n        return result\n"},"SubmissionId":1726613131,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T10:19:32.162897962+02:00"}}}
