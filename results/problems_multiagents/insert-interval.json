{"Question":{"Data":{"Question":{"questionFrontendId":"57","questionId":"57","Content":"<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n","SampleTestCase":"[[1,3],[6,9]]\n[2,5]","ExampleTestcases":"[[1,3],[6,9]]\n[2,5]\n[[1,2],[3,5],[6,7],[8,10],[12,16]]\n[4,8]","Difficulty":"Medium","Title":"Insert Interval","TitleSlug":"insert-interval","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 1517692, \"totalSubmissionRaw\": 3467211, \"acRate\": \"43.8%\"}","Likes":11252,"Dislikes":893,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function insert(intervals: number[][], newInterval: number[]): number[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func insert(intervals [][]int, newInterval []int) [][]int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (insert intervals newInterval)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec insert(Intervals :: [[integer()]], NewInterval :: [integer()]) -> [[integer()]].\ninsert(Intervals, NewInterval) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec insert(intervals :: [[integer]], new_interval :: [integer]) :: [[integer]]\n  def insert(intervals, new_interval) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:12:45.929367776+02:00","AcRate":"43.8","TotalSubmissions":3467211,"TotalAccepted":1517692,"AcceptanceRate":0.43772703766802773,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/insert-interval/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals to newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== DESIGN ===\nAlgorithm Choice: The approach is a straightforward iteration with conditional merging. Given the intervals are already sorted by the start time, we proceed to iterate to find where the new interval can fit, merge overlapping intervals, and finalize the list.\n\nStep-by-Step Approach:\n1. Create an empty list, `result`, to store the final list of intervals.\n2. Iterate through the `intervals` while adding intervals that end before the `newInterval` starts to the `result`.\n3. Merge all intervals that overlap with `newInterval`. Update the `newInterval` to encompass the start of the earliest interval and the end of the latest overlapping interval.\n4. Append the merged `newInterval` to `result`.\n5. Add all remaining intervals from the input list that start after the merged `newInterval` ends.\n6. Return the `result` list.\n\nData Structures: \n- Use a list to store the resulting intervals as merging proceeds.\n\nTime Complexity: The algorithm essentially processes each interval at most once, leading to a complexity of O(n), where n is the number of intervals.\n\nSpace Complexity: We use an additional list to store merged intervals, so in the worst case, space complexity is O(n) if none of the intervals overlap and all are returned.\n\nPseudocode:\n```\ndef insert(intervals, newInterval):\n    Initialize result as an empty list.\n    Set i to 0.\n    Set n to length of intervals.\n\n    # Add intervals that end before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        Add intervals[i] to result.\n        Increment i.\n\n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        Update newInterval[0] to min(newInterval[0], intervals[i][0])\n        Update newInterval[1] to max(newInterval[1], intervals[i][1])\n        Increment i.\n\n    # Add the merged interval to result\n    Add newInterval to result.\n\n    # Add non-overlapping intervals after newInterval\n    while i < n:\n        Add intervals[i] to result.\n        Increment i.\n\n    return result\n```\n\nHere's the implementation based on the above approach:\n\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals to newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n=== VERIFICATION ===\nThe provided solution correctly implements the algorithm for inserting and merging intervals as described in the problem statement. Here’s the verification of various aspects of the implementation:\n\n1. **Correctness**: \n   - The code correctly iterates through the list of intervals, adding non-overlapping intervals before the new interval, merging overlapping intervals with the new interval, and appending non-overlapping intervals after the merged new interval.\n   - It handles merging by adjusting the start and end of the new interval based on overlapping intervals, which is logically correct.\n\n2. **Edge Cases**:\n   - The solution handles edge cases such as:\n     - An empty list of intervals.\n     - The new interval overlapping all intervals in the list.\n     - The new interval not overlapping any intervals.\n   - It correctly manages cases where there are no intervals in the input by returning just the new interval.\n\n3. **Complexity**:\n   - Time Complexity: O(n), where n is the number of intervals, as it traverses the list linearly once.\n   - Space Complexity: O(n), since it uses a separate result list to store the merged intervals, similar to the complexity for a direct copy of the input list when intervals do not overlap.\n\n4. **Code Quality**:\n   - The code is clean, readable, and efficiently uses Python list operations.\n   - Variable names are intuitive, making the logic easy to follow.\n\n5. **Test Cases**:\n   - Example 1 and Example 2 from the problem statement are correctly handled, providing expected results.\n   - Works correctly with provided inputs, verifying the correctness across different conditions.\n\n6. **Potential Issues**:\n   - No bugs or logical errors found.\n   - No unnecessary calculations, maintaining efficiency.\n\nWith these evaluations, the solution is verified to be correct and optimal given the constraints. The implementation is ready to be executed directly.\n\nHere's the final validated solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge all overlapping intervals to newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        # Add the merged newInterval\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n```\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n","Model":"se-gpt-4o","Latency":20183699024,"SolvedAt":"2025-08-07T09:37:28.169848923+02:00","PromptTokens":4879,"OutputTokens":1627}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"57","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n"},"SubmissionId":1726601779,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T10:04:28.031912766+02:00"}}}
