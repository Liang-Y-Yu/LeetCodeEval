{"Question":{"Data":{"Question":{"questionFrontendId":"155","questionId":"155","Content":"<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n","SampleTestCase":"[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]","ExampleTestcases":"[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]","Difficulty":"Medium","Title":"Min Stack","TitleSlug":"min-stack","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"2.5M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 2467517, \"totalSubmissionRaw\": 4308870, \"acRate\": \"57.3%\"}","Likes":15597,"Dislikes":978,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjE1","Name":"Stack","Slug":"stack"},{"Id":"VG9waWNUYWdOb2RlOjI1","Name":"Design","Slug":"design"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class MinStack {\npublic:\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        \n    }\n    \n    void pop() {\n        \n    }\n    \n    int top() {\n        \n    }\n    \n    int getMin() {\n        \n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */"},{"Lang":"Java","LangSlug":"java","Code":"class MinStack {\n\n    public MinStack() {\n        \n    }\n    \n    public void push(int val) {\n        \n    }\n    \n    public void pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public int getMin() {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */"},{"Lang":"Python3","LangSlug":"python3","Code":"class MinStack:\n\n    def __init__(self):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> None:\n        \n\n    def top(self) -> int:\n        \n\n    def getMin(self) -> int:\n        \n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()"},{"Lang":"Python","LangSlug":"python","Code":"class MinStack(object):\n\n    def __init__(self):\n        \n\n    def push(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: None\n        \"\"\"\n        \n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def getMin(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"\nvar MinStack = function() {\n    \n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    \n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    \n};\n\n/** \n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"class MinStack {\n    constructor() {\n        \n    }\n\n    push(val: number): void {\n        \n    }\n\n    pop(): void {\n        \n    }\n\n    top(): number {\n        \n    }\n\n    getMin(): number {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"Lang":"C#","LangSlug":"csharp","Code":"public class MinStack {\n\n    public MinStack() {\n        \n    }\n    \n    public void Push(int val) {\n        \n    }\n    \n    public void Pop() {\n        \n    }\n    \n    public int Top() {\n        \n    }\n    \n    public int GetMin() {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.Push(val);\n * obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.GetMin();\n */"},{"Lang":"C","LangSlug":"c","Code":"\n\n\ntypedef struct {\n    \n} MinStack;\n\n\nMinStack* minStackCreate() {\n    \n}\n\nvoid minStackPush(MinStack* obj, int val) {\n    \n}\n\nvoid minStackPop(MinStack* obj) {\n    \n}\n\nint minStackTop(MinStack* obj) {\n    \n}\n\nint minStackGetMin(MinStack* obj) {\n    \n}\n\nvoid minStackFree(MinStack* obj) {\n    \n}\n\n/**\n * Your MinStack struct will be instantiated and called as such:\n * MinStack* obj = minStackCreate();\n * minStackPush(obj, val);\n \n * minStackPop(obj);\n \n * int param_3 = minStackTop(obj);\n \n * int param_4 = minStackGetMin(obj);\n \n * minStackFree(obj);\n*/"},{"Lang":"Go","LangSlug":"golang","Code":"type MinStack struct {\n    \n}\n\n\nfunc Constructor() MinStack {\n    \n}\n\n\nfunc (this *MinStack) Push(val int)  {\n    \n}\n\n\nfunc (this *MinStack) Pop()  {\n    \n}\n\n\nfunc (this *MinStack) Top() int {\n    \n}\n\n\nfunc (this *MinStack) GetMin() int {\n    \n}\n\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(val);\n * obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.GetMin();\n */"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class MinStack() {\n\n    fun push(`val`: Int) {\n        \n    }\n\n    fun pop() {\n        \n    }\n\n    fun top(): Int {\n        \n    }\n\n    fun getMin(): Int {\n        \n    }\n\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = MinStack()\n * obj.push(`val`)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"Lang":"Swift","LangSlug":"swift","Code":"\nclass MinStack {\n\n    init() {\n        \n    }\n    \n    func push(_ val: Int) {\n        \n    }\n    \n    func pop() {\n        \n    }\n    \n    func top() -> Int {\n        \n    }\n    \n    func getMin() -> Int {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * let obj = MinStack()\n * obj.push(val)\n * obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Int = obj.getMin()\n */"},{"Lang":"Rust","LangSlug":"rust","Code":"struct MinStack {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MinStack {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, val: i32) {\n        \n    }\n    \n    fn pop(&self) {\n        \n    }\n    \n    fn top(&self) -> i32 {\n        \n    }\n    \n    fn get_min(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * let obj = MinStack::new();\n * obj.push(val);\n * obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: i32 = obj.get_min();\n */"},{"Lang":"Ruby","LangSlug":"ruby","Code":"class MinStack\n    def initialize()\n        \n    end\n\n\n=begin\n    :type val: Integer\n    :rtype: Void\n=end\n    def push(val)\n        \n    end\n\n\n=begin\n    :rtype: Void\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def top()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_min()\n        \n    end\n\n\nend\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack.new()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.get_min()"},{"Lang":"PHP","LangSlug":"php","Code":"class MinStack {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $val\n     * @return NULL\n     */\n    function push($val) {\n        \n    }\n  \n    /**\n     * @return NULL\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function top() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function getMin() {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * $obj = MinStack();\n * $obj->push($val);\n * $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->getMin();\n */"},{"Lang":"Dart","LangSlug":"dart","Code":"class MinStack {\n\n  MinStack() {\n    \n  }\n  \n  void push(int val) {\n    \n  }\n  \n  void pop() {\n    \n  }\n  \n  int top() {\n    \n  }\n  \n  int getMin() {\n    \n  }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = MinStack();\n * obj.push(val);\n * obj.pop();\n * int param3 = obj.top();\n * int param4 = obj.getMin();\n */"},{"Lang":"Scala","LangSlug":"scala","Code":"class MinStack() {\n\n    def push(`val`: Int): Unit = {\n        \n    }\n\n    def pop(): Unit = {\n        \n    }\n\n    def top(): Int = {\n        \n    }\n\n    def getMin(): Int = {\n        \n    }\n\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * val obj = new MinStack()\n * obj.push(`val`)\n * obj.pop()\n * val param_3 = obj.top()\n * val param_4 = obj.getMin()\n */"},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule MinStack do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push(val :: integer) :: any\n  def push(val) do\n    \n  end\n\n  @spec pop() :: any\n  def pop() do\n    \n  end\n\n  @spec top() :: integer\n  def top() do\n    \n  end\n\n  @spec get_min() :: integer\n  def get_min() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MinStack.init_()\n# MinStack.push(val)\n# MinStack.pop()\n# param_3 = MinStack.top()\n# param_4 = MinStack.get_min()\n\n# MinStack.init_ will be called before every test case, in which you can do some necessary initializations."},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec min_stack_init_() -> any().\nmin_stack_init_() ->\n  .\n\n-spec min_stack_push(Val :: integer()) -> any().\nmin_stack_push(Val) ->\n  .\n\n-spec min_stack_pop() -> any().\nmin_stack_pop() ->\n  .\n\n-spec min_stack_top() -> integer().\nmin_stack_top() ->\n  .\n\n-spec min_stack_get_min() -> integer().\nmin_stack_get_min() ->\n  .\n\n\n%% Your functions will be called as such:\n%% min_stack_init_(),\n%% min_stack_push(Val),\n%% min_stack_pop(),\n%% Param_3 = min_stack_top(),\n%% Param_4 = min_stack_get_min(),\n\n%% min_stack_init_ will be called before every test case, in which you can do some necessary initializations."},{"Lang":"Racket","LangSlug":"racket","Code":"(define min-stack%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push val)\n      )\n    ; pop : -> void?\n    (define/public (pop)\n      )\n    ; top : -> exact-integer?\n    (define/public (top)\n      )\n    ; get-min : -> exact-integer?\n    (define/public (get-min)\n      )))\n\n;; Your min-stack% object will be instantiated and called as such:\n;; (define obj (new min-stack%))\n;; (send obj push val)\n;; (send obj pop)\n;; (define param_3 (send obj top))\n;; (define param_4 (send obj get-min))"}],"CompanyTagStats":""}},"DownloadedAt":"2025-11-17T15:29:14.221127+01:00","AcRate":"57.3","TotalSubmissions":4308870,"TotalAccepted":2467517,"AcceptanceRate":0.5726598853063565,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"multi","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"multi","python3":"multi","racket":"","ruby":"multi","rust":"","scala":"multi","swift":"","typescript":""},"Url":"https://leetcode.com/problems/min-stack/"},"Solutions":{"openai/gpt-5.1":{"Lang":"python3","Prompt":"Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\n\tMinStack() initializes the stack object.\n\tvoid push(int val) pushes the element val onto the stack.\n\tvoid pop() removes the element on the top of the stack.\n\tint top() gets the top element of the stack.\n\tint getMin() retrieves the minimum element in the stack.\nYou must implement a solution with O(1) time complexity for each function.\n \nExample 1:\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\nOutput\n[null,null,null,null,-3,null,0,-2]\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n \nConstraints:\n\t-2^31 <= val <= 2^31 - 1\n\tMethods pop, top and getMin operations will always be called on non-empty stacks.\n\tAt most 3 * 10^4 calls will be made to push, pop, top, and getMin.\n\nHere is the code snippet, which you should expand with your solution: class MinStack:\n\n    def __init__(self):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> None:\n        \n\n    def top(self) -> int:\n        \n\n    def getMin(self) -> int:\n        \n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n","Answer":"class MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = self.stack[-1][1]\n            self.stack.append((val, min(val, current_min)))\n\n    def pop(self) -> None:\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1][0]\n\n    def getMin(self) -> int:\n        return self.stack[-1][1]","TypedCode":"class MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = self.stack[-1][1]\n            self.stack.append((val, min(val, current_min)))\n\n    def pop(self) -> None:\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1][0]\n\n    def getMin(self) -> int:\n        return self.stack[-1][1]","Model":"openai/gpt-5.1","Latency":3999527792,"SolvedAt":"2025-11-19T10:28:55.96844+01:00","PromptTokens":572,"OutputTokens":230}},"Submissions":{"openai/gpt-5.1":{"SubmitRequest":{"lang":"python3","question_id":"155","typed_code":"class MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = self.stack[-1][1]\n            self.stack.append((val, min(val, current_min)))\n\n    def pop(self) -> None:\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1][0]\n\n    def getMin(self) -> int:\n        return self.stack[-1][1]"},"SubmissionId":1834110161,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-11-19T11:13:38.255533+01:00"}}}
