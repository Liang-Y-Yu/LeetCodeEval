{"Question":{"Data":{"Question":{"questionFrontendId":"823","questionId":"843","Content":"<p>Given an array of unique integers, <code>arr</code>, where each integer <code>arr[i]</code> is strictly greater than <code>1</code>.</p>\n\n<p>We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node&#39;s value should be equal to the product of the values of its children.</p>\n\n<p>Return <em>the number of binary trees we can make</em>. The answer may be too large so return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,4,5,10]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the values of <code>arr</code> are <strong>unique</strong>.</li>\n</ul>\n","SampleTestCase":"[2,4]","ExampleTestcases":"[2,4]\n[2,4,5,10]","Difficulty":"Medium","Title":"Binary Trees With Factors","TitleSlug":"binary-trees-with-factors","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"157.1K\", \"totalSubmission\": \"296.3K\", \"totalAcceptedRaw\": 157065, \"totalSubmissionRaw\": 296267, \"acRate\": \"53.0%\"}","Likes":3358,"Dislikes":260,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"},{"Id":"VG9waWNUYWdOb2RlOjYxMDQ5","Name":"Sorting","Slug":"sorting"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& arr) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int numFactoredBinaryTrees(int[] arr) {\n        \n    }\n}"},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        "},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def numFactoredBinaryTrees(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} arr\n * @return {number}\n */\nvar numFactoredBinaryTrees = function(arr) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function numFactoredBinaryTrees(arr: number[]): number {\n    \n};"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int NumFactoredBinaryTrees(int[] arr) {\n        \n    }\n}"},{"Lang":"C","LangSlug":"c","Code":"int numFactoredBinaryTrees(int* arr, int arrSize) {\n    \n}"},{"Lang":"Go","LangSlug":"golang","Code":"func numFactoredBinaryTrees(arr []int) int {\n    \n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun numFactoredBinaryTrees(arr: IntArray): Int {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func numFactoredBinaryTrees(_ arr: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} arr\n# @return {Integer}\ndef num_factored_binary_trees(arr)\n    \nend"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function numFactoredBinaryTrees($arr) {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int numFactoredBinaryTrees(List<int> arr) {\n    \n  }\n}"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def numFactoredBinaryTrees(arr: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec num_factored_binary_trees(arr :: [integer]) :: integer\n  def num_factored_binary_trees(arr) do\n    \n  end\nend"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec num_factored_binary_trees(Arr :: [integer()]) -> integer().\nnum_factored_binary_trees(Arr) ->\n  ."},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (num-factored-binary-trees arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )"}],"CompanyTagStats":""}},"DownloadedAt":"2025-11-17T14:57:39.817181+01:00","AcRate":"53.0","TotalSubmissions":296267,"TotalAccepted":157065,"AcceptanceRate":0.530146793264184,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/binary-trees-with-factors/"},"Solutions":{"openai/gpt-5.1":{"Lang":"python3","Prompt":"Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 10^9 + 7.\n \nExample 1:\nInput: arr = [2,4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: arr = [2,4,5,10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n \nConstraints:\n\t1 <= arr.length <= 1000\n\t2 <= arr[i] <= 10^9\n\tAll the values of arr are unique.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n","Answer":"from typing import List\n\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        n = len(arr)\n        index = {x: i for i, x in enumerate(arr)}\n        dp = [1] * n  # each number itself as a tree\n        \n        for i in range(n):\n            for j in range(i):\n                if arr[i] % arr[j] == 0:\n                    right = arr[i] // arr[j]\n                    if right in index:\n                        dp[i] = (dp[i] + dp[j] * dp[index[right]]) % MOD\n        \n        return sum(dp) % MOD","TypedCode":"from typing import List\n\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        n = len(arr)\n        index = {x: i for i, x in enumerate(arr)}\n        dp = [1] * n  # each number itself as a tree\n        \n        for i in range(n):\n            for j in range(i):\n                if arr[i] % arr[j] == 0:\n                    right = arr[i] // arr[j]\n                    if right in index:\n                        dp[i] = (dp[i] + dp[j] * dp[index[right]]) % MOD\n        \n        return sum(dp) % MOD","Model":"openai/gpt-5.1","Latency":21660042042,"SolvedAt":"2025-11-19T10:20:35.941923+01:00","PromptTokens":449,"OutputTokens":798}},"Submissions":{"openai/gpt-5.1":{"SubmitRequest":{"lang":"python3","question_id":"843","typed_code":"from typing import List\n\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        n = len(arr)\n        index = {x: i for i, x in enumerate(arr)}\n        dp = [1] * n  # each number itself as a tree\n        \n        for i in range(n):\n            for j in range(i):\n                if arr[i] % arr[j] == 0:\n                    right = arr[i] // arr[j]\n                    if right in index:\n                        dp[i] = (dp[i] + dp[j] * dp[index[right]]) % MOD\n        \n        return sum(dp) % MOD"},"SubmissionId":1834097654,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-11-19T10:56:26.180679+01:00"}}}
