{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1964",
        "questionId": "2096",
        "Content": "<p>You want to build some obstacle courses. You are given a <strong>0-indexed</strong> integer array <code>obstacles</code> of length <code>n</code>, where <code>obstacles[i]</code> describes the height of the <code>i<sup>th</sup></code> obstacle.</p>\n\n<p>For every index <code>i</code> between <code>0</code> and <code>n - 1</code> (<strong>inclusive</strong>), find the length of the <strong>longest obstacle course</strong> in <code>obstacles</code> such that:</p>\n\n<ul>\n\t<li>You choose any number of obstacles between <code>0</code> and <code>i</code> <strong>inclusive</strong>.</li>\n\t<li>You must include the <code>i<sup>th</sup></code> obstacle in the course.</li>\n\t<li>You must put the chosen obstacles in the <strong>same order</strong> as they appear in <code>obstacles</code>.</li>\n\t<li>Every obstacle (except the first) is <strong>taller</strong> than or the <strong>same height</strong> as the obstacle immediately before it.</li>\n</ul>\n\n<p>Return <em>an array</em> <code>ans</code> <em>of length</em> <code>n</code>, <em>where</em> <code>ans[i]</code> <em>is the length of the <strong>longest obstacle course</strong> for index</em> <code>i</code><em> as described above</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [1,2,3,2]\n<strong>Output:</strong> [1,2,3,3]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>1</u>], [1] has length 1.\n- i = 1: [<u>1</u>,<u>2</u>], [1,2] has length 2.\n- i = 2: [<u>1</u>,<u>2</u>,<u>3</u>], [1,2,3] has length 3.\n- i = 3: [<u>1</u>,<u>2</u>,3,<u>2</u>], [1,2,2] has length 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [2,2,1]\n<strong>Output:</strong> [1,2,1]\n<strong>Explanation: </strong>The longest valid obstacle course at each position is:\n- i = 0: [<u>2</u>], [2] has length 1.\n- i = 1: [<u>2</u>,<u>2</u>], [2,2] has length 2.\n- i = 2: [2,2,<u>1</u>], [1] has length 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [3,1,5,6,4,2]\n<strong>Output:</strong> [1,1,2,3,2,2]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>3</u>], [3] has length 1.\n- i = 1: [3,<u>1</u>], [1] has length 1.\n- i = 2: [<u>3</u>,1,<u>5</u>], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [<u>3</u>,1,<u>5</u>,<u>6</u>], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [<u>3</u>,1,5,6,<u>4</u>], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,<u>1</u>,5,6,4,<u>2</u>], [1,2] has length 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[1,2,3,2]",
        "ExampleTestcases": "[1,2,3,2]\n[2,2,1]\n[3,1,5,6,4,2]",
        "Difficulty": "Hard",
        "Title": "Find the Longest Valid Obstacle Course at Each Position",
        "TitleSlug": "find-the-longest-valid-obstacle-course-at-each-position",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"66.7K\", \"totalSubmission\": \"106.6K\", \"totalAcceptedRaw\": 66682, \"totalSubmissionRaw\": 106608, \"acRate\": \"62.5%\"}",
        "Likes": 1880,
        "Dislikes": 74,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI4",
            "Name": "Binary Indexed Tree",
            "Slug": "binary-indexed-tree"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nvar longestObstacleCourseAtEachPosition = function(obstacles) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function longestObstacleCourseAtEachPosition(obstacles: number[]): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] LongestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func longestObstacleCourseAtEachPosition(obstacles []int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun longestObstacleCourseAtEachPosition(obstacles: IntArray): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func longestObstacleCourseAtEachPosition(_ obstacles: [Int]) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn longest_obstacle_course_at_each_position(obstacles: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} obstacles\n# @return {Integer[]}\ndef longest_obstacle_course_at_each_position(obstacles)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $obstacles\n     * @return Integer[]\n     */\n    function longestObstacleCourseAtEachPosition($obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> longestObstacleCourseAtEachPosition(List<int> obstacles) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def longestObstacleCourseAtEachPosition(obstacles: Array[Int]): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec longest_obstacle_course_at_each_position(obstacles :: [integer]) :: [integer]\n  def longest_obstacle_course_at_each_position(obstacles) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec longest_obstacle_course_at_each_position(Obstacles :: [integer()]) -> [integer()].\nlongest_obstacle_course_at_each_position(Obstacles) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (longest-obstacle-course-at-each-position obstacles)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T13:56:35.847686+01:00",
    "AcRate": "62.5",
    "TotalSubmissions": 106608,
    "TotalAccepted": 66682,
    "AcceptanceRate": 0.6254877682725499,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the i^th obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\tYou choose any number of obstacles between 0 and i inclusive.\n\tYou must include the i^th obstacle in the course.\n\tYou must put the chosen obstacles in the same order as they appear in obstacles.\n\tEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n\u00a0\nExample 1:\nInput: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.\nExample 2:\nInput: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.\nExample 3:\nInput: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2.\n\u00a0\nConstraints:\n\tn == obstacles.length\n\t1 <= n <= 10^5\n\t1 <= obstacles[i] <= 10^7\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "Looking at this problem, I need to find the longest non-decreasing subsequence ending at each position.\n\nThis is a variant of the Longest Increasing Subsequence (LIS) problem, but with non-decreasing order (allowing equal values).\n\nThe key insight is to use a greedy approach with binary search:\n- Maintain an array `lis` where `lis[i]` represents the smallest ending value of all non-decreasing subsequences of length `i+1`\n- For each obstacle, find the rightmost position where we can place it (using binary search to find the rightmost element \u2264 current obstacle)\n- The answer for position i is the length of the subsequence we can form\n\nHere's my approach:\n1. Use binary search to find the position where the current obstacle should be placed in the `lis` array\n2. Since we want non-decreasing (allowing equals), we search for the rightmost position where we can insert the current value\n3. Update the `lis` array and record the length\n\n```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        lis = []\n        result = []\n        \n        for obstacle in obstacles:\n            pos = bisect.bisect_right(lis, obstacle)\n            \n            if pos == len(lis):\n                lis.append(obstacle)\n            else:\n                lis[pos] = obstacle\n            \n            result.append(pos + 1)\n        \n        return result\n```\n\nWait, let me trace through Example 1 to verify:\n- obstacles = [1,2,3,2]\n- i=0: obstacle=1, lis=[], pos=0, lis=[1], result=[1] \u2713\n- i=1: obstacle=2, lis=[1], pos=1, lis=[1,2], result=[1,2] \u2713\n- i=2: obstacle=3, lis=[1,2], pos=2, lis=[1,2,3], result=[1,2,3] \u2713\n- i=3: obstacle=2, lis=[1,2,3], pos=2 (bisect_right finds position after 2), lis=[1,2,2], result=[1,2,3,3] \u2713\n\nLet me verify Example 3:\n- obstacles = [3,1,5,6,4,2]\n- i=0: obstacle=3, lis=[], pos=0, lis=[3], result=[1] \u2713\n- i=1: obstacle=1, lis=[3], pos=0, lis=[1], result=[1,1] \u2713\n- i=2: obstacle=5, lis=[1], pos=1, lis=[1,5], result=[1,1,2] \u2713\n- i=3: obstacle=6, lis=[1,5], pos=2, lis=[1,5,6], result=[1,1,2,3] \u2713\n- i=4: obstacle=4, lis=[1,5,6], pos=1, lis=[1,4,6], result=[1,1,2,3,2] \u2713\n- i=5: obstacle=2, lis=[1,4,6], pos=1, lis=[1,2,6], result=[1,1,2,3,2,2] \u2713\n\nPerfect! The solution works correctly.\n\n```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        lis = []\n        result = []\n        \n        for obstacle in obstacles:\n            pos = bisect.bisect_right(lis, obstacle)\n            \n            if pos == len(lis):\n                lis.append(obstacle)\n            else:\n                lis[pos] = obstacle\n            \n            result.append(pos + 1)\n        \n        return result\n```",
      "TypedCode": "\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        lis = []\n        result = []\n        \n        for obstacle in obstacles:\n            pos = bisect.bisect_right(lis, obstacle)\n            \n            if pos == len(lis):\n                lis.append(obstacle)\n            else:\n                lis[pos] = obstacle\n            \n            result.append(pos + 1)\n        \n        return result\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 12012311000,
      "SolvedAt": "2025-11-19T21:40:16.561284+01:00",
      "PromptTokens": 923,
      "OutputTokens": 967
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "2096",
        "typed_code": "\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        lis = []\n        result = []\n        \n        for obstacle in obstacles:\n            pos = bisect.bisect_right(lis, obstacle)\n            \n            if pos == len(lis):\n                lis.append(obstacle)\n            else:\n                lis[pos] = obstacle\n            \n            result.append(pos + 1)\n        \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-19T22:43:15+01:00"
    }
  }
}