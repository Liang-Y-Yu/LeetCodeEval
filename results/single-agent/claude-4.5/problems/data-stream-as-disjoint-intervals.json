{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "352",
        "questionId": "352",
        "Content": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n",
        "SampleTestCase": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "ExampleTestcases": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "Difficulty": "Hard",
        "Title": "Data Stream as Disjoint Intervals",
        "TitleSlug": "data-stream-as-disjoint-intervals",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"125.3K\", \"totalSubmission\": \"209.8K\", \"totalAcceptedRaw\": 125278, \"totalSubmissionRaw\": 209830, \"acRate\": \"59.7%\"}",
        "Likes": 1795,
        "Dislikes": 371,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIz",
            "Name": "Union Find",
            "Slug": "union-find"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcw",
            "Name": "Ordered Set",
            "Slug": "ordered-set"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class SummaryRanges {\npublic:\n    SummaryRanges() {\n        \n    }\n    \n    void addNum(int value) {\n        \n    }\n    \n    vector<vector<int>> getIntervals() {\n        \n    }\n};\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges* obj = new SummaryRanges();\n * obj->addNum(value);\n * vector<vector<int>> param_2 = obj->getIntervals();\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void addNum(int value) {\n        \n    }\n    \n    public int[][] getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(value);\n * int[][] param_2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class SummaryRanges(object):\n\n    def __init__(self):\n        \n\n    def addNum(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getIntervals(self):\n        \"\"\"\n        :rtype: List[List[int]]\n        \"\"\"\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar SummaryRanges = function() {\n    \n};\n\n/** \n * @param {number} value\n * @return {void}\n */\nSummaryRanges.prototype.addNum = function(value) {\n    \n};\n\n/**\n * @return {number[][]}\n */\nSummaryRanges.prototype.getIntervals = function() {\n    \n};\n\n/** \n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class SummaryRanges {\n    constructor() {\n        \n    }\n\n    addNum(value: number): void {\n        \n    }\n\n    getIntervals(): number[][] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void AddNum(int value) {\n        \n    }\n    \n    public int[][] GetIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.AddNum(value);\n * int[][] param_2 = obj.GetIntervals();\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} SummaryRanges;\n\n\nSummaryRanges* summaryRangesCreate() {\n    \n}\n\nvoid summaryRangesAddNum(SummaryRanges* obj, int value) {\n    \n}\n\nint** summaryRangesGetIntervals(SummaryRanges* obj, int* retSize, int** retColSize) {\n    \n}\n\nvoid summaryRangesFree(SummaryRanges* obj) {\n    \n}\n\n/**\n * Your SummaryRanges struct will be instantiated and called as such:\n * SummaryRanges* obj = summaryRangesCreate();\n * summaryRangesAddNum(obj, value);\n \n * int** param_2 = summaryRangesGetIntervals(obj, retSize, retColSize);\n \n * summaryRangesFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type SummaryRanges struct {\n    \n}\n\n\nfunc Constructor() SummaryRanges {\n    \n}\n\n\nfunc (this *SummaryRanges) AddNum(value int)  {\n    \n}\n\n\nfunc (this *SummaryRanges) GetIntervals() [][]int {\n    \n}\n\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddNum(value);\n * param_2 := obj.GetIntervals();\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class SummaryRanges() {\n\n    fun addNum(value: Int) {\n        \n    }\n\n    fun getIntervals(): Array<IntArray> {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass SummaryRanges {\n\n    init() {\n        \n    }\n    \n    func addNum(_ value: Int) {\n        \n    }\n    \n    func getIntervals() -> [[Int]] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges()\n * obj.addNum(value)\n * let ret_2: [[Int]] = obj.getIntervals()\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct SummaryRanges {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SummaryRanges {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add_num(&self, value: i32) {\n        \n    }\n    \n    fn get_intervals(&self) -> Vec<Vec<i32>> {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges::new();\n * obj.add_num(value);\n * let ret_2: Vec<Vec<i32>> = obj.get_intervals();\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class SummaryRanges\n    def initialize()\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Void\n=end\n    def add_num(value)\n        \n    end\n\n\n=begin\n    :rtype: Integer[][]\n=end\n    def get_intervals()\n        \n    end\n\n\nend\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges.new()\n# obj.add_num(value)\n# param_2 = obj.get_intervals()"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class SummaryRanges {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return NULL\n     */\n    function addNum($value) {\n        \n    }\n  \n    /**\n     * @return Integer[][]\n     */\n    function getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * $obj = SummaryRanges();\n * $obj->addNum($value);\n * $ret_2 = $obj->getIntervals();\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class SummaryRanges {\n\n  SummaryRanges() {\n    \n  }\n  \n  void addNum(int value) {\n    \n  }\n  \n  List<List<int>> getIntervals() {\n    \n  }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = SummaryRanges();\n * obj.addNum(value);\n * List<List<int>> param2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class SummaryRanges() {\n\n    def addNum(value: Int): Unit = {\n        \n    }\n\n    def getIntervals(): Array[Array[Int]] = {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * val obj = new SummaryRanges()\n * obj.addNum(value)\n * val param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule SummaryRanges do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add_num(value :: integer) :: any\n  def add_num(value) do\n    \n  end\n\n  @spec get_intervals() :: [[integer]]\n  def get_intervals() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SummaryRanges.init_()\n# SummaryRanges.add_num(value)\n# param_2 = SummaryRanges.get_intervals()\n\n# SummaryRanges.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec summary_ranges_init_() -> any().\nsummary_ranges_init_() ->\n  .\n\n-spec summary_ranges_add_num(Value :: integer()) -> any().\nsummary_ranges_add_num(Value) ->\n  .\n\n-spec summary_ranges_get_intervals() -> [[integer()]].\nsummary_ranges_get_intervals() ->\n  .\n\n\n%% Your functions will be called as such:\n%% summary_ranges_init_(),\n%% summary_ranges_add_num(Value),\n%% Param_2 = summary_ranges_get_intervals(),\n\n%% summary_ranges_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define summary-ranges%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add-num : exact-integer? -> void?\n    (define/public (add-num value)\n      )\n    ; get-intervals : -> (listof (listof exact-integer?))\n    (define/public (get-intervals)\n      )))\n\n;; Your summary-ranges% object will be instantiated and called as such:\n;; (define obj (new summary-ranges%))\n;; (send obj add-num value)\n;; (define param_2 (send obj get-intervals))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:21:39.253726+01:00",
    "AcRate": "59.7",
    "TotalSubmissions": 209830,
    "TotalAccepted": 125278,
    "AcceptanceRate": 0.5970452270885955,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "multi",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\nImplement the SummaryRanges class:\n\tSummaryRanges() Initializes the object with an empty stream.\n\tvoid addNum(int value) Adds the integer value to the stream.\n\tint[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n\u00a0\nExample 1:\nInput\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\nOutput\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\nExplanation\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n\u00a0\nConstraints:\n\t0 <= value <= 10^4\n\tAt most 3 * 10^4 calls will be made to addNum and getIntervals.\n\tAt most 10^2\u00a0calls will be made to\u00a0getIntervals.\n\u00a0\nFollow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?\n\nHere is the code snippet, which you should expand with your solution: class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()\n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "Looking at this problem, I need to maintain a collection of disjoint intervals and efficiently handle:\n1. Adding new numbers\n2. Merging intervals when numbers fill gaps\n3. Returning sorted intervals\n\nI'll use a sorted list approach where I maintain intervals in sorted order and handle merging when adding new numbers.\n\n```python\nfrom typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        left, right = 0, len(self.intervals) - 1\n        insert_pos = len(self.intervals)\n        \n        for i in range(len(self.intervals)):\n            if value >= self.intervals[i][0] - 1 and value <= self.intervals[i][1] + 1:\n                insert_pos = i\n                break\n            elif value < self.intervals[i][0] - 1:\n                insert_pos = i\n                break\n        \n        if insert_pos < len(self.intervals):\n            interval = self.intervals[insert_pos]\n            if value >= interval[0] and value <= interval[1]:\n                return\n            elif value == interval[0] - 1:\n                interval[0] = value\n                if insert_pos > 0 and self.intervals[insert_pos - 1][1] == value - 1:\n                    self.intervals[insert_pos - 1][1] = interval[1]\n                    self.intervals.pop(insert_pos)\n                return\n            elif value == interval[1] + 1:\n                interval[1] = value\n                if insert_pos + 1 < len(self.intervals) and self.intervals[insert_pos + 1][0] == value + 1:\n                    interval[1] = self.intervals[insert_pos + 1][1]\n                    self.intervals.pop(insert_pos + 1)\n                return\n            else:\n                self.intervals.insert(insert_pos, [value, value])\n                return\n        else:\n            if self.intervals[-1][1] == value - 1:\n                self.intervals[-1][1] = value\n            elif value > self.intervals[-1][1]:\n                self.intervals.append([value, value])\n            return\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n```",
      "TypedCode": "\nfrom typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        left, right = 0, len(self.intervals) - 1\n        insert_pos = len(self.intervals)\n        \n        for i in range(len(self.intervals)):\n            if value >= self.intervals[i][0] - 1 and value <= self.intervals[i][1] + 1:\n                insert_pos = i\n                break\n            elif value < self.intervals[i][0] - 1:\n                insert_pos = i\n                break\n        \n        if insert_pos < len(self.intervals):\n            interval = self.intervals[insert_pos]\n            if value >= interval[0] and value <= interval[1]:\n                return\n            elif value == interval[0] - 1:\n                interval[0] = value\n                if insert_pos > 0 and self.intervals[insert_pos - 1][1] == value - 1:\n                    self.intervals[insert_pos - 1][1] = interval[1]\n                    self.intervals.pop(insert_pos)\n                return\n            elif value == interval[1] + 1:\n                interval[1] = value\n                if insert_pos + 1 < len(self.intervals) and self.intervals[insert_pos + 1][0] == value + 1:\n                    interval[1] = self.intervals[insert_pos + 1][1]\n                    self.intervals.pop(insert_pos + 1)\n                return\n            else:\n                self.intervals.insert(insert_pos, [value, value])\n                return\n        else:\n            if self.intervals[-1][1] == value - 1:\n                self.intervals[-1][1] = value\n            elif value > self.intervals[-1][1]:\n                self.intervals.append([value, value])\n            return\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 8551875166,
      "SolvedAt": "2025-11-19T21:38:45.242669+01:00",
      "PromptTokens": 971,
      "OutputTokens": 599
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "352",
        "typed_code": "\nfrom typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        left, right = 0, len(self.intervals) - 1\n        insert_pos = len(self.intervals)\n        \n        for i in range(len(self.intervals)):\n            if value >= self.intervals[i][0] - 1 and value <= self.intervals[i][1] + 1:\n                insert_pos = i\n                break\n            elif value < self.intervals[i][0] - 1:\n                insert_pos = i\n                break\n        \n        if insert_pos < len(self.intervals):\n            interval = self.intervals[insert_pos]\n            if value >= interval[0] and value <= interval[1]:\n                return\n            elif value == interval[0] - 1:\n                interval[0] = value\n                if insert_pos > 0 and self.intervals[insert_pos - 1][1] == value - 1:\n                    self.intervals[insert_pos - 1][1] = interval[1]\n                    self.intervals.pop(insert_pos)\n                return\n            elif value == interval[1] + 1:\n                interval[1] = value\n                if insert_pos + 1 < len(self.intervals) and self.intervals[insert_pos + 1][0] == value + 1:\n                    interval[1] = self.intervals[insert_pos + 1][1]\n                    self.intervals.pop(insert_pos + 1)\n                return\n            else:\n                self.intervals.insert(insert_pos, [value, value])\n                return\n        else:\n            if self.intervals[-1][1] == value - 1:\n                self.intervals[-1][1] = value\n            elif value > self.intervals[-1][1]:\n                self.intervals.append([value, value])\n            return\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-19T22:57:38+01:00"
    }
  }
}