{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "210",
        "questionId": "210",
        "Content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n",
        "SampleTestCase": "2\n[[1,0]]",
        "ExampleTestcases": "2\n[[1,0]]\n4\n[[1,0],[2,0],[3,1],[3,2]]\n1\n[]",
        "Difficulty": "Medium",
        "Title": "Course Schedule II",
        "TitleSlug": "course-schedule-ii",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"2.8M\", \"totalAcceptedRaw\": 1549471, \"totalSubmissionRaw\": 2845434, \"acRate\": \"54.5%\"}",
        "Likes": 11718,
        "Dislikes": 374,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjIx",
            "Name": "Depth-First Search",
            "Slug": "depth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIy",
            "Name": "Breadth-First Search",
            "Slug": "breadth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI0",
            "Name": "Graph",
            "Slug": "graph"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI2",
            "Name": "Topological Sort",
            "Slug": "topological-sort"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findOrder(numCourses int, prerequisites [][]int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer} num_courses\n# @param {Integer[][]} prerequisites\n# @return {Integer[]}\ndef find_order(num_courses, prerequisites)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer $numCourses\n     * @param Integer[][] $prerequisites\n     * @return Integer[]\n     */\n    function findOrder($numCourses, $prerequisites) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> findOrder(int numCourses, List<List<int>> prerequisites) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_order(num_courses :: integer, prerequisites :: [[integer]]) :: [integer]\n  def find_order(num_courses, prerequisites) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_order(NumCourses :: integer(), Prerequisites :: [[integer()]]) -> [integer()].\nfind_order(NumCourses, Prerequisites) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-order numCourses prerequisites)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:27:26.807907+01:00",
    "AcRate": "54.5",
    "TotalSubmissions": 2845434,
    "TotalAccepted": 1549471,
    "AcceptanceRate": 0.5445464558306395,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/course-schedule-ii/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\u00a0\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\u00a0\nConstraints:\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "Looking at this problem, I need to find a valid ordering of courses given prerequisites. This is a classic topological sort problem on a directed graph.\n\nThe approach:\n1. Build a graph where edges represent prerequisites\n2. Use Kahn's algorithm (BFS-based topological sort) with in-degree counting\n3. If we can process all courses, return the ordering; otherwise return empty array (cycle detected)\n\nLet me trace through Example 2:\n- numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n- Graph: 0\u21921, 0\u21922, 1\u21923, 2\u21923\n- In-degrees: [0, 1, 1, 2]\n- Start with course 0 (in-degree 0)\n- Process 0, add 1 and 2 to queue\n- Process 1 or 2, eventually process 3\n- Result: [0,1,2,3] or [0,2,1,3]\n\n```python\nfrom typing import List\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        result = []\n        \n        while queue:\n            course = queue.popleft()\n            result.append(course)\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n```",
      "TypedCode": "\nfrom typing import List\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        result = []\n        \n        while queue:\n            course = queue.popleft()\n            result.append(course)\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 7488943875,
      "SolvedAt": "2025-11-19T21:38:28.956007+01:00",
      "PromptTokens": 685,
      "OutputTokens": 501
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "210",
        "typed_code": "\nfrom typing import List\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n        \n        queue = deque()\n        for i in range(numCourses):\n            if in_degree[i] == 0:\n                queue.append(i)\n        \n        result = []\n        \n        while queue:\n            course = queue.popleft()\n            result.append(course)\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-19T22:18:26+01:00"
    }
  }
}