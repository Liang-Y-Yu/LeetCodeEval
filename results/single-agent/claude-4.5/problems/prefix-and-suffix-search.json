{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "745",
        "questionId": "746",
        "Content": "<p>Design a special dictionary that searches the words in it by a prefix and a suffix.</p>\n\n<p>Implement the <code>WordFilter</code> class:</p>\n\n<ul>\n\t<li><code>WordFilter(string[] words)</code> Initializes the object with the <code>words</code> in the dictionary.</li>\n\t<li><code>f(string pref, string suff)</code> Returns <em>the index of the word in the dictionary,</em> which has the prefix <code>pref</code> and the suffix <code>suff</code>. If there is more than one valid index, return <strong>the largest</strong> of them. If there is no such word in the dictionary, return <code>-1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;WordFilter&quot;, &quot;f&quot;]\n[[[&quot;apple&quot;]], [&quot;a&quot;, &quot;e&quot;]]\n<strong>Output</strong>\n[null, 0]\n<strong>Explanation</strong>\nWordFilter wordFilter = new WordFilter([&quot;apple&quot;]);\nwordFilter.f(&quot;a&quot;, &quot;e&quot;); // return 0, because the word at index 0 has prefix = &quot;a&quot; and suffix = &quot;e&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>\n\t<li><code>words[i]</code>, <code>pref</code> and <code>suff</code> consist of lowercase English letters only.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to the function <code>f</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"WordFilter\",\"f\"]\n[[[\"apple\"]],[\"a\",\"e\"]]",
        "ExampleTestcases": "[\"WordFilter\",\"f\"]\n[[[\"apple\"]],[\"a\",\"e\"]]",
        "Difficulty": "Hard",
        "Title": "Prefix and Suffix Search",
        "TitleSlug": "prefix-and-suffix-search",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"107.5K\", \"totalSubmission\": \"264.6K\", \"totalAcceptedRaw\": 107470, \"totalSubmissionRaw\": 264587, \"acRate\": \"40.6%\"}",
        "Likes": 2334,
        "Dislikes": 498,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI3",
            "Name": "Trie",
            "Slug": "trie"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class WordFilter {\npublic:\n    WordFilter(vector<string>& words) {\n        \n    }\n    \n    int f(string pref, string suff) {\n        \n    }\n};\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * WordFilter* obj = new WordFilter(words);\n * int param_1 = obj->f(pref,suff);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class WordFilter {\n\n    public WordFilter(String[] words) {\n        \n    }\n    \n    public int f(String pref, String suff) {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * WordFilter obj = new WordFilter(words);\n * int param_1 = obj.f(pref,suff);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class WordFilter:\n\n    def __init__(self, words: List[str]):\n        \n\n    def f(self, pref: str, suff: str) -> int:\n        \n\n\n# Your WordFilter object will be instantiated and called as such:\n# obj = WordFilter(words)\n# param_1 = obj.f(pref,suff)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class WordFilter(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        \n\n    def f(self, pref, suff):\n        \"\"\"\n        :type pref: str\n        :type suff: str\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your WordFilter object will be instantiated and called as such:\n# obj = WordFilter(words)\n# param_1 = obj.f(pref,suff)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string[]} words\n */\nvar WordFilter = function(words) {\n    \n};\n\n/** \n * @param {string} pref \n * @param {string} suff\n * @return {number}\n */\nWordFilter.prototype.f = function(pref, suff) {\n    \n};\n\n/** \n * Your WordFilter object will be instantiated and called as such:\n * var obj = new WordFilter(words)\n * var param_1 = obj.f(pref,suff)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class WordFilter {\n    constructor(words: string[]) {\n        \n    }\n\n    f(pref: string, suff: string): number {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * var obj = new WordFilter(words)\n * var param_1 = obj.f(pref,suff)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class WordFilter {\n\n    public WordFilter(string[] words) {\n        \n    }\n    \n    public int F(string pref, string suff) {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * WordFilter obj = new WordFilter(words);\n * int param_1 = obj.F(pref,suff);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} WordFilter;\n\n\nWordFilter* wordFilterCreate(char** words, int wordsSize) {\n    \n}\n\nint wordFilterF(WordFilter* obj, char* pref, char* suff) {\n    \n}\n\nvoid wordFilterFree(WordFilter* obj) {\n    \n}\n\n/**\n * Your WordFilter struct will be instantiated and called as such:\n * WordFilter* obj = wordFilterCreate(words, wordsSize);\n * int param_1 = wordFilterF(obj, pref, suff);\n \n * wordFilterFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type WordFilter struct {\n    \n}\n\n\nfunc Constructor(words []string) WordFilter {\n    \n}\n\n\nfunc (this *WordFilter) F(pref string, suff string) int {\n    \n}\n\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * obj := Constructor(words);\n * param_1 := obj.F(pref,suff);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class WordFilter(words: Array<String>) {\n\n    fun f(pref: String, suff: String): Int {\n        \n    }\n\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * var obj = WordFilter(words)\n * var param_1 = obj.f(pref,suff)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass WordFilter {\n\n    init(_ words: [String]) {\n        \n    }\n    \n    func f(_ pref: String, _ suff: String) -> Int {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * let obj = WordFilter(words)\n * let ret_1: Int = obj.f(pref, suff)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct WordFilter {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl WordFilter {\n\n    fn new(words: Vec<String>) -> Self {\n        \n    }\n    \n    fn f(&self, pref: String, suff: String) -> i32 {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * let obj = WordFilter::new(words);\n * let ret_1: i32 = obj.f(pref, suff);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class WordFilter\n\n=begin\n    :type words: String[]\n=end\n    def initialize(words)\n        \n    end\n\n\n=begin\n    :type pref: String\n    :type suff: String\n    :rtype: Integer\n=end\n    def f(pref, suff)\n        \n    end\n\n\nend\n\n# Your WordFilter object will be instantiated and called as such:\n# obj = WordFilter.new(words)\n# param_1 = obj.f(pref, suff)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class WordFilter {\n    /**\n     * @param String[] $words\n     */\n    function __construct($words) {\n        \n    }\n  \n    /**\n     * @param String $pref\n     * @param String $suff\n     * @return Integer\n     */\n    function f($pref, $suff) {\n        \n    }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * $obj = WordFilter($words);\n * $ret_1 = $obj->f($pref, $suff);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class WordFilter {\n\n  WordFilter(List<String> words) {\n    \n  }\n  \n  int f(String pref, String suff) {\n    \n  }\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * WordFilter obj = WordFilter(words);\n * int param1 = obj.f(pref,suff);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class WordFilter(_words: Array[String]) {\n\n    def f(pref: String, suff: String): Int = {\n        \n    }\n\n}\n\n/**\n * Your WordFilter object will be instantiated and called as such:\n * val obj = new WordFilter(words)\n * val param_1 = obj.f(pref,suff)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule WordFilter do\n  @spec init_(words :: [String.t]) :: any\n  def init_(words) do\n    \n  end\n\n  @spec f(pref :: String.t, suff :: String.t) :: integer\n  def f(pref, suff) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# WordFilter.init_(words)\n# param_1 = WordFilter.f(pref, suff)\n\n# WordFilter.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec word_filter_init_(Words :: [unicode:unicode_binary()]) -> any().\nword_filter_init_(Words) ->\n  .\n\n-spec word_filter_f(Pref :: unicode:unicode_binary(), Suff :: unicode:unicode_binary()) -> integer().\nword_filter_f(Pref, Suff) ->\n  .\n\n\n%% Your functions will be called as such:\n%% word_filter_init_(Words),\n%% Param_1 = word_filter_f(Pref, Suff),\n\n%% word_filter_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define word-filter%\n  (class object%\n    (super-new)\n    \n    ; words : (listof string?)\n    (init-field\n      words)\n    \n    ; f : string? string? -> exact-integer?\n    (define/public (f pref suff)\n      )))\n\n;; Your word-filter% object will be instantiated and called as such:\n;; (define obj (new word-filter% [words words]))\n;; (define param_1 (send obj f pref suff))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:03:22.53053+01:00",
    "AcRate": "40.6",
    "TotalSubmissions": 264587,
    "TotalAccepted": 107470,
    "AcceptanceRate": 0.406180197817731,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/prefix-and-suffix-search/"
  },
  "Solutions": {
    "anthropic/claude-sonnet-4.5": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Design a special dictionary that searches the words in it by a prefix and a suffix.\nImplement the WordFilter class:\n\tWordFilter(string[] words) Initializes the object with the words in the dictionary.\n\tf(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.\n\u00a0\nExample 1:\nInput\n[\"WordFilter\", \"f\"]\n[[[\"apple\"]], [\"a\", \"e\"]]\nOutput\n[null, 0]\nExplanation\nWordFilter wordFilter = new WordFilter([\"apple\"]);\nwordFilter.f(\"a\", \"e\"); // return 0, because the word at index 0 has prefix = \"a\" and suffix = \"e\".\n\u00a0\nConstraints:\n\t1 <= words.length <= 10^4\n\t1 <= words[i].length <= 7\n\t1 <= pref.length, suff.length <= 7\n\twords[i], pref and suff consist of lowercase English letters only.\n\tAt most 10^4 calls will be made to the function f.\n\nHere is the code snippet, which you should expand with your solution: class WordFilter:\n\n    def __init__(self, words: List[str]):\n        \n\n    def f(self, pref: str, suff: str) -> int:\n        \n\n\n# Your WordFilter object will be instantiated and called as such:\n# obj = WordFilter(words)\n# param_1 = obj.f(pref,suff)\n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "Looking at this problem, I need to efficiently search for words by both prefix and suffix, returning the largest index when multiple matches exist.\n\nLet me think through the approach:\n1. We need to handle prefix and suffix matching simultaneously\n2. We want the largest index when there are multiple matches\n3. With constraints (words \u2264 10^4, length \u2264 7, calls \u2264 10^4), we need an efficient solution\n\nThe key insight is to use a trie-like structure or a hash map that stores combinations of prefixes and suffixes. Since word lengths are small (\u2264 7), we can precompute all possible prefix-suffix combinations for each word.\n\nA clever approach is to create a combined key format: for each word, we generate keys like `suffix#prefix` for all possible suffix-prefix combinations. This way, when querying with a prefix and suffix, we just need to look up `suff#pref`.\n\nHowever, an even better approach is to store all combinations of `suffix#word` format in a trie or map, where we can match against `suff#pref`.\n\nLet me implement using a dictionary that maps each `(prefix, suffix)` pair to the largest index:\n\n```python\nfrom typing import List\n\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.prefix_suffix_map = {}\n        \n        for index, word in enumerate(words):\n            word_len = len(word)\n            for i in range(word_len + 1):\n                prefix = word[:i]\n                for j in range(word_len + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    self.prefix_suffix_map[key] = index\n\n    def f(self, pref: str, suff: str) -> int:\n        key = (pref, suff)\n        return self.prefix_suffix_map.get(key, -1)\n```\n\nWait, this approach stores all combinations but since we iterate through words in order and always update the map, the last (largest) index will be stored for each prefix-suffix combination. This works perfectly!\n\nLet me verify with the example:\n- Word \"apple\" at index 0\n- Prefixes: \"\", \"a\", \"ap\", \"app\", \"appl\", \"apple\"\n- Suffixes: \"\", \"e\", \"le\", \"ple\", \"pple\", \"apple\"\n- For prefix=\"a\" and suffix=\"e\", the key (\"a\", \"e\") maps to index 0\n- f(\"a\", \"e\") returns 0 \u2713\n\nThe solution handles all cases correctly and since word length is at most 7, each word generates at most 8*8=64 entries, which is manageable.\n\n```python\nfrom typing import List\n\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.prefix_suffix_map = {}\n        \n        for index, word in enumerate(words):\n            word_len = len(word)\n            for i in range(word_len + 1):\n                prefix = word[:i]\n                for j in range(word_len + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    self.prefix_suffix_map[key] = index\n\n    def f(self, pref: str, suff: str) -> int:\n        key = (pref, suff)\n        return self.prefix_suffix_map.get(key, -1)\n```",
      "TypedCode": "\nfrom typing import List\n\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.prefix_suffix_map = {}\n        \n        for index, word in enumerate(words):\n            word_len = len(word)\n            for i in range(word_len + 1):\n                prefix = word[:i]\n                for j in range(word_len + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    self.prefix_suffix_map[key] = index\n\n    def f(self, pref: str, suff: str) -> int:\n        key = (pref, suff)\n        return self.prefix_suffix_map.get(key, -1)\n",
      "Model": "anthropic/claude-sonnet-4.5",
      "Latency": 15248443792,
      "SolvedAt": "2025-11-19T21:50:35.099947+01:00",
      "PromptTokens": 576,
      "OutputTokens": 823
    }
  },
  "Submissions": {
    "anthropic/claude-sonnet-4.5": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "746",
        "typed_code": "\nfrom typing import List\n\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.prefix_suffix_map = {}\n        \n        for index, word in enumerate(words):\n            word_len = len(word)\n            for i in range(word_len + 1):\n                prefix = word[:i]\n                for j in range(word_len + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    self.prefix_suffix_map[key] = index\n\n    def f(self, pref: str, suff: str) -> int:\n        key = (pref, suff)\n        return self.prefix_suffix_map.get(key, -1)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-19T22:11:25+01:00"
    }
  }
}