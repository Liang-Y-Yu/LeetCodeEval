{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "2300",
        "questionId": "2392",
        "Content": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>\n\n<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>\n\n<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<strong>Output:</strong> [4,0,3]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.\nThus, [4,0,3] is returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16\n<strong>Output:</strong> [2,0,2]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[5,1,3]\n[1,2,3,4,5]\n7",
        "ExampleTestcases": "[5,1,3]\n[1,2,3,4,5]\n7\n[3,1,2]\n[8,5,8]\n16",
        "Difficulty": "Medium",
        "Title": "Successful Pairs of Spells and Potions",
        "TitleSlug": "successful-pairs-of-spells-and-potions",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"362.7K\", \"totalSubmission\": \"736.4K\", \"totalAcceptedRaw\": 362706, \"totalSubmissionRaw\": 736363, \"acRate\": \"49.3%\"}",
        "Likes": 3151,
        "Dislikes": 104,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjk=",
            "Name": "Two Pointers",
            "Slug": "two-pointers"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def successfulPairs(self, spells, potions, success):\n        \"\"\"\n        :type spells: List[int]\n        :type potions: List[int]\n        :type success: int\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} spells\n * @param {number[]} potions\n * @param {number} success\n * @return {number[]}\n */\nvar successfulPairs = function(spells, potions, success) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function successfulPairs(spells: number[], potions: number[], success: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func successfulPairs(spells []int, potions []int, success int64) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun successfulPairs(spells: IntArray, potions: IntArray, success: Long): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn successful_pairs(spells: Vec<i32>, potions: Vec<i32>, success: i64) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} spells\n# @param {Integer[]} potions\n# @param {Integer} success\n# @return {Integer[]}\ndef successful_pairs(spells, potions, success)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $spells\n     * @param Integer[] $potions\n     * @param Integer $success\n     * @return Integer[]\n     */\n    function successfulPairs($spells, $potions, $success) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> successfulPairs(List<int> spells, List<int> potions, int success) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def successfulPairs(spells: Array[Int], potions: Array[Int], success: Long): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec successful_pairs(spells :: [integer], potions :: [integer], success :: integer) :: [integer]\n  def successful_pairs(spells, potions, success) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec successful_pairs(Spells :: [integer()], Potions :: [integer()], Success :: integer()) -> [integer()].\nsuccessful_pairs(Spells, Potions, Success) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (successful-pairs spells potions success)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T13:40:29.830982+01:00",
    "AcRate": "49.3",
    "TotalSubmissions": 736363,
    "TotalAccepted": 362706,
    "AcceptanceRate": 0.4925641293764081,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/successful-pairs-of-spells-and-potions/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the i^th spell and potions[j] represents the strength of the j^th potion.\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the i^th spell.\n\u00a0\nExample 1:\nInput: spells = [5,1,3], potions = [1,2,3,4,5], success = 7\nOutput: [4,0,3]\nExplanation:\n- 0^th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.\n- 1^st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2^nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.\nThus, [4,0,3] is returned.\nExample 2:\nInput: spells = [3,1,2], potions = [8,5,8], success = 16\nOutput: [2,0,2]\nExplanation:\n- 0^th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.\n- 1^st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2^nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n\u00a0\nConstraints:\n\tn == spells.length\n\tm == potions.length\n\t1 <= n, m <= 10^5\n\t1 <= spells[i], potions[i] <= 10^5\n\t1 <= success <= 10^10\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient approach to this problem is to leverage binary search.\n\nThe core of the problem is, for each spell `s`, to find the number of potions `p` such that `s * p >= success`. This inequality can be rearranged to `p >= success / s`. Since potion strengths are integers, we are looking for the number of potions whose strength is at least `ceil(success / s)`.\n\nA naive O(n * m) solution, which iterates through every spell-potion pair, would be too slow given the constraints.\nInstead, we can significantly speed up the process of counting suitable potions for each spell.\n\nHere's the optimized strategy:\n1.  **Sort the `potions` array.** This allows us to use binary search. Sorting takes O(m log m) time.\n2.  **Iterate through each spell.** For each `spell` in the `spells` array:\n    a.  Calculate the minimum required potion strength. This is `ceil(success / spell)`. Using integer arithmetic, this can be calculated as `(success + spell - 1) // spell` to avoid floating-point inaccuracies.\n    b.  Use binary search on the sorted `potions` array to find the index of the first potion whose strength is greater than or equal to this minimum requirement. Python's `bisect.bisect_left` is perfect for this task. This step takes O(log m) time.\n    c.  Once this index is found, all potions from this index to the end of the array will also be successful partners. The number of such potions is `m - index`.\n    d.  Append this count to our result array.\n3.  **Return the result array.**\n\nThe total time complexity will be dominated by sorting the potions and then performing a binary search for each spell, resulting in O(m log m + n log m), which is efficient enough to pass within the time limits.\n\n```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        \"\"\"\n        Calculates the number of successful pairs for each spell.\n        A pair (spell, potion) is successful if spell * potion >= success.\n        \"\"\"\n        potions.sort()\n        m = len(potions)\n        result = []\n\n        for spell in spells:\n            min_potion_strength = (success + spell - 1) // spell\n            \n            # Find the insertion point for min_potion_strength.\n            # bisect_left returns an index `i` such that all potions[j] with j < i\n            # have potions[j] < min_potion_strength, and all potions[j] with j >= i\n            # have potions[j] >= min_potion_strength.\n            index = bisect.bisect_left(potions, min_potion_strength)\n            \n            # The number of successful potions is the total number of potions\n            # minus the index of the first successful one.\n            count = m - index\n            result.append(count)\n            \n        return result\n```",
      "TypedCode": "\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        \"\"\"\n        Calculates the number of successful pairs for each spell.\n        A pair (spell, potion) is successful if spell * potion >= success.\n        \"\"\"\n        potions.sort()\n        m = len(potions)\n        result = []\n\n        for spell in spells:\n            min_potion_strength = (success + spell - 1) // spell\n            \n            # Find the insertion point for min_potion_strength.\n            # bisect_left returns an index `i` such that all potions[j] with j < i\n            # have potions[j] < min_potion_strength, and all potions[j] with j >= i\n            # have potions[j] >= min_potion_strength.\n            index = bisect.bisect_left(potions, min_potion_strength)\n            \n            # The number of successful potions is the total number of potions\n            # minus the index of the first successful one.\n            count = m - index\n            result.append(count)\n            \n        return result\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 102269102375,
      "SolvedAt": "2025-11-20T19:16:32.433384+01:00",
      "PromptTokens": 748,
      "OutputTokens": 14876
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "2392",
        "typed_code": "\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        \"\"\"\n        Calculates the number of successful pairs for each spell.\n        A pair (spell, potion) is successful if spell * potion >= success.\n        \"\"\"\n        potions.sort()\n        m = len(potions)\n        result = []\n\n        for spell in spells:\n            min_potion_strength = (success + spell - 1) // spell\n            \n            # Find the insertion point for min_potion_strength.\n            # bisect_left returns an index `i` such that all potions[j] with j < i\n            # have potions[j] < min_potion_strength, and all potions[j] with j >= i\n            # have potions[j] >= min_potion_strength.\n            index = bisect.bisect_left(potions, min_potion_strength)\n            \n            # The number of successful potions is the total number of potions\n            # minus the index of the first successful one.\n            count = m - index\n            result.append(count)\n            \n        return result\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:39:43+01:00"
    }
  }
}