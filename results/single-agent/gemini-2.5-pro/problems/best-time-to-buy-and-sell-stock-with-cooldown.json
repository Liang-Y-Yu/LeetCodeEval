{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "309",
        "questionId": "309",
        "Content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n\t<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>\n</ul>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,0,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "SampleTestCase": "[1,2,3,0,2]",
        "ExampleTestcases": "[1,2,3,0,2]\n[1]",
        "Difficulty": "Medium",
        "Title": "Best Time to Buy and Sell Stock with Cooldown",
        "TitleSlug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"711.8K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 711815, \"totalSubmissionRaw\": 1161056, \"acRate\": \"61.3%\"}",
        "Likes": 9930,
        "Dislikes": 347,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function maxProfit(prices: number[]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int maxProfit(int* prices, int pricesSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func maxProfit(prices []int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int maxProfit(List<int> prices) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec max_profit(prices :: [integer]) :: integer\n  def max_profit(prices) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec max_profit(Prices :: [integer()]) -> integer().\nmax_profit(Prices) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (max-profit prices)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:23:34.061883+01:00",
    "AcRate": "61.3",
    "TotalSubmissions": 1161056,
    "TotalAccepted": 711815,
    "AcceptanceRate": 0.6130755105696882,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\tAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\u00a0\nExample 1:\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\nExample 2:\nInput: prices = [1]\nOutput: 0\n\u00a0\nConstraints:\n\t1 <= prices.length <= 5000\n\t0 <= prices[i] <= 1000\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient way to solve this problem is by using dynamic programming with states representing the possible actions on any given day. At the end of each day, we can be in one of three states:\n\n1.  `hold`: We are holding a stock.\n2.  `sold`: We have just sold a stock on this day.\n3 a. `cool`: We are not holding a stock and are in a \"cooldown\" or \"rest\" period, allowing us to buy on the next day.\n\nLet's define the maximum profit for each state at the end of day `i`:\n\n*   `hold[i]`: Maximum profit if we are holding a stock. This can be achieved by either:\n    *   Holding the stock from the previous day: `hold[i-1]`.\n    *   Buying the stock today, which is only possible if we were in the `cool` state yesterday: `cool[i-1] - prices[i]`.\n    So, `hold[i] = max(hold[i-1], cool[i-1] - prices[i])`.\n\n*   `sold[i]`: Maximum profit if we sell the stock today. This requires holding a stock yesterday: `hold[i-1] + prices[i]`.\n\n*   `cool[i]`: Maximum profit if we are in a cooldown/rest state. This can be achieved by either:\n    *   Resting from a previous `cool` state: `cool[i-1]`.\n    *   Being forced into cooldown after selling yesterday: `sold[i-1]`.\n    So, `cool[i] = max(cool[i-1], sold[i-1])`.\n\nSince the states for any day `i` only depend on the states of day `i-1`, we can optimize the space complexity from O(N) to O(1) by using three variables to track the states of the previous day.\n\nWe can initialize the states for a virtual day \"before day 0\" as follows:\n*   `hold = -infinity` (we can't be holding a stock we haven't bought).\n*   `sold = -infinity` (we can't have sold a stock before trading starts).\n*   `cool = 0` (initial state with zero profit, ready to buy).\n\nAfter iterating through all the days, the maximum profit will be the maximum of the `sold` and `cool` states, as we cannot end up in a `hold` state (selling is always better if profit is positive).\n\nThis logic is implemented concisely using tuple assignment in Python, which evaluates all expressions on the right-hand side before updating the variables on the left-hand side, effectively using the \"previous day's\" state values for the current day's calculation.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        hold = float('-inf')\n        sold = float('-inf')\n        cool = 0\n\n        for price in prices:\n            hold, sold, cool = max(hold, cool - price), hold + price, max(cool, sold)\n\n        return max(sold, cool)\n\n```",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        hold = float('-inf')\n        sold = float('-inf')\n        cool = 0\n\n        for price in prices:\n            hold, sold, cool = max(hold, cool - price), hold + price, max(cool, sold)\n\n        return max(sold, cool)\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 162706837292,
      "SolvedAt": "2025-11-20T12:11:34.062614+01:00",
      "PromptTokens": 428,
      "OutputTokens": 20402
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "309",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        hold = float('-inf')\n        sold = float('-inf')\n        cool = 0\n\n        for price in prices:\n            hold, sold, cool = max(hold, cool - price), hold + price, max(cool, sold)\n\n        return max(sold, cool)\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:21:49+01:00"
    }
  }
}