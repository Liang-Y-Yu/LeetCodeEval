{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "472",
        "questionId": "472",
        "Content": "<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>\n\n<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)&nbsp;in the given array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; \n&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; \n&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]\n<strong>Output:</strong> [&quot;catdog&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
        "ExampleTestcases": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n[\"cat\",\"dog\",\"catdog\"]",
        "Difficulty": "Hard",
        "Title": "Concatenated Words",
        "TitleSlug": "concatenated-words",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"260.2K\", \"totalSubmission\": \"524.6K\", \"totalAcceptedRaw\": 260204, \"totalSubmissionRaw\": 524581, \"acRate\": \"49.6%\"}",
        "Likes": 4037,
        "Dislikes": 292,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIx",
            "Name": "Depth-First Search",
            "Slug": "depth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI3",
            "Name": "Trie",
            "Slug": "trie"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nvar findAllConcatenatedWordsInADict = function(words) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findAllConcatenatedWordsInADict(words: string[]): string[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findAllConcatenatedWordsInADict(char** words, int wordsSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findAllConcatenatedWordsInADict(words []string) []string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findAllConcatenatedWordsInADict(_ words: [String]) -> [String] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_all_concatenated_words_in_a_dict(words: Vec<String>) -> Vec<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String[]} words\n# @return {String[]}\ndef find_all_concatenated_words_in_a_dict(words)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return String[]\n     */\n    function findAllConcatenatedWordsInADict($words) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<String> findAllConcatenatedWordsInADict(List<String> words) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findAllConcatenatedWordsInADict(words: Array[String]): List[String] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_all_concatenated_words_in_a_dict(words :: [String.t]) :: [String.t]\n  def find_all_concatenated_words_in_a_dict(words) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_all_concatenated_words_in_a_dict(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nfind_all_concatenated_words_in_a_dict(Words) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-all-concatenated-words-in-a-dict words)\n  (-> (listof string?) (listof string?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:15:38.89262+01:00",
    "AcRate": "49.6",
    "TotalSubmissions": 524581,
    "TotalAccepted": 260204,
    "AcceptanceRate": 0.4960225398937438,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/concatenated-words/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)\u00a0in the given array.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\nExample 2:\nInput: words = [\"cat\",\"dog\",\"catdog\"]\nOutput: [\"catdog\"]\n\u00a0\nConstraints:\n\t1 <= words.length <= 10^4\n\t1 <= words[i].length <= 30\n\twords[i] consists of only lowercase English letters.\n\tAll the strings of words are unique.\n\t1 <= sum(words[i].length) <= 10^5\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and effective way to solve this problem is to use a recursive approach with memoization, which is a form of dynamic programming. For each word in the input list, we need to determine if it can be formed by concatenating at least two other, shorter words from the same list.\n\nHere's a breakdown of the chosen approach:\n\n1.  **Dictionary Creation:** First, all words from the input list are placed into a hash set. This allows for very fast lookups (average O(1) time complexity, proportional to string length) to check if a given substring is a valid word from our dictionary.\n\n2.  **Iterate and Check:** We iterate through each `word` in the original `words` list. For each `word`, we call a helper function, let's call it `is_concatenated`, to determine if it meets the problem's criteria.\n\n3.  **Recursive Checker (`is_concatenated`):** This is the core of the solution.\n    *   **Base Case:** The recursion needs a way to terminate. A word cannot be a concatenation of itself in one piece. Our recursive function will check for splits into at least two parts. If no such split is found, it's not a concatenated word in this context.\n    *   **Recursive Step:** For a given `word`, we try every possible split point. A split divides the `word` into a `prefix` and a `suffix`.\n        *   If the `prefix` is a valid word (found in our word set), we then examine the `suffix`.\n        *   If the `suffix` is also a valid word in the set, we have successfully found a two-word composition. The word is concatenated.\n        *   If the `suffix` is not a simple word from the set, we recursively call `is_concatenated` on the `suffix` to see if it can be formed by other words. If it can, our original `word` is also considered concatenated (`prefix` + a concatenated `suffix`).\n    *   The loop for splitting the word `for i in range(1, len(word))` inherently ensures that both `prefix` and `suffix` are shorter than the original `word`, satisfying a key requirement.\n\n4.  **Memoization:** This recursive process can be very inefficient if we re-compute results for the same substrings repeatedly. For example, checking \"catsdogcats\" and \"ratdogcats\" would both involve checking \"dogcats\". To avoid this, we use a memoization table (a dictionary or hash map) to cache the result of `is_concatenated(substring)`. Before any computation, we check the cache; after computing a result, we store it. This drastically improves performance, making the solution feasible for the given constraints.\n\nThis Depth-First Search (DFS) with memoization approach correctly identifies all concatenated words by efficiently exploring all valid segmentation possibilities for each word.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        self.word_set = set(words)\n        self.memo = {}\n        \n        result = []\n        for word in words:\n            if self.is_concatenated(word):\n                result.append(word)\n        return result\n\n    def is_concatenated(self, word: str) -> bool:\n        if word in self.memo:\n            return self.memo[word]\n        \n        # A word is concatenated if it can be split into a prefix and a suffix,\n        # where the prefix is a word, and the suffix is either a word or another\n        # concatenated word.\n        # The loop range ensures we always split into at least two non-empty,\n        # and therefore shorter, parts.\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            \n            if prefix in self.word_set:\n                # If the suffix is a word in the set, we've found a valid concatenation.\n                if suffix in self.word_set:\n                    self.memo[word] = True\n                    return True\n                # If not, we recursively check if the suffix can be formed by other words.\n                if self.is_concatenated(suffix):\n                    self.memo[word] = True\n                    return True\n        \n        # If no valid concatenation is found after checking all splits, store and return False.\n        self.memo[word] = False\n        return False\n\n```",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        self.word_set = set(words)\n        self.memo = {}\n        \n        result = []\n        for word in words:\n            if self.is_concatenated(word):\n                result.append(word)\n        return result\n\n    def is_concatenated(self, word: str) -> bool:\n        if word in self.memo:\n            return self.memo[word]\n        \n        # A word is concatenated if it can be split into a prefix and a suffix,\n        # where the prefix is a word, and the suffix is either a word or another\n        # concatenated word.\n        # The loop range ensures we always split into at least two non-empty,\n        # and therefore shorter, parts.\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            \n            if prefix in self.word_set:\n                # If the suffix is a word in the set, we've found a valid concatenation.\n                if suffix in self.word_set:\n                    self.memo[word] = True\n                    return True\n                # If not, we recursively check if the suffix can be formed by other words.\n                if self.is_concatenated(suffix):\n                    self.memo[word] = True\n                    return True\n        \n        # If no valid concatenation is found after checking all splits, store and return False.\n        self.memo[word] = False\n        return False\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 227199873125,
      "SolvedAt": "2025-11-20T12:32:21.671529+01:00",
      "PromptTokens": 504,
      "OutputTokens": 27191
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "472",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        self.word_set = set(words)\n        self.memo = {}\n        \n        result = []\n        for word in words:\n            if self.is_concatenated(word):\n                result.append(word)\n        return result\n\n    def is_concatenated(self, word: str) -> bool:\n        if word in self.memo:\n            return self.memo[word]\n        \n        # A word is concatenated if it can be split into a prefix and a suffix,\n        # where the prefix is a word, and the suffix is either a word or another\n        # concatenated word.\n        # The loop range ensures we always split into at least two non-empty,\n        # and therefore shorter, parts.\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            \n            if prefix in self.word_set:\n                # If the suffix is a word in the set, we've found a valid concatenation.\n                if suffix in self.word_set:\n                    self.memo[word] = True\n                    return True\n                # If not, we recursively check if the suffix can be formed by other words.\n                if self.is_concatenated(suffix):\n                    self.memo[word] = True\n                    return True\n        \n        # If no valid concatenation is found after checking all splits, store and return False.\n        self.memo[word] = False\n        return False\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:45:14+01:00"
    }
  }
}