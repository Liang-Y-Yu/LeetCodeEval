{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1964",
        "questionId": "2096",
        "Content": "<p>You want to build some obstacle courses. You are given a <strong>0-indexed</strong> integer array <code>obstacles</code> of length <code>n</code>, where <code>obstacles[i]</code> describes the height of the <code>i<sup>th</sup></code> obstacle.</p>\n\n<p>For every index <code>i</code> between <code>0</code> and <code>n - 1</code> (<strong>inclusive</strong>), find the length of the <strong>longest obstacle course</strong> in <code>obstacles</code> such that:</p>\n\n<ul>\n\t<li>You choose any number of obstacles between <code>0</code> and <code>i</code> <strong>inclusive</strong>.</li>\n\t<li>You must include the <code>i<sup>th</sup></code> obstacle in the course.</li>\n\t<li>You must put the chosen obstacles in the <strong>same order</strong> as they appear in <code>obstacles</code>.</li>\n\t<li>Every obstacle (except the first) is <strong>taller</strong> than or the <strong>same height</strong> as the obstacle immediately before it.</li>\n</ul>\n\n<p>Return <em>an array</em> <code>ans</code> <em>of length</em> <code>n</code>, <em>where</em> <code>ans[i]</code> <em>is the length of the <strong>longest obstacle course</strong> for index</em> <code>i</code><em> as described above</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [1,2,3,2]\n<strong>Output:</strong> [1,2,3,3]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>1</u>], [1] has length 1.\n- i = 1: [<u>1</u>,<u>2</u>], [1,2] has length 2.\n- i = 2: [<u>1</u>,<u>2</u>,<u>3</u>], [1,2,3] has length 3.\n- i = 3: [<u>1</u>,<u>2</u>,3,<u>2</u>], [1,2,2] has length 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [2,2,1]\n<strong>Output:</strong> [1,2,1]\n<strong>Explanation: </strong>The longest valid obstacle course at each position is:\n- i = 0: [<u>2</u>], [2] has length 1.\n- i = 1: [<u>2</u>,<u>2</u>], [2,2] has length 2.\n- i = 2: [2,2,<u>1</u>], [1] has length 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obstacles = [3,1,5,6,4,2]\n<strong>Output:</strong> [1,1,2,3,2,2]\n<strong>Explanation:</strong> The longest valid obstacle course at each position is:\n- i = 0: [<u>3</u>], [3] has length 1.\n- i = 1: [3,<u>1</u>], [1] has length 1.\n- i = 2: [<u>3</u>,1,<u>5</u>], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [<u>3</u>,1,<u>5</u>,<u>6</u>], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [<u>3</u>,1,5,6,<u>4</u>], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,<u>1</u>,5,6,4,<u>2</u>], [1,2] has length 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[1,2,3,2]",
        "ExampleTestcases": "[1,2,3,2]\n[2,2,1]\n[3,1,5,6,4,2]",
        "Difficulty": "Hard",
        "Title": "Find the Longest Valid Obstacle Course at Each Position",
        "TitleSlug": "find-the-longest-valid-obstacle-course-at-each-position",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"66.7K\", \"totalSubmission\": \"106.6K\", \"totalAcceptedRaw\": 66682, \"totalSubmissionRaw\": 106608, \"acRate\": \"62.5%\"}",
        "Likes": 1880,
        "Dislikes": 74,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI4",
            "Name": "Binary Indexed Tree",
            "Slug": "binary-indexed-tree"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nvar longestObstacleCourseAtEachPosition = function(obstacles) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function longestObstacleCourseAtEachPosition(obstacles: number[]): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int[] LongestObstacleCourseAtEachPosition(int[] obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func longestObstacleCourseAtEachPosition(obstacles []int) []int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun longestObstacleCourseAtEachPosition(obstacles: IntArray): IntArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func longestObstacleCourseAtEachPosition(_ obstacles: [Int]) -> [Int] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn longest_obstacle_course_at_each_position(obstacles: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} obstacles\n# @return {Integer[]}\ndef longest_obstacle_course_at_each_position(obstacles)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $obstacles\n     * @return Integer[]\n     */\n    function longestObstacleCourseAtEachPosition($obstacles) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<int> longestObstacleCourseAtEachPosition(List<int> obstacles) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def longestObstacleCourseAtEachPosition(obstacles: Array[Int]): Array[Int] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec longest_obstacle_course_at_each_position(obstacles :: [integer]) :: [integer]\n  def longest_obstacle_course_at_each_position(obstacles) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec longest_obstacle_course_at_each_position(Obstacles :: [integer()]) -> [integer()].\nlongest_obstacle_course_at_each_position(Obstacles) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (longest-obstacle-course-at-each-position obstacles)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T13:56:35.847686+01:00",
    "AcRate": "62.5",
    "TotalSubmissions": 106608,
    "TotalAccepted": 66682,
    "AcceptanceRate": 0.6254877682725499,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the i^th obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\tYou choose any number of obstacles between 0 and i inclusive.\n\tYou must include the i^th obstacle in the course.\n\tYou must put the chosen obstacles in the same order as they appear in obstacles.\n\tEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n\u00a0\nExample 1:\nInput: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.\nExample 2:\nInput: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.\nExample 3:\nInput: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2.\n\u00a0\nConstraints:\n\tn == obstacles.length\n\t1 <= n <= 10^5\n\t1 <= obstacles[i] <= 10^7\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient solution to this problem can be achieved by adapting the classic O(n log n) algorithm for finding the Longest Increasing Subsequence (LIS). The problem asks for the length of the longest non-decreasing subsequence ending at each position `i`, considering all obstacles from index 0 to `i`.\n\nLet's maintain a list, let's call it `tails`. This list will store the smallest tail of all non-decreasing subsequences for each possible length. Specifically, `tails[k]` will hold the smallest ending value of a non-decreasing subsequence of length `k + 1`. By its definition, this `tails` list will always be sorted in non-decreasing order.\n\nWe iterate through the `obstacles` array, processing one obstacle at a time. For each obstacle `x` at index `i`:\n\n1.  We need to determine the length of the longest non-decreasing subsequence ending with `x`. This length is `1 + L`, where `L` is the length of the longest non-decreasing subsequence formed from obstacles before `x` (i.e., at indices `j < i`) whose last element is less than or equal to `x`.\n\n2.  We can find `L` by searching in our `tails` list. Since `tails` is sorted, we can use binary search. We look for the length of the longest subsequence whose tail is less than or equal to `x`. The number of elements in `tails` that are less than or equal to `x` gives us this length, `L`. Python's `bisect.bisect_right(tails, x)` efficiently computes this value. Let's call the result `idx`. This `idx` represents `L`.\n\n3.  The length of the longest obstacle course ending at the current position is therefore `idx + 1`. We record this value in our answer array.\n\n4.  Finally, we update the `tails` list. We have just found a non-decreasing subsequence of length `idx + 1` that ends with `x`.\n    *   If `idx` equals the current length of `tails`, it means `x` is greater than or equal to all existing Rtails. This allows us to form a new, longer subsequence. We append `x` to `tails`.\n    *   If `idx` is less than the length of `tails`, it means we have found a new contender for the smallest tail of a subsequence of length `idx + 1`. The previous smallest tail for this length was `tails[idx]`. Since `bisect_right` ensures that `x < tails[idx]` (if `tails[idx]` exists), `x` is a \"better\" (smaller) tail. We update `tails[idx]` to `x`. This helps in potentially building longer subsequences later on with smaller preceding values.\n\nThis process is repeated for all obstacles. The overall time complexity will be O(n log n) due to the binary search performed for each of the `n` obstacles. The space complexity will be O(n) to store the `tails` list and the final answer.\n\n```python\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        # `tails` stores the smallest tail of all non-decreasing subsequences\n        # for each possible length. `tails[k]` is the smallest tail for a subsequence\n        # of length k+1. This list is maintained in sorted order.\n        tails = []\n        ans = []\n        \n        for x in obstacles:\n            # `bisect_right` finds the insertion point for x in tails to maintain sort order.\n            # This index, `idx`, is the number of elements in `tails` less than or equal to `x`.\n            # This corresponds to the length of the longest valid subsequence ending before `x`\n            # which we can extend with `x`.\n            idx = bisect.bisect_right(tails, x)\n            \n            # The length of the longest course ending at `x` is `idx + 1`.\n            ans.append(idx + 1)\n            \n            if idx == len(tails):\n                # If `x` is greater than or equal to all elements in `tails`,\n                # it extends the longest subsequence found so far.\n                tails.append(x)\n            else:\n                # `x` can replace `tails[idx]` to form a new non-decreasing subsequence\n                # of length `idx + 1` with a smaller or equal tail.\n                tails[idx] = x\n                \n        return ans\n\n```",
      "TypedCode": "\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        # `tails` stores the smallest tail of all non-decreasing subsequences\n        # for each possible length. `tails[k]` is the smallest tail for a subsequence\n        # of length k+1. This list is maintained in sorted order.\n        tails = []\n        ans = []\n        \n        for x in obstacles:\n            # `bisect_right` finds the insertion point for x in tails to maintain sort order.\n            # This index, `idx`, is the number of elements in `tails` less than or equal to `x`.\n            # This corresponds to the length of the longest valid subsequence ending before `x`\n            # which we can extend with `x`.\n            idx = bisect.bisect_right(tails, x)\n            \n            # The length of the longest course ending at `x` is `idx + 1`.\n            ans.append(idx + 1)\n            \n            if idx == len(tails):\n                # If `x` is greater than or equal to all elements in `tails`,\n                # it extends the longest subsequence found so far.\n                tails.append(x)\n            else:\n                # `x` can replace `tails[idx]` to form a new non-decreasing subsequence\n                # of length `idx + 1` with a smaller or equal tail.\n                tails[idx] = x\n                \n        return ans\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 123749559500,
      "SolvedAt": "2025-11-20T13:41:56.863132+01:00",
      "PromptTokens": 898,
      "OutputTokens": 15373
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "2096",
        "typed_code": "\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        # `tails` stores the smallest tail of all non-decreasing subsequences\n        # for each possible length. `tails[k]` is the smallest tail for a subsequence\n        # of length k+1. This list is maintained in sorted order.\n        tails = []\n        ans = []\n        \n        for x in obstacles:\n            # `bisect_right` finds the insertion point for x in tails to maintain sort order.\n            # This index, `idx`, is the number of elements in `tails` less than or equal to `x`.\n            # This corresponds to the length of the longest valid subsequence ending before `x`\n            # which we can extend with `x`.\n            idx = bisect.bisect_right(tails, x)\n            \n            # The length of the longest course ending at `x` is `idx + 1`.\n            ans.append(idx + 1)\n            \n            if idx == len(tails):\n                # If `x` is greater than or equal to all elements in `tails`,\n                # it extends the longest subsequence found so far.\n                tails.append(x)\n            else:\n                # `x` can replace `tails[idx]` to form a new non-decreasing subsequence\n                # of length `idx + 1` with a smaller or equal tail.\n                tails[idx] = x\n                \n        return ans\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:25:31+01:00"
    }
  }
}