{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "480",
        "questionId": "480",
        "Content": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is <code>3</code>.</li>\n\t<li>For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. There is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the median array for each window in the original array</em>. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n<strong>Explanation:</strong> \nWindow position                Median\n---------------                -----\n[<strong>1  3  -1</strong>] -3  5  3  6  7        1\n 1 [<strong>3  -1  -3</strong>] 5  3  6  7       -1\n 1  3 [<strong>-1  -3  5</strong>] 3  6  7       -1\n 1  3  -1 [<strong>-3  5  3</strong>] 6  7        3\n 1  3  -1  -3 [<strong>5  3  6</strong>] 7        5\n 1  3  -1  -3  5 [<strong>3  6  7</strong>]       6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,2,3,1,4,2], k = 3\n<strong>Output:</strong> [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "SampleTestCase": "[1,3,-1,-3,5,3,6,7]\n3",
        "ExampleTestcases": "[1,3,-1,-3,5,3,6,7]\n3\n[1,2,3,4,2,3,1,4,2]\n3",
        "Difficulty": "Hard",
        "Title": "Sliding Window Median",
        "TitleSlug": "sliding-window-median",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"205.6K\", \"totalSubmission\": \"529.8K\", \"totalAcceptedRaw\": 205634, \"totalSubmissionRaw\": 529797, \"acRate\": \"38.8%\"}",
        "Likes": 3499,
        "Dislikes": 231,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar medianSlidingWindow = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function medianSlidingWindow(nums: number[], k: number): number[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public double[] MedianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ndouble* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func medianSlidingWindow(nums []int, k int) []float64 {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun medianSlidingWindow(nums: IntArray, k: Int): DoubleArray {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Float[]}\ndef median_sliding_window(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Float[]\n     */\n    function medianSlidingWindow($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<double> medianSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec median_sliding_window(nums :: [integer], k :: integer) :: [float]\n  def median_sliding_window(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec median_sliding_window(Nums :: [integer()], K :: integer()) -> [float()].\nmedian_sliding_window(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (median-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof flonum?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:15:09.240796+01:00",
    "AcRate": "38.8",
    "TotalSubmissions": 529797,
    "TotalAccepted": 205634,
    "AcceptanceRate": 0.38813734317106363,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/sliding-window-median/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\tFor examples, if arr = [2,3,4], the median is 3.\n\tFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10^-5 of the actual value will be accepted.\n\u00a0\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6\nExample 2:\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n\u00a0\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient way to solve this problem is by using two heaps: a max-heap and a min-heap. These two heaps will store the smaller and larger halves of the numbers in the current sliding window, respectively. This allows us to find the median in constant time (by looking at the top elements of the heaps) and to update the heaps in logarithmic time as the window slides.\n\n### High-Level Approach:\n\n1.  **Two Heaps**: We'll maintain two heaps:\n    *   `small`: A max-heap to store the smaller half of the window's elements.\n    *   `large`: A min-heap to store the larger half of the window's elements.\n    \n    In Python, `heapq` provides a min-heap. We can simulate a max-heap by storing negated values in `small`.\n\n2.  **Heap Size Invariant**: To easily find the median, we need to keep the heaps balanced. We'll maintain the invariant that `len(small)` is either equal to `len(large)` or one element larger.\n    *   If `k` is odd, `len(small) = len(large) + 1`. The median is the top of `small`.\n    *   If `k` is even, `len(small) = len(large)`. The median is the average of the tops of `small` and `large`.\n\n3.  **Lazy Removal**: Standard heaps don't support efficient removal of arbitrary elements. Since we need to remove the element sliding out of the window, we'll use a \"lazy removal\" technique. We'll use a hash map (`to_remove`) to keep a count of elements that are outdated. When we access the top of a heap, we'll first check if it's an outdated element. If so, we pop it and decrement its count in `to_remove`, repeating until the top is a valid element.\n\n### Detailed Algorithm:\n\n1.  **Initialization**:\n    *   Create `small` (max-heap) and `large` (min-heap).\n    *   Populate the heaps with the first `k` elements from `nums`. A straightforward way is to push all `k` elements into `small` and then move the `k // 2` largest elements from `small` to `large`. This automatically partitions and balances the heaps.\n    *   Initialize a hash map `to_remove` to track elements for lazy removal.\n\n2.  **Main Loop**: Iterate from `i = k` to `len(nums)` (inclusive of a final step to calculate the last median).\n    a. **Calculate Median**: Before each calculation, \"clean\" the tops of the heaps by removing any stale elements marked in `to_remove`. Then, calculate the median based on the `k % 2` parity and append it to the result list.\n    b. **Slide the Window**:\n        *   Identify `old_num` (leaving the window, `nums[i-k]`) and `new_num` (entering the window, `nums[i]`).\n        *   Determine the net change to `small`'s size. The boundary between `small` and `large` is effectively `-small[0]`.\n        *   An element belongs to `small` if it's less than or equal to this boundary.\n        *   Calculate `small_size_diff = (1 if new_num goes to small) - (1 if old_num was in small)`.\n        *   Add `new_num` to the appropriate heap.\n        *   Mark `old_num` for removal in the `to_remove` map.\n        *   **Rebalance**: Based on `small_size_diff`, move one element between heaps if necessary to restore the size invariant. For instance, if `small_size_diff` is -1, `small` has shrunk relative to `large`, so we move an element from `large` to `small`.\n\nThis approach results in an overall time complexity of O(N log K), as each of the N elements is processed with heap operations that take O(log K) time. The space complexity is O(K) for storing the heaps and the `to_remove` map.\n\n```python\nimport heapq\nimport collections\n\nclass Solution:\n    def medianSlidingWindow(self, nums: list[int], k: int) -> list[float]:\n        # small is a max-heap (stores negative numbers), large is a min-heap\n        small, large = [], []\n        to_remove = collections.defaultdict(int)\n        ans = []\n\n        # Initialize the heaps with the first window\n        for i in range(k):\n            heapq.heappush(small, -nums[i])\n        for _ in range(k // 2):\n            heapq.heappush(large, -heapq.heappop(small))\n\n        # Main loop to slide the window\n        for i in range(k, len(nums) + 1):\n            # Clean up stale elements from the top of the heaps\n            while small and to_remove[-small[0]] > 0:\n                to_remove[-small[0]] -= 1\n                heapq.heappop(small)\n            while large and to_remove[large[0]] > 0:\n                to_remove[large[0]] -= 1\n                heapq.heappop(large)\n\n            # Calculate the median for the current valid window\n            if k % 2 == 1:\n                ans.append(float(-small[0]))\n            else:\n                ans.append((-small[0] + large[0]) / 2.0)\n\n            # If we've processed all windows, break\n            if i == len(nums):\n                break\n\n            # Define elements for sliding\n            old_num, new_num = nums[i - k], nums[i]\n\n            # The boundary is the current median-related value, -small[0]\n            boundary = -small[0]\n\n            # Determine the net change in the size of the small heap\n            small_size_diff = 0\n            if new_num <= boundary:\n                small_size_diff += 1\n            if old_num <= boundary:\n                small_size_diff -= 1\n\n            # Add the new number\n            if new_num <= boundary:\n                heapq.heappush(small, -new_num)\n            else:\n                heapq.heappush(large, new_num)\n\n            # Mark the old number for lazy removal\n            to_remove[old_num] += 1\n\n            # Rebalance the heaps based on the size difference\n            if small_size_diff < 0:  # small heap became smaller\n                heapq.heappush(small, -heapq.heappop(large))\n            elif small_size_diff > 0:  # small heap became larger\n                heapq.heappush(large, -heapq.heappop(small))\n\n        return ans\n\n```",
      "TypedCode": "\nimport heapq\nimport collections\n\nclass Solution:\n    def medianSlidingWindow(self, nums: list[int], k: int) -> list[float]:\n        # small is a max-heap (stores negative numbers), large is a min-heap\n        small, large = [], []\n        to_remove = collections.defaultdict(int)\n        ans = []\n\n        # Initialize the heaps with the first window\n        for i in range(k):\n            heapq.heappush(small, -nums[i])\n        for _ in range(k // 2):\n            heapq.heappush(large, -heapq.heappop(small))\n\n        # Main loop to slide the window\n        for i in range(k, len(nums) + 1):\n            # Clean up stale elements from the top of the heaps\n            while small and to_remove[-small[0]] > 0:\n                to_remove[-small[0]] -= 1\n                heapq.heappop(small)\n            while large and to_remove[large[0]] > 0:\n                to_remove[large[0]] -= 1\n                heapq.heappop(large)\n\n            # Calculate the median for the current valid window\n            if k % 2 == 1:\n                ans.append(float(-small[0]))\n            else:\n                ans.append((-small[0] + large[0]) / 2.0)\n\n            # If we've processed all windows, break\n            if i == len(nums):\n                break\n\n            # Define elements for sliding\n            old_num, new_num = nums[i - k], nums[i]\n\n            # The boundary is the current median-related value, -small[0]\n            boundary = -small[0]\n\n            # Determine the net change in the size of the small heap\n            small_size_diff = 0\n            if new_num <= boundary:\n                small_size_diff += 1\n            if old_num <= boundary:\n                small_size_diff -= 1\n\n            # Add the new number\n            if new_num <= boundary:\n                heapq.heappush(small, -new_num)\n            else:\n                heapq.heappush(large, new_num)\n\n            # Mark the old number for lazy removal\n            to_remove[old_num] += 1\n\n            # Rebalance the heaps based on the size difference\n            if small_size_diff < 0:  # small heap became smaller\n                heapq.heappush(small, -heapq.heappop(large))\n            elif small_size_diff > 0:  # small heap became larger\n                heapq.heappush(large, -heapq.heappop(small))\n\n        return ans\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 263461770416,
      "SolvedAt": "2025-11-20T18:55:19.496436+01:00",
      "PromptTokens": 769,
      "OutputTokens": 30504
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "480",
        "typed_code": "\nimport heapq\nimport collections\n\nclass Solution:\n    def medianSlidingWindow(self, nums: list[int], k: int) -> list[float]:\n        # small is a max-heap (stores negative numbers), large is a min-heap\n        small, large = [], []\n        to_remove = collections.defaultdict(int)\n        ans = []\n\n        # Initialize the heaps with the first window\n        for i in range(k):\n            heapq.heappush(small, -nums[i])\n        for _ in range(k // 2):\n            heapq.heappush(large, -heapq.heappop(small))\n\n        # Main loop to slide the window\n        for i in range(k, len(nums) + 1):\n            # Clean up stale elements from the top of the heaps\n            while small and to_remove[-small[0]] > 0:\n                to_remove[-small[0]] -= 1\n                heapq.heappop(small)\n            while large and to_remove[large[0]] > 0:\n                to_remove[large[0]] -= 1\n                heapq.heappop(large)\n\n            # Calculate the median for the current valid window\n            if k % 2 == 1:\n                ans.append(float(-small[0]))\n            else:\n                ans.append((-small[0] + large[0]) / 2.0)\n\n            # If we've processed all windows, break\n            if i == len(nums):\n                break\n\n            # Define elements for sliding\n            old_num, new_num = nums[i - k], nums[i]\n\n            # The boundary is the current median-related value, -small[0]\n            boundary = -small[0]\n\n            # Determine the net change in the size of the small heap\n            small_size_diff = 0\n            if new_num <= boundary:\n                small_size_diff += 1\n            if old_num <= boundary:\n                small_size_diff -= 1\n\n            # Add the new number\n            if new_num <= boundary:\n                heapq.heappush(small, -new_num)\n            else:\n                heapq.heappush(large, new_num)\n\n            # Mark the old number for lazy removal\n            to_remove[old_num] += 1\n\n            # Rebalance the heaps based on the size difference\n            if small_size_diff < 0:  # small heap became smaller\n                heapq.heappush(small, -heapq.heappop(large))\n            elif small_size_diff > 0:  # small heap became larger\n                heapq.heappush(large, -heapq.heappop(small))\n\n        return ans\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T19:51:59+01:00"
    }
  }
}