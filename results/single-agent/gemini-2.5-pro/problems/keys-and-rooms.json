{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "841",
        "questionId": "871",
        "Content": "<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>\n\n<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>\n\n<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1],[2],[3],[]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "SampleTestCase": "[[1],[2],[3],[]]",
        "ExampleTestcases": "[[1],[2],[3],[]]\n[[1,3],[3,0,1],[2],[0]]",
        "Difficulty": "Medium",
        "Title": "Keys and Rooms",
        "TitleSlug": "keys-and-rooms",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"636.9K\", \"totalSubmission\": \"846.9K\", \"totalAcceptedRaw\": 636945, \"totalSubmissionRaw\": 846890, \"acRate\": \"75.2%\"}",
        "Likes": 6575,
        "Dislikes": 297,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjIx",
            "Name": "Depth-First Search",
            "Slug": "depth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIy",
            "Name": "Breadth-First Search",
            "Slug": "breadth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI0",
            "Name": "Graph",
            "Slug": "graph"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def canVisitAllRooms(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function(rooms) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function canVisitAllRooms(rooms: number[][]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool CanVisitAllRooms(IList<IList<int>> rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func canVisitAllRooms(rooms [][]int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun canVisitAllRooms(rooms: List<List<Int>>): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func canVisitAllRooms(_ rooms: [[Int]]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn can_visit_all_rooms(rooms: Vec<Vec<i32>>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[][]} rooms\n# @return {Boolean}\ndef can_visit_all_rooms(rooms)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[][] $rooms\n     * @return Boolean\n     */\n    function canVisitAllRooms($rooms) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool canVisitAllRooms(List<List<int>> rooms) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def canVisitAllRooms(rooms: List[List[Int]]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec can_visit_all_rooms(rooms :: [[integer]]) :: boolean\n  def can_visit_all_rooms(rooms) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec can_visit_all_rooms(Rooms :: [[integer()]]) -> boolean().\ncan_visit_all_rooms(Rooms) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (can-visit-all-rooms rooms)\n  (-> (listof (listof exact-integer?)) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:56:10.326741+01:00",
    "AcRate": "75.2",
    "TotalSubmissions": 846890,
    "TotalAccepted": 636945,
    "AcceptanceRate": 0.752098855813624,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/keys-and-rooms/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: There are n rooms labeled from 0 to n - 1\u00a0and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\u00a0\nExample 1:\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\nExample 2:\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n\u00a0\nConstraints:\n\tn == rooms.length\n\t2 <= n <= 1000\n\t0 <= rooms[i].length <= 1000\n\t1 <= sum(rooms[i].length) <= 3000\n\t0 <= rooms[i][j] < n\n\tAll the values of rooms[i] are unique.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient way to solve this problem is to model it as a graph traversal. Each room is a node in the graph, and a key found in room `i` that unlocks room `j` represents a directed edge from node `i` to node `j`. The problem then becomes: can we reach all nodes starting from node 0?\n\nThis is a classic reachability problem that can be solved using either Breadth-First Search (BFS) or Depth-First Search (DFS). Both algorithms will correctly determine the set of all rooms reachable from room 0.\n\nHere, I'll use an iterative DFS approach, which is a good choice as it's straightforward to implement, memory-efficient, and avoids potential recursion depth issues with very large inputs (though not a concern with the given constraints).\n\nThe algorithm proceeds as follows:\n1.  Initialize a `stack` for the DFS traversal, starting with room 0, which is the only room we can access initially.\n2.  Initialize a `visited` set to keep track of the rooms we have visited. Add room 0 to this set.\n3.  While the `stack` is not empty, pop a room to visit.\n4.  For the current room, iterate through all the keys it contains.\n5.  If a key unlocks a room that has not been visited yet, mark that room as visited and add it to the `stack` to be explored later.\n6.  After the traversal is complete, all rooms reachable from room 0 will be in the `visited` set.\n7.  Finally, check if the number of visited rooms is equal to the total number of rooms. If it is, we can visit all rooms, so we return `True`. Otherwise, we return `False`.\n\nThis approach systematically explores the graph of rooms and correctly identifies all connected components reachable from the starting point.\n\n```python\nclass Solution:\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n        \"\"\"\n        Determines if all rooms can be visited starting from room 0.\n\n        This problem can be modeled as a graph traversal. Each room is a node,\n        and a key in room `i` for room `j` is a directed edge from `i` to `j`.\n        The goal is to check if all nodes are reachable from node 0.\n\n        We use an iterative Depth-First Search (DFS) approach.\n\n        1. A `stack` is used to keep track of rooms to visit, initialized with room 0.\n        2. A `visited` set stores the rooms that have been visited to avoid cycles\n           and redundant processing. Room 0 is initially marked as visited.\n        3. The traversal continues until the stack is empty. In each step, a room\n           is popped from the stack, and for each key found in it, if the\n           corresponding room hasn't been visited, it's marked as visited and\n           pushed onto the stack.\n        4. After the traversal, if the count of visited rooms equals the total\n           number of rooms, it means all rooms are reachable.\n        \"\"\"\n        \n        # The stack for the DFS traversal, starting with room 0.\n        stack = [0]\n        \n        # A set to keep track of visited rooms, initialized with room 0.\n        visited = {0}\n\n        while stack:\n            # Get the next room to visit from the stack.\n            room = stack.pop()\n\n            # For each key in the current room, explore the new room if not visited.\n            for key in rooms[room]:\n                if key not in visited:\n                    # Mark the new room as visited.\n                    visited.add(key)\n                    # Add the new room to the stack to visit its neighbors.\n                    stack.append(key)\n        \n        # If the number of visited rooms equals the total number of rooms,\n        # all rooms are accessible.\n        return len(visited) == len(rooms)\n\n```",
      "TypedCode": "\nclass Solution:\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n        \"\"\"\n        Determines if all rooms can be visited starting from room 0.\n\n        This problem can be modeled as a graph traversal. Each room is a node,\n        and a key in room `i` for room `j` is a directed edge from `i` to `j`.\n        The goal is to check if all nodes are reachable from node 0.\n\n        We use an iterative Depth-First Search (DFS) approach.\n\n        1. A `stack` is used to keep track of rooms to visit, initialized with room 0.\n        2. A `visited` set stores the rooms that have been visited to avoid cycles\n           and redundant processing. Room 0 is initially marked as visited.\n        3. The traversal continues until the stack is empty. In each step, a room\n           is popped from the stack, and for each key found in it, if the\n           corresponding room hasn't been visited, it's marked as visited and\n           pushed onto the stack.\n        4. After the traversal, if the count of visited rooms equals the total\n           number of rooms, it means all rooms are reachable.\n        \"\"\"\n        \n        # The stack for the DFS traversal, starting with room 0.\n        stack = [0]\n        \n        # A set to keep track of visited rooms, initialized with room 0.\n        visited = {0}\n\n        while stack:\n            # Get the next room to visit from the stack.\n            room = stack.pop()\n\n            # For each key in the current room, explore the new room if not visited.\n            for key in rooms[room]:\n                if key not in visited:\n                    # Mark the new room as visited.\n                    visited.add(key)\n                    # Add the new room to the stack to visit its neighbors.\n                    stack.append(key)\n        \n        # If the number of visited rooms equals the total number of rooms,\n        # all rooms are accessible.\n        return len(visited) == len(rooms)\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 111933607042,
      "SolvedAt": "2025-11-20T14:06:18.506171+01:00",
      "PromptTokens": 580,
      "OutputTokens": 13418
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "871",
        "typed_code": "\nclass Solution:\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n        \"\"\"\n        Determines if all rooms can be visited starting from room 0.\n\n        This problem can be modeled as a graph traversal. Each room is a node,\n        and a key in room `i` for room `j` is a directed edge from `i` to `j`.\n        The goal is to check if all nodes are reachable from node 0.\n\n        We use an iterative Depth-First Search (DFS) approach.\n\n        1. A `stack` is used to keep track of rooms to visit, initialized with room 0.\n        2. A `visited` set stores the rooms that have been visited to avoid cycles\n           and redundant processing. Room 0 is initially marked as visited.\n        3. The traversal continues until the stack is empty. In each step, a room\n           is popped from the stack, and for each key found in it, if the\n           corresponding room hasn't been visited, it's marked as visited and\n           pushed onto the stack.\n        4. After the traversal, if the count of visited rooms equals the total\n           number of rooms, it means all rooms are reachable.\n        \"\"\"\n        \n        # The stack for the DFS traversal, starting with room 0.\n        stack = [0]\n        \n        # A set to keep track of visited rooms, initialized with room 0.\n        visited = {0}\n\n        while stack:\n            # Get the next room to visit from the stack.\n            room = stack.pop()\n\n            # For each key in the current room, explore the new room if not visited.\n            for key in rooms[room]:\n                if key not in visited:\n                    # Mark the new room as visited.\n                    visited.add(key)\n                    # Add the new room to the stack to visit its neighbors.\n                    stack.append(key)\n        \n        # If the number of visited rooms equals the total number of rooms,\n        # all rooms are accessible.\n        return len(visited) == len(rooms)\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:35:49+01:00"
    }
  }
}