{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "901",
        "questionId": "937",
        "Content": "<p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>\n\n<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>\n\n<ul>\n\t<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>\n\t<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>\n</ul>\n\n<p>Implement the <code>StockSpanner</code> class:</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> Initializes the object of the class.</li>\n\t<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>Output</strong>\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>Explanation</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.\nstockSpanner.next(85);  // return 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>\n</ul>\n",
        "SampleTestCase": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "ExampleTestcases": "[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"]\n[[],[100],[80],[60],[70],[60],[75],[85]]",
        "Difficulty": "Medium",
        "Title": "Online Stock Span",
        "TitleSlug": "online-stock-span",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"533.2K\", \"totalSubmission\": \"780.3K\", \"totalAcceptedRaw\": 533155, \"totalSubmissionRaw\": 780342, \"acRate\": \"68.3%\"}",
        "Likes": 7070,
        "Dislikes": 486,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjE1",
            "Name": "Stack",
            "Slug": "stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU0",
            "Name": "Monotonic Stack",
            "Slug": "monotonic-stack"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class StockSpanner(object):\n\n    def __init__(self):\n        \n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar StockSpanner = function() {\n    \n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    \n};\n\n/** \n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class StockSpanner {\n    constructor() {\n        \n    }\n\n    next(price: number): number {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int Next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.Next(price);\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} StockSpanner;\n\n\nStockSpanner* stockSpannerCreate() {\n    \n}\n\nint stockSpannerNext(StockSpanner* obj, int price) {\n    \n}\n\nvoid stockSpannerFree(StockSpanner* obj) {\n    \n}\n\n/**\n * Your StockSpanner struct will be instantiated and called as such:\n * StockSpanner* obj = stockSpannerCreate();\n * int param_1 = stockSpannerNext(obj, price);\n \n * stockSpannerFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type StockSpanner struct {\n    \n}\n\n\nfunc Constructor() StockSpanner {\n    \n}\n\n\nfunc (this *StockSpanner) Next(price int) int {\n    \n}\n\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Next(price);\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class StockSpanner() {\n\n    fun next(price: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = StockSpanner()\n * var param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass StockSpanner {\n\n    init() {\n        \n    }\n    \n    func next(_ price: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner()\n * let ret_1: Int = obj.next(price)\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct StockSpanner {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockSpanner {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn next(&self, price: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner::new();\n * let ret_1: i32 = obj.next(price);\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class StockSpanner\n    def initialize()\n        \n    end\n\n\n=begin\n    :type price: Integer\n    :rtype: Integer\n=end\n    def next(price)\n        \n    end\n\n\nend\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner.new()\n# param_1 = obj.next(price)"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class StockSpanner {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $price\n     * @return Integer\n     */\n    function next($price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * $obj = StockSpanner();\n * $ret_1 = $obj->next($price);\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class StockSpanner {\n\n  StockSpanner() {\n    \n  }\n  \n  int next(int price) {\n    \n  }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = StockSpanner();\n * int param1 = obj.next(price);\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class StockSpanner() {\n\n    def next(price: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * val obj = new StockSpanner()\n * val param_1 = obj.next(price)\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule StockSpanner do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec next(price :: integer) :: integer\n  def next(price) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockSpanner.init_()\n# param_1 = StockSpanner.next(price)\n\n# StockSpanner.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec stock_spanner_init_() -> any().\nstock_spanner_init_() ->\n  .\n\n-spec stock_spanner_next(Price :: integer()) -> integer().\nstock_spanner_next(Price) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_spanner_init_(),\n%% Param_1 = stock_spanner_next(Price),\n\n%% stock_spanner_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define stock-spanner%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; next : exact-integer? -> exact-integer?\n    (define/public (next price)\n      )))\n\n;; Your stock-spanner% object will be instantiated and called as such:\n;; (define obj (new stock-spanner%))\n;; (define param_1 (send obj next price))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:50:37.88752+01:00",
    "AcRate": "68.3",
    "TotalSubmissions": 780342,
    "TotalAccepted": 533155,
    "AcceptanceRate": 0.683232480117692,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/online-stock-span/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.\nThe span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.\n\tFor example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.\n\tAlso, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.\nImplement the StockSpanner class:\n\tStockSpanner() Initializes the object of the class.\n\tint next(int price) Returns the span of the stock's price given that today's price is price.\n\u00a0\nExample 1:\nInput\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n[[], [100], [80], [60], [70], [60], [75], [85]]\nOutput\n[null, 1, 1, 1, 2, 1, 4, 6]\nExplanation\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.\nstockSpanner.next(85);  // return 6\n\u00a0\nConstraints:\n\t1 <= price <= 10^5\n\tAt most 10^4 calls will be made to next.\n\nHere is the code snippet, which you should expand with your solution: class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient way to solve this problem is by using a monotonic stack. The stack will store pairs of `(price, span)`, where `price` is a price from a previous day and `span` is the calculated span for that price. We will maintain the stack in a way that the prices are monotonically decreasing from the bottom to the top.\n\nHere's the logic for the `next(price)` method:\n1. Initialize the `span` for the current day's `price` to 1 (counting the day itself).\n2. Look at the top of the stack. As long as the stack is not empty and the price on top of the stack is less than or equal to the current `price`, we can extend the current span.\n3. The reason we can do this is that if a past price `p_past` is less than or equal to the current price `p_current`, then any day that contributed to `p_past`'s span (i.e., had a price `<= p_past`) must also have a price `<= p_current`.\n4. Therefore, we can add the entire span of the weaker (smaller or equal) past price to our current `span` and then remove that past price from the stack. We repeat this process, accumulating spans, until we find a price on the stack that is strictly greater than the current price, or the stack becomes empty.\n5. After the loop, the `current_span` is the correct total span for the current day's price.\n6. Finally, we push the current `(price, current_span)` pair onto the stack to be used for future calculations. This maintains the monotonic property of the stack, as all smaller or equal preceding prices have been removed.\n\nThis approach ensures that each price is pushed onto and popped from the stack at most once over all calls to `next`. This results in an amortized time complexity of O(1) for each call, and a total time complexity of O(N) for N calls, which is highly efficient.\n\n```python\nclass StockSpanner:\n\n    def __init__(self):\n        # The stack will store tuples of (price, span).\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        # While the stack is not empty and the price at the top \n        # is less than or equal to the current price.\n        while self.stack and self.stack[-1][0] <= price:\n            # Add the span of the popped element to the current span.\n            span += self.stack.pop()[1]\n        \n        # Push the current price and its calculated span onto the stack.\n        self.stack.append((price, span))\n        \n        return span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n```",
      "TypedCode": "\nclass StockSpanner:\n\n    def __init__(self):\n        # The stack will store tuples of (price, span).\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        # While the stack is not empty and the price at the top \n        # is less than or equal to the current price.\n        while self.stack and self.stack[-1][0] <= price:\n            # Add the span of the popped element to the current span.\n            span += self.stack.pop()[1]\n        \n        # Push the current price and its calculated span onto the stack.\n        self.stack.append((price, span))\n        \n        return span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 98866481416,
      "SolvedAt": "2025-11-20T17:57:38.445587+01:00",
      "PromptTokens": 792,
      "OutputTokens": 12244
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "937",
        "typed_code": "\nclass StockSpanner:\n\n    def __init__(self):\n        # The stack will store tuples of (price, span).\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        \n        # While the stack is not empty and the price at the top \n        # is less than or equal to the current price.\n        while self.stack and self.stack[-1][0] <= price:\n            # Add the span of the popped element to the current span.\n            span += self.stack.pop()[1]\n        \n        # Push the current price and its calculated span onto the stack.\n        self.stack.append((price, span))\n        \n        return span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:15:43+01:00"
    }
  }
}