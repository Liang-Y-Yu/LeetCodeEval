{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "330",
        "questionId": "330",
        "Content": "<p>Given a sorted integer array <code>nums</code> and an integer <code>n</code>, add/patch elements to the array such that any number in the range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array.</p>\n\n<p>Return <em>the minimum number of patches required</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3], n = 6\n<strong>Output:</strong> 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,10], n = 20\n<strong>Output:</strong> 2\nExplanation: The two patches can be [2, 4].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2], n = 5\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "SampleTestCase": "[1,3]\n6",
        "ExampleTestcases": "[1,3]\n6\n[1,5,10]\n20\n[1,2,2]\n5",
        "Difficulty": "Hard",
        "Title": "Patching Array",
        "TitleSlug": "patching-array",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"177K\", \"totalSubmission\": \"328.6K\", \"totalAcceptedRaw\": 176972, \"totalSubmissionRaw\": 328648, \"acRate\": \"53.8%\"}",
        "Likes": 2413,
        "Dislikes": 202,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE3",
            "Name": "Greedy",
            "Slug": "greedy"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number}\n */\nvar minPatches = function(nums, n) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function minPatches(nums: number[], n: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int MinPatches(int[] nums, int n) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int minPatches(int* nums, int numsSize, int n) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func minPatches(nums []int, n int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun minPatches(nums: IntArray, n: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func minPatches(_ nums: [Int], _ n: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn min_patches(nums: Vec<i32>, n: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} n\n# @return {Integer}\ndef min_patches(nums, n)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $n\n     * @return Integer\n     */\n    function minPatches($nums, $n) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int minPatches(List<int> nums, int n) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def minPatches(nums: Array[Int], n: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec min_patches(nums :: [integer], n :: integer) :: integer\n  def min_patches(nums, n) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec min_patches(Nums :: [integer()], N :: integer()) -> integer().\nmin_patches(Nums, N) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (min-patches nums n)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:22:26.994463+01:00",
    "AcRate": "53.8",
    "TotalSubmissions": 328648,
    "TotalAccepted": 176972,
    "AcceptanceRate": 0.5384849443781797,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/patching-array/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\nReturn the minimum number of patches required.\n\u00a0\nExample 1:\nInput: nums = [1,3], n = 6\nOutput: 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\nExample 2:\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\nExample 3:\nInput: nums = [1,2,2], n = 5\nOutput: 0\n\u00a0\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 10^4\n\tnums is sorted in ascending order.\n\t1 <= n <= 2^31 - 1\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and efficient solution to this problem can be achieved using a greedy approach. The core idea is to keep track of the smallest number that we cannot yet form with the numbers we have. Let's call this number `miss`.\n\nInitially, with an empty set of numbers, the smallest sum we can't form is 1. So, we initialize `miss = 1`. This also means we can form all sums in the range `[1, miss - 1]`, which is an empty range `[1, 0]` at the start.\n\nOur goal is to be able to form all numbers up to `n`. This means we need to extend our reachable range until `miss` is greater than `n`.\n\nWe iterate as long as `miss <= n`. In each step, we decide how to cover the current `miss`:\n\n1.  **Use an existing number from `nums`**: If we have a number `x` in our array `nums` such that `x <= miss`, we can use it to extend our range of reachable sums. If we could already form all sums in `[1, miss - 1]`, by including `x`, we can now form all sums in `[1, miss - 1 + x]`. So, the new `miss` becomes `miss + x`. Since `nums` is sorted, we process its elements in order. This is a \"free\" extension of our range as it doesn't require a patch.\n\n2.  **Add a patch**: If the next number in `nums` is greater than `miss`, or if we have used all numbers in `nums`, we are stuck. We cannot form `miss` with the numbers we have. To proceed, we must add a patch. The most efficient number to patch is `miss` itself. By adding `miss` to our set of numbers, we extend our reachable range from `[1, miss - 1]` to `[1, miss - 1 + miss] = [1, 2 * miss - 1]`. The new `miss` becomes `2 * miss`. This operation costs one patch.\n\nThis greedy strategy is optimal because at each step, we extend the range of formable sums as much as possible, either by using an existing number for free or by adding the most effective patch.\n\nThe algorithm proceeds as follows:\n1. Initialize `miss = 1`, `patches = 0`, and an index `i = 0` for `nums`.\n2. While `miss <= n`:\n   a. If `i` is within the bounds of `nums` and `nums[i] <= miss`, update `miss += nums[i]` and increment `i`.\n   b. Otherwise, patch the array by adding `miss`. Update `miss += miss` and increment `patches`.\n3. Return `patches`.\n\nThis approach ensures that `miss` grows, guaranteeing loop termination. The time complexity is O(len(nums) + log n) because `i` iterates through `nums` once, and `miss` grows exponentially in the patching steps. The space complexity is O(1).\n\n```python\nfrom typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        miss = 1\n        patches = 0\n        i = 0\n        \n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        \n        return patches\n```",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        miss = 1\n        patches = 0\n        i = 0\n        \n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        \n        return patches\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 106004438625,
      "SolvedAt": "2025-11-20T18:09:32.727264+01:00",
      "PromptTokens": 543,
      "OutputTokens": 13821
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "330",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        miss = 1\n        patches = 0\n        i = 0\n        \n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        \n        return patches\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:11:29+01:00"
    }
  }
}