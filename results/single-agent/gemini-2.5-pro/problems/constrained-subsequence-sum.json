{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1425",
        "questionId": "1286",
        "Content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the maximum sum of a <strong>non-empty</strong> subsequence of that array such that for every two <strong>consecutive</strong> integers in the subsequence, <code>nums[i]</code> and <code>nums[j]</code>, where <code>i &lt; j</code>, the condition <code>j - i &lt;= k</code> is satisfied.</p>\n\n<p>A <em>subsequence</em> of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2,-10,5,20], k = 2\n<strong>Output:</strong> 37\n<b>Explanation:</b> The subsequence is [10, 2, 5, 20].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3], k = 1\n<strong>Output:</strong> -1\n<b>Explanation:</b> The subsequence must be non-empty, so we choose the largest number.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,-2,-10,-5,20], k = 2\n<strong>Output:</strong> 23\n<b>Explanation:</b> The subsequence is [10, -2, -5, 20].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[10,2,-10,5,20]\n2",
        "ExampleTestcases": "[10,2,-10,5,20]\n2\n[-1,-2,-3]\n1\n[10,-2,-10,-5,20]\n2",
        "Difficulty": "Hard",
        "Title": "Constrained Subsequence Sum",
        "TitleSlug": "constrained-subsequence-sum",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"88.8K\", \"totalSubmission\": \"157.6K\", \"totalAcceptedRaw\": 88847, \"totalSubmissionRaw\": 157638, \"acRate\": \"56.4%\"}",
        "Likes": 2219,
        "Dislikes": 108,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjM0",
            "Name": "Queue",
            "Slug": "queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjU1ODIx",
            "Name": "Sliding Window",
            "Slug": "sliding-window"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcx",
            "Name": "Monotonic Queue",
            "Slug": "monotonic-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int constrainedSubsetSum(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def constrainedSubsetSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar constrainedSubsetSum = function(nums, k) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function constrainedSubsetSum(nums: number[], k: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int ConstrainedSubsetSum(int[] nums, int k) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int constrainedSubsetSum(int* nums, int numsSize, int k) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func constrainedSubsetSum(nums []int, k int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun constrainedSubsetSum(nums: IntArray, k: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef constrained_subset_sum(nums, k)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function constrainedSubsetSum($nums, $k) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int constrainedSubsetSum(List<int> nums, int k) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def constrainedSubsetSum(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec constrained_subset_sum(nums :: [integer], k :: integer) :: integer\n  def constrained_subset_sum(nums, k) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec constrained_subset_sum(Nums :: [integer()], K :: integer()) -> integer().\nconstrained_subset_sum(Nums, K) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (constrained-subset-sum nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:35:49.392471+01:00",
    "AcRate": "56.4",
    "TotalSubmissions": 157638,
    "TotalAccepted": 88847,
    "AcceptanceRate": 0.5636141031984674,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/constrained-subsequence-sum/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\nA subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n\u00a0\nExample 1:\nInput: nums = [10,2,-10,5,20], k = 2\nOutput: 37\nExplanation: The subsequence is [10, 2, 5, 20].\nExample 2:\nInput: nums = [-1,-2,-3], k = 1\nOutput: -1\nExplanation: The subsequence must be non-empty, so we choose the largest number.\nExample 3:\nInput: nums = [10,-2,-10,-5,20], k = 2\nOutput: 23\nExplanation: The subsequence is [10, -2, -5, 20].\n\u00a0\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t-10^4 <= nums[i] <= 10^4\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant explanation of the method, followed by the complete code.\nThe user wants me to solve the \"Constrained Subset Sum\" problem.\n\n### Method Explanation\n\nThis problem asks for the maximum sum of a subsequence with a constraint on the indices of consecutive elements. This structure suggests a dynamic programming approach.\n\nLet `dp[i]` be the maximum sum of a valid subsequence ending at index `i`. To form such a subsequence, we must include `nums[i]`. The element preceding `nums[i]` in the subsequence, say `nums[j]`, must satisfy `i - k <= j < i`. To maximize `dp[i]`, we should choose the predecessor `j` that has the maximum `dp[j]` value.\n\nThe recurrence relation for `dp[i]` is:\n`dp[i] = nums[i] + max(0, max_{i-k <= j < i} dp[j])`\n\nWe take `max(0, ...)` because if all possible `dp[j]` values are negative, it's better to start a new subsequence at `nums[i]` rather than extending a previous one. Starting a new subsequence is equivalent to extending a subsequence of sum 0.\n\nA naive implementation of this DP approach would be `O(N*k)`, as calculating `max_{i-k <= j < i} dp[j]` for each `i` would take `O(k)` time. With `N` and `k` up to 10^5, this is too slow.\n\nTo optimize the calculation of the maximum in the sliding window `[i-k, i-1]`, we can use a monotonic deque. The deque will store indices `j` from the current window, ordered such that their corresponding `dp[j]` values are monotonically decreasing. This way, the index at the front of the deque always corresponds to the maximum `dp` value in the window, allowing for `O(1)` amortized lookup.\n\nThe overall algorithm is as follows:\n1. Initialize a `dp` array of the same size as `nums`.\n2. Initialize a deque to store indices.\n3. Iterate from `i = 0` to `n-1`:\n    a. Remove indices from the front of the deque that are no longer in the `k`-sized window.\n    b. Calculate `dp[i]` using the `dp` value of the index at the front of the deque.\n    c. Update the overall maximum sum found so far.\n    d. Maintain the deque's monotonic property by removing indices from the back that have `dp` values less than or equal to the current `dp[i]`.\n    e. Add the current index `i` to the deque.\n4. The final answer is the overall maximum sum tracked during the iteration.\n\nThis approach has a time complexity of `O(N)` because each index is added to and removed from the deque at most once. The space complexity is `O(N)` for the `dp` array.\n\n```python\nimport collections\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dq = collections.deque()\n        max_so_far = float('-inf')\n\n        for i in range(n):\n            if dq and dq[0] < i - k:\n                dq.popleft()\n\n            prev_max = dp[dq[0]] if dq else 0\n            \n            dp[i] = nums[i] + max(0, prev_max)\n            max_so_far = max(max_so_far, dp[i])\n\n            while dq and dp[i] >= dp[dq[-1]]:\n                dq.pop()\n            \n            dq.append(i)\n            \n        return max_so_far\n\n```",
      "TypedCode": "\nimport collections\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dq = collections.deque()\n        max_so_far = float('-inf')\n\n        for i in range(n):\n            if dq and dq[0] < i - k:\n                dq.popleft()\n\n            prev_max = dp[dq[0]] if dq else 0\n            \n            dp[i] = nums[i] + max(0, prev_max)\n            max_so_far = max(max_so_far, dp[i])\n\n            while dq and dp[i] >= dp[dq[-1]]:\n                dq.pop()\n            \n            dq.append(i)\n            \n        return max_so_far\n\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 192581809583,
      "SolvedAt": "2025-11-20T12:36:12.539342+01:00",
      "PromptTokens": 505,
      "OutputTokens": 25158
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1286",
        "typed_code": "\nimport collections\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dq = collections.deque()\n        max_so_far = float('-inf')\n\n        for i in range(n):\n            if dq and dq[0] < i - k:\n                dq.popleft()\n\n            prev_max = dp[dq[0]] if dq else 0\n            \n            dp[i] = nums[i] + max(0, prev_max)\n            max_so_far = max(max_so_far, dp[i])\n\n            while dq and dp[i] >= dp[dq[-1]]:\n                dq.pop()\n            \n            dq.append(i)\n            \n        return max_so_far\n\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T20:32:38+01:00"
    }
  }
}