{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "68",
        "questionId": "68",
        "Content": "<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n",
        "SampleTestCase": "[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n16",
        "ExampleTestcases": "[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n16\n[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n16\n[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n20",
        "Difficulty": "Hard",
        "Title": "Text Justification",
        "TitleSlug": "text-justification",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"600K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 600049, \"totalSubmissionRaw\": 1208407, \"acRate\": \"49.7%\"}",
        "Likes": 4407,
        "Dislikes": 5283,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDU1",
            "Name": "Simulation",
            "Slug": "simulation"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function fullJustify(words: string[], maxWidth: number): string[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<string> FullJustify(string[] words, int maxWidth) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fullJustify(char** words, int wordsSize, int maxWidth, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func fullJustify(words []string, maxWidth int) []string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String[]} words\n# @param {Integer} max_width\n# @return {String[]}\ndef full_justify(words, max_width)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param Integer $maxWidth\n     * @return String[]\n     */\n    function fullJustify($words, $maxWidth) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<String> fullJustify(List<String> words, int maxWidth) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec full_justify(words :: [String.t], max_width :: integer) :: [String.t]\n  def full_justify(words, max_width) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec full_justify(Words :: [unicode:unicode_binary()], MaxWidth :: integer()) -> [unicode:unicode_binary()].\nfull_justify(Words, MaxWidth) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (full-justify words maxWidth)\n  (-> (listof string?) exact-integer? (listof string?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:35:08.588851+01:00",
    "AcRate": "49.7",
    "TotalSubmissions": 1208407,
    "TotalAccepted": 600049,
    "AcceptanceRate": 0.49656200270273176,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/text-justification/"
  },
  "Solutions": {
    "google/gemini-2.5-pro": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\n\u00a0\nExample 1:\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n]\nExample 2:\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n]\n\u00a0\nConstraints:\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "An elegant and effective solution can be achieved by processing the words line by line. The core of the algorithm involves two main steps for each line: first, greedily determining how many words can fit, and second, formatting those words according to the justification rules.\n\nHere's a step-by-step breakdown of the approach:\n\n1.  **Iterate and Pack Lines:**\n    *   We traverse the `words` array using a pointer, say `i`, which marks the beginning of the words for the current line.\n    *   From `i`, we use another pointer, `j`, to find the maximum number of words that can fit on a single line without exceeding `maxWidth`. To check if a new word fits, we calculate the potential line length: `(sum of lengths of words) + (number of mandatory single spaces)`.\n    *   Once we've identified the words for the current line (from index `i` to `j-1`), we proceed to the formatting step.\n\n2.  **Format Lines:**\n    *   There are two main formatting scenarios: full justification and left justification.\n    *   **Left Justification:** This applies to two specific cases:\n        1.  The very last line of the text.\n        2.  Any line that contains only a single word.\n        To left-justify, we join the words with a single space and then pad the right side with enough spaces to make the line's total length equal to `maxWidth`.\n    *   **Full Justification:** This applies to all other lines (i.e., not the last line and containing more than one word).\n        1.  Calculate the total number of spaces that need to be distributed: `total_spaces = maxWidth - (sum of lengths of all words on the line)`.\n        2.  Calculate the number of \"gaps\" between words: `num_gaps = num_words - 1`.\n        3.  Distribute the `total_spaces` as evenly as possible among the `num_gaps`. The base number of spaces for each gap is `total_spaces // num_gaps`.\n        4.  Any leftover spaces (`total_spaces % num_gaps`) are distributed one by one to the gaps on the left until they run out.\n        5.  Construct the line by concatenating the words with their calculated number of spaces in between.\n\n3.  **Repeat:**\n    *   After a line is formatted and added to our result list, we update the starting pointer `i` to `j` and repeat the process for the next line, continuing until all words have been formatted.\n\nThis approach ensures that all requirements, including the greedy packing and the specific justification rules for different line types, are met correctly and efficiently.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Step 1: Greedily determine which words fit on the current line.\n            j = i\n            line_words_len = 0\n            while j < n:\n                # Minimum length of the line if words[j] is added:\n                # sum of word lengths + number of single-space gaps.\n                # Number of gaps would be (j - i).\n                len_with_new_word = line_words_len + len(words[j]) + (j - i)\n                if len_with_new_word > maxWidth:\n                    break\n                line_words_len += len(words[j])\n                j += 1\n            \n            # The words for the current line are from index i to j-1.\n            line_words = words[i:j]\n            num_words = len(line_words)\n            \n            # Step 2: Format the selected words into a line.\n            is_last_line = (j == n)\n\n            # Case A: Left-justification (last line or a single-word line).\n            if is_last_line or num_words == 1:\n                line_str = \" \".join(line_words)\n                trailing_spaces = maxWidth - len(line_str)\n                res.append(line_str + ' ' * trailing_spaces)\n            \n            # Case B: Full-justification (all other lines).\n            else:\n                num_gaps = num_words - 1\n                total_spaces = maxWidth - line_words_len\n                \n                base_spaces = total_spaces // num_gaps\n                extra_spaces = total_spaces % num_gaps\n                \n                line_builder = []\n                for k in range(num_gaps):\n                    line_builder.append(line_words[k])\n                    \n                    # Add spaces for the current gap.\n                    # The first 'extra_spaces' gaps get one additional space.\n                    num_spaces_to_add = base_spaces\n                    if k < extra_spaces:\n                        num_spaces_to_add += 1\n                    line_builder.append(' ' * num_spaces_to_add)\n                \n                # Add the last word of the line.\n                line_builder.append(line_words[-1])\n                res.append(\"\".join(line_builder))\n\n            # Move the pointer to the start of the next line.\n            i = j\n            \n        return res\n```",
      "TypedCode": "\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Step 1: Greedily determine which words fit on the current line.\n            j = i\n            line_words_len = 0\n            while j < n:\n                # Minimum length of the line if words[j] is added:\n                # sum of word lengths + number of single-space gaps.\n                # Number of gaps would be (j - i).\n                len_with_new_word = line_words_len + len(words[j]) + (j - i)\n                if len_with_new_word > maxWidth:\n                    break\n                line_words_len += len(words[j])\n                j += 1\n            \n            # The words for the current line are from index i to j-1.\n            line_words = words[i:j]\n            num_words = len(line_words)\n            \n            # Step 2: Format the selected words into a line.\n            is_last_line = (j == n)\n\n            # Case A: Left-justification (last line or a single-word line).\n            if is_last_line or num_words == 1:\n                line_str = \" \".join(line_words)\n                trailing_spaces = maxWidth - len(line_str)\n                res.append(line_str + ' ' * trailing_spaces)\n            \n            # Case B: Full-justification (all other lines).\n            else:\n                num_gaps = num_words - 1\n                total_spaces = maxWidth - line_words_len\n                \n                base_spaces = total_spaces // num_gaps\n                extra_spaces = total_spaces % num_gaps\n                \n                line_builder = []\n                for k in range(num_gaps):\n                    line_builder.append(line_words[k])\n                    \n                    # Add spaces for the current gap.\n                    # The first 'extra_spaces' gaps get one additional space.\n                    num_spaces_to_add = base_spaces\n                    if k < extra_spaces:\n                        num_spaces_to_add += 1\n                    line_builder.append(' ' * num_spaces_to_add)\n                \n                # Add the last word of the line.\n                line_builder.append(line_words[-1])\n                res.append(\"\".join(line_builder))\n\n            # Move the pointer to the start of the next line.\n            i = j\n            \n        return res\n",
      "Model": "google/gemini-2.5-pro",
      "Latency": 117241422667,
      "SolvedAt": "2025-11-20T19:21:48.214203+01:00",
      "PromptTokens": 797,
      "OutputTokens": 13736
    }
  },
  "Submissions": {
    "google/gemini-2.5-pro": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "68",
        "typed_code": "\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Step 1: Greedily determine which words fit on the current line.\n            j = i\n            line_words_len = 0\n            while j < n:\n                # Minimum length of the line if words[j] is added:\n                # sum of word lengths + number of single-space gaps.\n                # Number of gaps would be (j - i).\n                len_with_new_word = line_words_len + len(words[j]) + (j - i)\n                if len_with_new_word > maxWidth:\n                    break\n                line_words_len += len(words[j])\n                j += 1\n            \n            # The words for the current line are from index i to j-1.\n            line_words = words[i:j]\n            num_words = len(line_words)\n            \n            # Step 2: Format the selected words into a line.\n            is_last_line = (j == n)\n\n            # Case A: Left-justification (last line or a single-word line).\n            if is_last_line or num_words == 1:\n                line_str = \" \".join(line_words)\n                trailing_spaces = maxWidth - len(line_str)\n                res.append(line_str + ' ' * trailing_spaces)\n            \n            # Case B: Full-justification (all other lines).\n            else:\n                num_gaps = num_words - 1\n                total_spaces = maxWidth - line_words_len\n                \n                base_spaces = total_spaces // num_gaps\n                extra_spaces = total_spaces % num_gaps\n                \n                line_builder = []\n                for k in range(num_gaps):\n                    line_builder.append(line_words[k])\n                    \n                    # Add spaces for the current gap.\n                    # The first 'extra_spaces' gaps get one additional space.\n                    num_spaces_to_add = base_spaces\n                    if k < extra_spaces:\n                        num_spaces_to_add += 1\n                    line_builder.append(' ' * num_spaces_to_add)\n                \n                # Add the last word of the line.\n                line_builder.append(line_words[-1])\n                res.append(\"\".join(line_builder))\n\n            # Move the pointer to the start of the next line.\n            i = j\n            \n        return res\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T19:50:05+01:00"
    }
  }
}