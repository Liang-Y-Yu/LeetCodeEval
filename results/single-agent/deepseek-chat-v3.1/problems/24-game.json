{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "679",
        "questionId": "679",
        "Content": "<p>You are given an integer array <code>cards</code> of length <code>4</code>. You have four cards, each containing a number in the range <code>[1, 9]</code>. You should arrange the numbers on these cards in a mathematical expression using the operators <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> and the parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> to get the value 24.</p>\n\n<p>You are restricted with the following rules:</p>\n\n<ul>\n\t<li>The division operator <code>&#39;/&#39;</code> represents real division, not integer division.\n\n\t<ul>\n\t\t<li>For example, <code>4 / (1 - 2 / 3) = 4 / (1 / 3) = 12</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Every operation done is between two numbers. In particular, we cannot use <code>&#39;-&#39;</code> as a unary operator.\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 1, 1, 1]</code>, the expression <code>&quot;-1 - 1 - 1 - 1&quot;</code> is <strong>not allowed</strong>.</li>\n\t</ul>\n\t</li>\n\t<li>You cannot concatenate numbers together\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 2, 1, 2]</code>, the expression <code>&quot;12 + 12&quot;</code> is not valid.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <code>true</code> if you can get such expression that evaluates to <code>24</code>, and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [4,1,8,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [1,2,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n",
        "SampleTestCase": "[4,1,8,7]",
        "ExampleTestcases": "[4,1,8,7]\n[1,2,1,2]",
        "Difficulty": "Hard",
        "Title": "24 Game",
        "TitleSlug": "24-game",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"164.2K\", \"totalSubmission\": \"277.3K\", \"totalAcceptedRaw\": 164151, \"totalSubmissionRaw\": 277296, \"acRate\": \"59.2%\"}",
        "Likes": 1872,
        "Dislikes": 288,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjg=",
            "Name": "Math",
            "Slug": "math"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool judgePoint24(vector<int>& cards) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean judgePoint24(int[] cards) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} cards\n * @return {boolean}\n */\nvar judgePoint24 = function(cards) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function judgePoint24(cards: number[]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool JudgePoint24(int[] cards) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool judgePoint24(int* cards, int cardsSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func judgePoint24(cards []int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun judgePoint24(cards: IntArray): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func judgePoint24(_ cards: [Int]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn judge_point24(cards: Vec<i32>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} cards\n# @return {Boolean}\ndef judge_point24(cards)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $cards\n     * @return Boolean\n     */\n    function judgePoint24($cards) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool judgePoint24(List<int> cards) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def judgePoint24(cards: Array[Int]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec judge_point24(cards :: [integer]) :: boolean\n  def judge_point24(cards) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec judge_point24(Cards :: [integer()]) -> boolean().\njudge_point24(Cards) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (judge-point24 cards)\n  (-> (listof exact-integer?) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:06:56.163065+01:00",
    "AcRate": "59.2",
    "TotalSubmissions": 277296,
    "TotalAccepted": 164151,
    "AcceptanceRate": 0.5919703133114073,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/24-game/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\nYou are restricted with the following rules:\n\tThe division operator '/' represents real division, not integer division.\n\t\n\t\tFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\t\n\t\n\tEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n\t\n\t\tFor example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n\t\n\t\n\tYou cannot concatenate numbers together\n\t\n\t\tFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\n\t\n\t\nReturn true if you can get such expression that evaluates to 24, and false otherwise.\n\u00a0\nExample 1:\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\nExample 2:\nInput: cards = [1,2,1,2]\nOutput: false\n\u00a0\nConstraints:\n\tcards.length == 4\n\t1 <= cards[i] <= 9\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to determine if we can use the four given numbers (each between 1 and 9) and the operators ['+', '-', '*', '/'] along with parentheses to form an expression that evaluates to 24. The solution involves exploring all possible ways to combine the numbers and operations while adhering to the given rules.\n\n### Approach\n1. **Problem Analysis**: The problem requires checking all possible combinations of the four numbers and the operations (including the use of parentheses) to see if any combination results in 24. The challenge is to efficiently explore these combinations without missing any valid expression.\n2. **Key Insight**: The expressions can be built by combining two numbers at a time with an operator, effectively reducing the number of elements until one remains. This suggests a recursive approach where we:\n   - Consider all pairs of numbers in the current list and apply each operator to them.\n   - Replace the two numbers with the result of the operation, and recursively process the new list.\n   - Base case: when the list has only one number, check if it is approximately 24 (due to floating point precision issues).\n3. **Handling Parentheses**: The recursive method naturally accounts for all parenthetical groupings because it considers every possible order of operations. For instance, combining (a op b) first and then (result op c) is equivalent to (a op b) op c, which matches one way of parenthesizing.\n4. **Precision Handling**: Since we are using real division and floating point arithmetic, we should compare the result with a tolerance (e.g., 1e-6) to avoid precision errors.\n5. **Algorithm Selection**: We use a recursive function that:\n   - If the list has one element, check if it is close to 24.\n   - Otherwise, iterate over all pairs of indices (i, j) in the list. For each pair, generate all possible results by applying each operator (considering both orders for non-commutative operations).\n   - For each result, create a new list without the two chosen numbers and with the result added, then recursively call the function on this new list.\n6. **Efficiency**: There are 4! = 24 permutations of the numbers, but we are generating pairs recursively. The recursion depth is 3 (since we start with 4 numbers and reduce by one each time), and at each step, the number of pairs is manageable.\n\n### Solution Code\n```python\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            n = len(nums)\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    new_nums = []\n                    for k in range(n):\n                        if k != i and k != j:\n                            new_nums.append(nums[k])\n                    for op in range(4):\n                        if op == 0:\n                            new_nums.append(nums[i] + nums[j])\n                        elif op == 1:\n                            new_nums.append(nums[i] - nums[j])\n                        elif op == 2:\n                            new_nums.append(nums[i] * nums[j])\n                        elif op == 3:\n                            if nums[j] != 0:\n                                new_nums.append(nums[i] / nums[j])\n                            else:\n                                continue\n                        if dfs(new_nums):\n                            return True\n                        new_nums.pop()\n            return False\n        return dfs(cards)\n```\n\n### Explanation\n1. **Base Case**: The recursive function `dfs` checks if the current list of numbers has only one element. If that element is approximately 24 (within a tolerance of 1e-6), it returns True.\n2. **Recursive Case**: For each pair of indices (i, j) in the current list (where i != j), the function creates a new list excluding these two indices. It then applies each operator (+, -, *, /) to the numbers at indices i and j. For division, it checks for division by zero.\n3. **Recursion**: The result of the operation is added to the new list, and `dfs` is called recursively on this list. If any recursive call returns True, the function returns True.\n4. **Backtracking**: After processing each operation, the result is removed from the new list (backtracking) to ensure correctness for subsequent operations.\n5. **Initial Call**: The function starts with the original list of four cards and recursively explores all possible expressions, returning True if any expression evaluates to 24, otherwise False.\n\nThis approach efficiently explores all possible expressions by leveraging recursion and backtracking, ensuring correctness while handling floating point precision appropriately.",
      "TypedCode": "\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            n = len(nums)\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    new_nums = []\n                    for k in range(n):\n                        if k != i and k != j:\n                            new_nums.append(nums[k])\n                    for op in range(4):\n                        if op == 0:\n                            new_nums.append(nums[i] + nums[j])\n                        elif op == 1:\n                            new_nums.append(nums[i] - nums[j])\n                        elif op == 2:\n                            new_nums.append(nums[i] * nums[j])\n                        elif op == 3:\n                            if nums[j] != 0:\n                                new_nums.append(nums[i] / nums[j])\n                            else:\n                                continue\n                        if dfs(new_nums):\n                            return True\n                        new_nums.pop()\n            return False\n        return dfs(cards)\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 15614306291,
      "SolvedAt": "2025-11-20T21:11:45.790438+01:00",
      "PromptTokens": 531,
      "OutputTokens": 996
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "679",
        "typed_code": "\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            n = len(nums)\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    new_nums = []\n                    for k in range(n):\n                        if k != i and k != j:\n                            new_nums.append(nums[k])\n                    for op in range(4):\n                        if op == 0:\n                            new_nums.append(nums[i] + nums[j])\n                        elif op == 1:\n                            new_nums.append(nums[i] - nums[j])\n                        elif op == 2:\n                            new_nums.append(nums[i] * nums[j])\n                        elif op == 3:\n                            if nums[j] != 0:\n                                new_nums.append(nums[i] / nums[j])\n                            else:\n                                continue\n                        if dfs(new_nums):\n                            return True\n                        new_nums.pop()\n            return False\n        return dfs(cards)\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T22:47:48+01:00"
    }
  }
}