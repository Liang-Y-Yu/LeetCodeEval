{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "526",
        "questionId": "526",
        "Content": "<p>Suppose you have <code>n</code> integers labeled <code>1</code> through <code>n</code>. A permutation of those <code>n</code> integers <code>perm</code> (<strong>1-indexed</strong>) is considered a <strong>beautiful arrangement</strong> if for every <code>i</code> (<code>1 &lt;= i &lt;= n</code>), <strong>either</strong> of the following is true:</p>\n\n<ul>\n\t<li><code>perm[i]</code> is divisible by <code>i</code>.</li>\n\t<li><code>i</code> is divisible by <code>perm[i]</code>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of the <strong>beautiful arrangements</strong> that you can construct</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<b>Explanation:</b> \nThe first beautiful arrangement is [1,2]:\n    - perm[1] = 1 is divisible by i = 1\n    - perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n    - perm[1] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm[2] = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n</ul>\n",
        "SampleTestCase": "2",
        "ExampleTestcases": "2\n1",
        "Difficulty": "Medium",
        "Title": "Beautiful Arrangement",
        "TitleSlug": "beautiful-arrangement",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"208.1K\", \"totalSubmission\": \"321.8K\", \"totalAcceptedRaw\": 208060, \"totalSubmissionRaw\": 321792, \"acRate\": \"64.7%\"}",
        "Likes": 3378,
        "Dislikes": 389,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE5",
            "Name": "Bit Manipulation",
            "Slug": "bit-manipulation"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDc4",
            "Name": "Bitmask",
            "Slug": "bitmask"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int countArrangement(int n) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int countArrangement(int n) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def countArrangement(self, n: int) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def countArrangement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number} n\n * @return {number}\n */\nvar countArrangement = function(n) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function countArrangement(n: number): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int CountArrangement(int n) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int countArrangement(int n) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func countArrangement(n int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun countArrangement(n: Int): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func countArrangement(_ n: Int) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn count_arrangement(n: i32) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer} n\n# @return {Integer}\ndef count_arrangement(n)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function countArrangement($n) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int countArrangement(int n) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def countArrangement(n: Int): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec count_arrangement(n :: integer) :: integer\n  def count_arrangement(n) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec count_arrangement(N :: integer()) -> integer().\ncount_arrangement(N) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (count-arrangement n)\n  (-> exact-integer? exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:12:39.465818+01:00",
    "AcRate": "64.7",
    "TotalSubmissions": 321792,
    "TotalAccepted": 208060,
    "AcceptanceRate": 0.6465667263325378,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/beautiful-arrangement/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:\n\tperm[i] is divisible by i.\n\ti is divisible by perm[i].\nGiven an integer n, return the number of the beautiful arrangements that you can construct.\n\u00a0\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: \nThe first beautiful arrangement is [1,2]:\n    - perm[1] = 1 is divisible by i = 1\n    - perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n    - perm[1] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm[2] = 1\nExample 2:\nInput: n = 1\nOutput: 1\n\u00a0\nConstraints:\n\t1 <= n <= 15\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def countArrangement(self, n: int) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to count the number of beautiful arrangements for a given integer `n`. A beautiful arrangement is a permutation of integers from 1 to `n` such that for every index `i` (1-indexed), either `perm[i]` is divisible by `i` or `i` is divisible by `perm[i]`.\n\n### Approach\n1. **Understanding the Problem**: The problem requires generating permutations of numbers from 1 to `n` that satisfy the condition for each position. However, generating all permutations and checking the condition for each one would be inefficient for `n` up to 15 (which has 15! = 1,307,674,368,000 permutations). Hence, a brute-force approach is not feasible.\n\n2. **Backtracking with Pruning**: We can use a backtracking approach that builds the permutation step by step, and at each step, we check if the current number we are about to place satisfies the condition. If it does, we proceed; otherwise, we skip that number. This approach prunes many invalid paths early, making it efficient enough for `n <= 15`.\n\n3. **Recursive Backtracking**:\n   - We define a recursive function that takes the current position we are filling and a list (or a set) of numbers that have already been used.\n   - For each number from 1 to `n` that hasn't been used, check if it satisfies the condition for the current position (i.e., either the number is divisible by the index or the index is divisible by the number).\n   - If it does, mark the number as used and recursively move to the next position.\n   - If we successfully place all numbers (i.e., we reach beyond the last position), we count that as a valid arrangement.\n   - Unmark the number when backtracking to explore other possibilities.\n\n4. **Optimization**: Using a boolean array to track used numbers is efficient. The recursion depth is `n`, and at each step, we check up to `n` numbers. The worst-case time complexity is still factorial, but with pruning, it becomes manageable for `n=15`.\n\n### Solution Code\n```python\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        def backtrack(pos, used):\n            if pos > n:\n                self.count += 1\n                return\n            for num in range(1, n+1):\n                if not used[num]:\n                    if num % pos == 0 or pos % num == 0:\n                        used[num] = True\n                        backtrack(pos+1, used)\n                        used[num] = False\n        \n        self.count = 0\n        used = [False] * (n+1)\n        backtrack(1, used)\n        return self.count\n```\n\n### Explanation\n1. **Initialization**: We initialize a counter `self.count` to zero and a boolean list `used` of size `n+1` (indexed from 1 to `n`) to keep track of which numbers have been used in the current permutation.\n2. **Backtracking Function**: The `backtrack` function is defined to take the current position `pos` (starting at 1) and the `used` array.\n   - **Base Case**: If `pos` exceeds `n`, it means we have successfully placed all numbers, so we increment the count.\n   - **Recursive Step**: For each number from 1 to `n`, if it hasn't been used, check if it satisfies the condition for the current position. If yes, mark it as used, recursively call `backtrack` for the next position, and then unmark it (backtrack).\n3. **Result**: After exploring all possibilities, `self.count` holds the number of valid beautiful arrangements, which is returned.\n\nThis approach efficiently prunes invalid paths early, making it feasible for the given constraints.",
      "TypedCode": "\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        def backtrack(pos, used):\n            if pos > n:\n                self.count += 1\n                return\n            for num in range(1, n+1):\n                if not used[num]:\n                    if num % pos == 0 or pos % num == 0:\n                        used[num] = True\n                        backtrack(pos+1, used)\n                        used[num] = False\n        \n        self.count = 0\n        used = [False] * (n+1)\n        backtrack(1, used)\n        return self.count\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 21659649667,
      "SolvedAt": "2025-11-20T21:12:50.870718+01:00",
      "PromptTokens": 421,
      "OutputTokens": 811
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "526",
        "typed_code": "\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        def backtrack(pos, used):\n            if pos > n:\n                self.count += 1\n                return\n            for num in range(1, n+1):\n                if not used[num]:\n                    if num % pos == 0 or pos % num == 0:\n                        used[num] = True\n                        backtrack(pos+1, used)\n                        used[num] = False\n        \n        self.count = 0\n        used = [False] * (n+1)\n        backtrack(1, used)\n        return self.count\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T22:26:12+01:00"
    }
  }
}