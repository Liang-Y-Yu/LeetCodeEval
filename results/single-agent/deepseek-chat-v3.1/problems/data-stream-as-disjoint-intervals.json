{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "352",
        "questionId": "352",
        "Content": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n",
        "SampleTestCase": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "ExampleTestcases": "[\"SummaryRanges\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\",\"addNum\",\"getIntervals\"]\n[[],[1],[],[3],[],[7],[],[2],[],[6],[]]",
        "Difficulty": "Hard",
        "Title": "Data Stream as Disjoint Intervals",
        "TitleSlug": "data-stream-as-disjoint-intervals",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"125.3K\", \"totalSubmission\": \"209.8K\", \"totalAcceptedRaw\": 125278, \"totalSubmissionRaw\": 209830, \"acRate\": \"59.7%\"}",
        "Likes": 1795,
        "Dislikes": 371,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEx",
            "Name": "Binary Search",
            "Slug": "binary-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIz",
            "Name": "Union Find",
            "Slug": "union-find"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI1",
            "Name": "Design",
            "Slug": "design"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDYz",
            "Name": "Data Stream",
            "Slug": "data-stream"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDcw",
            "Name": "Ordered Set",
            "Slug": "ordered-set"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class SummaryRanges {\npublic:\n    SummaryRanges() {\n        \n    }\n    \n    void addNum(int value) {\n        \n    }\n    \n    vector<vector<int>> getIntervals() {\n        \n    }\n};\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges* obj = new SummaryRanges();\n * obj->addNum(value);\n * vector<vector<int>> param_2 = obj->getIntervals();\n */"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void addNum(int value) {\n        \n    }\n    \n    public int[][] getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(value);\n * int[][] param_2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class SummaryRanges(object):\n\n    def __init__(self):\n        \n\n    def addNum(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getIntervals(self):\n        \"\"\"\n        :rtype: List[List[int]]\n        \"\"\"\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()"
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "\nvar SummaryRanges = function() {\n    \n};\n\n/** \n * @param {number} value\n * @return {void}\n */\nSummaryRanges.prototype.addNum = function(value) {\n    \n};\n\n/**\n * @return {number[][]}\n */\nSummaryRanges.prototype.getIntervals = function() {\n    \n};\n\n/** \n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "class SummaryRanges {\n    constructor() {\n        \n    }\n\n    addNum(value: number): void {\n        \n    }\n\n    getIntervals(): number[][] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class SummaryRanges {\n\n    public SummaryRanges() {\n        \n    }\n    \n    public void AddNum(int value) {\n        \n    }\n    \n    public int[][] GetIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.AddNum(value);\n * int[][] param_2 = obj.GetIntervals();\n */"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "\n\n\ntypedef struct {\n    \n} SummaryRanges;\n\n\nSummaryRanges* summaryRangesCreate() {\n    \n}\n\nvoid summaryRangesAddNum(SummaryRanges* obj, int value) {\n    \n}\n\nint** summaryRangesGetIntervals(SummaryRanges* obj, int* retSize, int** retColSize) {\n    \n}\n\nvoid summaryRangesFree(SummaryRanges* obj) {\n    \n}\n\n/**\n * Your SummaryRanges struct will be instantiated and called as such:\n * SummaryRanges* obj = summaryRangesCreate();\n * summaryRangesAddNum(obj, value);\n \n * int** param_2 = summaryRangesGetIntervals(obj, retSize, retColSize);\n \n * summaryRangesFree(obj);\n*/"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "type SummaryRanges struct {\n    \n}\n\n\nfunc Constructor() SummaryRanges {\n    \n}\n\n\nfunc (this *SummaryRanges) AddNum(value int)  {\n    \n}\n\n\nfunc (this *SummaryRanges) GetIntervals() [][]int {\n    \n}\n\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddNum(value);\n * param_2 := obj.GetIntervals();\n */"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class SummaryRanges() {\n\n    fun addNum(value: Int) {\n        \n    }\n\n    fun getIntervals(): Array<IntArray> {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = SummaryRanges()\n * obj.addNum(value)\n * var param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "\nclass SummaryRanges {\n\n    init() {\n        \n    }\n    \n    func addNum(_ value: Int) {\n        \n    }\n    \n    func getIntervals() -> [[Int]] {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges()\n * obj.addNum(value)\n * let ret_2: [[Int]] = obj.getIntervals()\n */"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "struct SummaryRanges {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SummaryRanges {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add_num(&self, value: i32) {\n        \n    }\n    \n    fn get_intervals(&self) -> Vec<Vec<i32>> {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * let obj = SummaryRanges::new();\n * obj.add_num(value);\n * let ret_2: Vec<Vec<i32>> = obj.get_intervals();\n */"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "class SummaryRanges\n    def initialize()\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Void\n=end\n    def add_num(value)\n        \n    end\n\n\n=begin\n    :rtype: Integer[][]\n=end\n    def get_intervals()\n        \n    end\n\n\nend\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges.new()\n# obj.add_num(value)\n# param_2 = obj.get_intervals()"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class SummaryRanges {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return NULL\n     */\n    function addNum($value) {\n        \n    }\n  \n    /**\n     * @return Integer[][]\n     */\n    function getIntervals() {\n        \n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * $obj = SummaryRanges();\n * $obj->addNum($value);\n * $ret_2 = $obj->getIntervals();\n */"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class SummaryRanges {\n\n  SummaryRanges() {\n    \n  }\n  \n  void addNum(int value) {\n    \n  }\n  \n  List<List<int>> getIntervals() {\n    \n  }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = SummaryRanges();\n * obj.addNum(value);\n * List<List<int>> param2 = obj.getIntervals();\n */"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "class SummaryRanges() {\n\n    def addNum(value: Int): Unit = {\n        \n    }\n\n    def getIntervals(): Array[Array[Int]] = {\n        \n    }\n\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * val obj = new SummaryRanges()\n * obj.addNum(value)\n * val param_2 = obj.getIntervals()\n */"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule SummaryRanges do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add_num(value :: integer) :: any\n  def add_num(value) do\n    \n  end\n\n  @spec get_intervals() :: [[integer]]\n  def get_intervals() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SummaryRanges.init_()\n# SummaryRanges.add_num(value)\n# param_2 = SummaryRanges.get_intervals()\n\n# SummaryRanges.init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec summary_ranges_init_() -> any().\nsummary_ranges_init_() ->\n  .\n\n-spec summary_ranges_add_num(Value :: integer()) -> any().\nsummary_ranges_add_num(Value) ->\n  .\n\n-spec summary_ranges_get_intervals() -> [[integer()]].\nsummary_ranges_get_intervals() ->\n  .\n\n\n%% Your functions will be called as such:\n%% summary_ranges_init_(),\n%% summary_ranges_add_num(Value),\n%% Param_2 = summary_ranges_get_intervals(),\n\n%% summary_ranges_init_ will be called before every test case, in which you can do some necessary initializations."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define summary-ranges%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add-num : exact-integer? -> void?\n    (define/public (add-num value)\n      )\n    ; get-intervals : -> (listof (listof exact-integer?))\n    (define/public (get-intervals)\n      )))\n\n;; Your summary-ranges% object will be instantiated and called as such:\n;; (define obj (new summary-ranges%))\n;; (send obj add-num value)\n;; (define param_2 (send obj get-intervals))"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:21:39.253726+01:00",
    "AcRate": "59.7",
    "TotalSubmissions": 209830,
    "TotalAccepted": 125278,
    "AcceptanceRate": 0.5970452270885955,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "multi",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "multi",
      "python3": "multi",
      "racket": "",
      "ruby": "multi",
      "rust": "",
      "scala": "multi",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\nImplement the SummaryRanges class:\n\tSummaryRanges() Initializes the object with an empty stream.\n\tvoid addNum(int value) Adds the integer value to the stream.\n\tint[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n\u00a0\nExample 1:\nInput\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\nOutput\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\nExplanation\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n\u00a0\nConstraints:\n\t0 <= value <= 10^4\n\tAt most 3 * 10^4 calls will be made to addNum and getIntervals.\n\tAt most 10^2\u00a0calls will be made to\u00a0getIntervals.\n\u00a0\nFollow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?\n\nHere is the code snippet, which you should expand with your solution: class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()\n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to maintain a summary of a data stream of non-negative integers as a list of disjoint intervals. The intervals should be merged whenever consecutive numbers are added, and the summary should be returned in sorted order by the start of each interval.\n\n### Approach\n1. **Problem Analysis**: The problem requires efficiently adding integers to a data structure and then retrieving a list of disjoint intervals that cover all integers added so far. The challenge is to handle merges correctly when new numbers connect existing intervals (e.g., adding 2 when we have intervals [1,1] and [3,3] merges into [1,3]).\n2. **Intuition**: We need a way to quickly check if a new number connects with existing intervals. We can maintain a sorted list of intervals. For each new number, we can:\n   - Check if it is already covered by an existing interval.\n   - If not, find the immediate left and right intervals to see if it can merge with them.\n3. **Data Structures**: Using a sorted list of intervals allows efficient insertion and merging. However, to avoid O(n) operations for each insertion, we can use a data structure that supports efficient search and insertion. Alternatively, we can use a balanced BST or a sorted list with binary search for insertion.\n4. **Algorithm**:\n   - **Initialization**: Initialize an empty list to store intervals.\n   - **addNum(value)**:\n        - If the list is empty, simply add the interval [value, value].\n        - Otherwise, use binary search to find the position where the new value might be inserted.\n        - Check if the value is already covered by an existing interval. If yes, skip.\n        - Check the left interval to see if value is adjacent to it (i.e., value == end+1). Similarly, check the right interval (value == start-1).\n        - If it merges with both left and right, combine them into one interval.\n        - If it merges with only one, extend that interval.\n        - If it merges with none, insert a new interval at the correct position.\n   - **getIntervals()**: Return the current list of intervals.\n5. **Efficiency**: Since the number of intervals is expected to be small (due to merges), the list of intervals will be manageable. Each insertion might require O(log n) to find the position and O(n) for merging and shifting, but overall it should be efficient given the constraints.\n\n### Solution Code\n```python\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        lo, hi = 0, len(self.intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            interval = self.intervals[mid]\n            if interval[0] <= value <= interval[1]:\n                return\n            elif value < interval[0]:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        pos = lo\n        if pos > 0 and self.intervals[pos-1][1] + 1 == value:\n            self.intervals[pos-1][1] = value\n            if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n                self.intervals[pos-1][1] = self.intervals[pos][1]\n                self.intervals.pop(pos)\n            return\n        \n        if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n            self.intervals[pos][0] = value\n            return\n        \n        self.intervals.insert(pos, [value, value])\n        \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n```\n\n### Explanation\n1. **Initialization**: The `SummaryRanges` class initializes with an empty list `intervals` to store the disjoint intervals.\n2. **addNum(value)**:\n   - If the list is empty, it directly adds the interval [value, value].\n   - It uses binary search to find the correct position for the new value. If the value is already within an existing interval, it returns without changes.\n   - It checks if the value can extend the left interval (if it is exactly one more than the end of the left interval). If so, it extends that interval and checks if it can merge with the right interval (if the extended end meets the start of the right interval).\n   - Similarly, it checks if the value can extend the right interval (if it is exactly one less than the start of the right interval).\n   - If no merge is possible, it inserts a new interval at the found position.\n3. **getIntervals()**: Simply returns the current list of intervals, which are maintained in sorted order by their start values.\n\nThis approach efficiently manages the intervals by leveraging binary search for insertion and handles merges in constant time when possible, ensuring optimal performance even for large streams.",
      "TypedCode": "\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        lo, hi = 0, len(self.intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            interval = self.intervals[mid]\n            if interval[0] <= value <= interval[1]:\n                return\n            elif value < interval[0]:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        pos = lo\n        if pos > 0 and self.intervals[pos-1][1] + 1 == value:\n            self.intervals[pos-1][1] = value\n            if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n                self.intervals[pos-1][1] = self.intervals[pos][1]\n                self.intervals.pop(pos)\n            return\n        \n        if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n            self.intervals[pos][0] = value\n            return\n        \n        self.intervals.insert(pos, [value, value])\n        \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 9183499250,
      "SolvedAt": "2025-11-20T21:15:43.631258+01:00",
      "PromptTokens": 836,
      "OutputTokens": 1071
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "352",
        "typed_code": "\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n            return\n        \n        lo, hi = 0, len(self.intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            interval = self.intervals[mid]\n            if interval[0] <= value <= interval[1]:\n                return\n            elif value < interval[0]:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        pos = lo\n        if pos > 0 and self.intervals[pos-1][1] + 1 == value:\n            self.intervals[pos-1][1] = value\n            if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n                self.intervals[pos-1][1] = self.intervals[pos][1]\n                self.intervals.pop(pos)\n            return\n        \n        if pos < len(self.intervals) and value + 1 == self.intervals[pos][0]:\n            self.intervals[pos][0] = value\n            return\n        \n        self.intervals.insert(pos, [value, value])\n        \n    def getIntervals(self) -> list[list[int]]:\n        return self.intervals\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T23:04:59+01:00"
    }
  }
}