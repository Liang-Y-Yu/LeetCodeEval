{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "1354",
        "questionId": "1479",
        "Content": "<p>You are given an array <code>target</code> of n integers. From a starting array <code>arr</code> consisting of <code>n</code> 1&#39;s, you may perform the following procedure :</p>\n\n<ul>\n\t<li>let <code>x</code> be the sum of all elements currently in your array.</li>\n\t<li>choose index <code>i</code>, such that <code>0 &lt;= i &lt; n</code> and set the value of <code>arr</code> at index <code>i</code> to <code>x</code>.</li>\n\t<li>You may repeat this procedure as many times as needed.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to construct the</em> <code>target</code> <em>array from</em> <code>arr</code><em>, otherwise, return</em> <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [9,3,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,1,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Impossible to create target array from [1,1,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [8,5]\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[9,3,5]",
        "ExampleTestcases": "[9,3,5]\n[1,1,1,2]\n[8,5]",
        "Difficulty": "Hard",
        "Title": "Construct Target Array With Multiple Sums",
        "TitleSlug": "construct-target-array-with-multiple-sums",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"71.5K\", \"totalSubmission\": \"196.7K\", \"totalAcceptedRaw\": 71522, \"totalSubmissionRaw\": 196703, \"acRate\": \"36.4%\"}",
        "Likes": 2078,
        "Dislikes": 171,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "Name": "Heap (Priority Queue)",
            "Slug": "heap-priority-queue"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    bool isPossible(vector<int>& target) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public boolean isPossible(int[] target) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def isPossible(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} target\n * @return {boolean}\n */\nvar isPossible = function(target) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function isPossible(target: number[]): boolean {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public bool IsPossible(int[] target) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "bool isPossible(int* target, int targetSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func isPossible(target []int) bool {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun isPossible(target: IntArray): Boolean {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func isPossible(_ target: [Int]) -> Bool {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn is_possible(target: Vec<i32>) -> bool {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} target\n# @return {Boolean}\ndef is_possible(target)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $target\n     * @return Boolean\n     */\n    function isPossible($target) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  bool isPossible(List<int> target) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def isPossible(target: Array[Int]): Boolean = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec is_possible(target :: [integer]) :: boolean\n  def is_possible(target) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec is_possible(Target :: [integer()]) -> boolean().\nis_possible(Target) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (is-possible target)\n  (-> (listof exact-integer?) boolean?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:25:47.226174+01:00",
    "AcRate": "36.4",
    "TotalSubmissions": 196703,
    "TotalAccepted": 71522,
    "AcceptanceRate": 0.36360401214013005,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/construct-target-array-with-multiple-sums/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure :\n\tlet x be the sum of all elements currently in your array.\n\tchoose index i, such that 0 <= i < n and set the value of arr at index i to x.\n\tYou may repeat this procedure as many times as needed.\nReturn true if it is possible to construct the target array from arr, otherwise, return false.\n\u00a0\nExample 1:\nInput: target = [9,3,5]\nOutput: true\nExplanation: Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done\nExample 2:\nInput: target = [1,1,1,2]\nOutput: false\nExplanation: Impossible to create target array from [1,1,1,1].\nExample 3:\nInput: target = [8,5]\nOutput: true\n\u00a0\nConstraints:\n\tn == target.length\n\t1 <= n <= 5 * 10^4\n\t1 <= target[i] <= 10^9\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to determine whether it's possible to transform an initial array of all 1's into a given target array by repeatedly performing an operation where we replace an element with the sum of all elements in the array. \n\n### Approach\n1. **Understanding the Operation**: The operation allows replacing any element with the total sum of the array at that moment. This process is reversible. Instead of building up from all 1's to the target, we can reverse the process: start from the target and reduce it to the initial array of all 1's.\n2. **Reverse Process**:\n   - In the reverse process, the largest element in the current array must have been set in the last operation. So, we can replace the largest element (say `max_val`) with its value before the operation. The value before the operation would be `max_val - (total_sum - max_val)`, because the total sum in the previous step was `total_sum - max_val` (excluding the current largest element) and then we added the new value which is the total sum of that step.\n   - However, if the largest element is significantly larger than the rest, we can use modulo operation to avoid repeated subtraction. Specifically, if we have a largest element `max_val` and the rest of the elements sum to `rest_sum = total_sum - max_val`, then the previous value of the largest element is `max_val % rest_sum`. But if `rest_sum` is 1, then we can set the previous value to 1 (since we are going to end up with 1 eventually). Also, if `rest_sum` is 0, it means there's only one element, which should be 1.\n3. **Algorithm**:\n   - Use a max-heap to efficiently get the largest element each time.\n   - Calculate the total sum of the target array.\n   - While the largest element is greater than 1:\n        - Let `max_val` be the largest element. Pop it from the heap.\n        - Calculate `rest_sum = total_sum - max_val`.\n        - If `rest_sum` is 0 or `max_val <= rest_sum`, we break (which means it's impossible if `max_val` is still greater than 1).\n        - Otherwise, the previous value of the largest element is `max_val % rest_sum`. If the modulo result is 0, we set it to `rest_sum` only if `rest_sum` is 1 (to avoid 0 which is invalid) but generally if `rest_sum` is 1 then we set to 1. However, note: if `rest_sum` is 1, then the previous value should be 1. Otherwise, if the modulo is 0, it is invalid because we cannot have zero in the array (all elements must be at least 1). Actually, if we get 0 from modulo, it means we have to subtract multiple times until we get 1, but if `rest_sum` is 1, then we can get 1 by subtracting until 1. So if `rest_sum` is 1, then the previous value is 1. Otherwise, if we get 0 and `rest_sum` > 1, it's invalid.\n        - So, we can compute: `prev = max_val % rest_sum` if `rest_sum` != 0. But if `prev` becomes 0, then we set `prev = rest_sum` only if `rest_sum` is 1? Actually, if `rest_sum` is 1, then we can set `prev` to 1. But if `rest_sum` > 1 and `prev` is 0, it is impossible because we cannot have a zero. So if `prev` becomes 0 and `rest_sum` > 1, return false.\n        - However, a better way is: if `rest_sum` == 1, then we can set `prev` to 1. Otherwise, if `max_val % rest_sum` == 0, return false. Else, `prev = max_val % rest_sum`.\n   - Update the total sum: subtract `max_val` and add `prev`.\n   - Push `prev` back into the heap.\n   - If we successfully reduce all elements to 1, return true.\n\n4. **Edge Cases**:\n   - If the target has only one element, it must be 1.\n   - If the largest element is 1, then we are done (all are 1).\n\n### Solution Code\n```python\nimport heapq\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        total = sum(target)\n        heap = [-x for x in target]\n        heapq.heapify(heap)\n        \n        while -heap[0] > 1:\n            max_val = -heapq.heappop(heap)\n            rest_sum = total - max_val\n            if rest_sum == 0 or max_val <= rest_sum:\n                return False\n            prev = max_val % rest_sum\n            if prev == 0:\n                if rest_sum == 1:\n                    prev = 1\n                else:\n                    return False\n            total = total - max_val + prev\n            heapq.heappush(heap, -prev)\n        \n        return True\n```\n\n### Explanation\n1. **Initialization**: We start by calculating the total sum of the target array and creating a max-heap (using negative values to simulate a max-heap with heapq, which is a min-heap by default).\n2. **Processing**: While the largest element (retrieved from the heap) is greater than 1:\n   - We pop the largest element and compute the sum of the rest of the elements.\n   - If the rest sum is 0 or the largest element is not greater than the rest sum, it's impossible to reduce further, so return false.\n   - Compute the previous value of the largest element using modulo. If modulo results in 0, handle it by setting to 1 only if the rest sum is 1; otherwise, return false.\n   - Update the total sum by replacing the largest element with its previous value and push the previous value back into the heap.\n3. **Termination**: If all elements become 1 (largest element is 1), return true.\n\nThis approach efficiently reverses the operations using a heap to always process the largest element, ensuring correctness and handling large values optimally with modulo operations.",
      "TypedCode": "\nimport heapq\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        total = sum(target)\n        heap = [-x for x in target]\n        heapq.heapify(heap)\n        \n        while -heap[0] > 1:\n            max_val = -heapq.heappop(heap)\n            rest_sum = total - max_val\n            if rest_sum == 0 or max_val <= rest_sum:\n                return False\n            prev = max_val % rest_sum\n            if prev == 0:\n                if rest_sum == 1:\n                    prev = 1\n                else:\n                    return False\n            total = total - max_val + prev\n            heapq.heappush(heap, -prev)\n        \n        return True\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 20548231917,
      "SolvedAt": "2025-11-20T21:14:23.464401+01:00",
      "PromptTokens": 494,
      "OutputTokens": 1346
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "1479",
        "typed_code": "\nimport heapq\n\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        total = sum(target)\n        heap = [-x for x in target]\n        heapq.heapify(heap)\n        \n        while -heap[0] > 1:\n            max_val = -heapq.heappop(heap)\n            rest_sum = total - max_val\n            if rest_sum == 0 or max_val <= rest_sum:\n                return False\n            prev = max_val % rest_sum\n            if prev == 0:\n                if rest_sum == 1:\n                    prev = 1\n                else:\n                    return False\n            total = total - max_val + prev\n            heapq.heappush(heap, -prev)\n        \n        return True\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T22:09:20+01:00"
    }
  }
}