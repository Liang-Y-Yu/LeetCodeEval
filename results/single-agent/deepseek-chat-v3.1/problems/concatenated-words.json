{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "472",
        "questionId": "472",
        "Content": "<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>\n\n<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)&nbsp;in the given array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; \n&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; \n&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]\n<strong>Output:</strong> [&quot;catdog&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "SampleTestCase": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
        "ExampleTestcases": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n[\"cat\",\"dog\",\"catdog\"]",
        "Difficulty": "Hard",
        "Title": "Concatenated Words",
        "TitleSlug": "concatenated-words",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"260.2K\", \"totalSubmission\": \"524.6K\", \"totalAcceptedRaw\": 260204, \"totalSubmissionRaw\": 524581, \"acRate\": \"49.6%\"}",
        "Likes": 4037,
        "Dislikes": 292,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIx",
            "Name": "Depth-First Search",
            "Slug": "depth-first-search"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjI3",
            "Name": "Trie",
            "Slug": "trie"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nvar findAllConcatenatedWordsInADict = function(words) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findAllConcatenatedWordsInADict(words: string[]): string[] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findAllConcatenatedWordsInADict(char** words, int wordsSize, int* returnSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findAllConcatenatedWordsInADict(words []string) []string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findAllConcatenatedWordsInADict(_ words: [String]) -> [String] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_all_concatenated_words_in_a_dict(words: Vec<String>) -> Vec<String> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String[]} words\n# @return {String[]}\ndef find_all_concatenated_words_in_a_dict(words)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return String[]\n     */\n    function findAllConcatenatedWordsInADict($words) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<String> findAllConcatenatedWordsInADict(List<String> words) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findAllConcatenatedWordsInADict(words: Array[String]): List[String] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_all_concatenated_words_in_a_dict(words :: [String.t]) :: [String.t]\n  def find_all_concatenated_words_in_a_dict(words) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_all_concatenated_words_in_a_dict(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nfind_all_concatenated_words_in_a_dict(Words) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-all-concatenated-words-in-a-dict words)\n  (-> (listof string?) (listof string?))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:15:38.89262+01:00",
    "AcRate": "49.6",
    "TotalSubmissions": 524581,
    "TotalAccepted": 260204,
    "AcceptanceRate": 0.4960225398937438,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/concatenated-words/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)\u00a0in the given array.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\nExample 2:\nInput: words = [\"cat\",\"dog\",\"catdog\"]\nOutput: [\"catdog\"]\n\u00a0\nConstraints:\n\t1 <= words.length <= 10^4\n\t1 <= words[i].length <= 30\n\twords[i] consists of only lowercase English letters.\n\tAll the strings of words are unique.\n\t1 <= sum(words[i].length) <= 10^5\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to find all concatenated words in a given list of words. A concatenated word is defined as a string that is composed entirely of two or more shorter words from the same list. The solution involves efficiently determining for each word whether it can be formed by concatenating other words in the list.\n\n### Approach\n1. **Problem Analysis**: The problem requires checking each word in the list to see if it can be built by concatenating one or more other words from the same list. The challenge is to do this efficiently given the constraints.\n2. **Key Insight**: For each word, we can use dynamic programming to determine if it can be segmented into smaller words that exist in the list. Specifically, we define a DP array where `dp[i]` indicates whether the substring from the start to the i-th character can be segmented into words from the list.\n3. **Optimization**: To avoid unnecessary checks, we first sort the words by their length. This allows us to process shorter words first and use them to check longer words. Additionally, we use a set for fast lookups.\n4. **Algorithm**:\n   - Sort the list of words by their length.\n   - Initialize an empty set to keep track of words that have been processed (shorter words).\n   - For each word in the sorted list:\n        - Check if the word can be segmented into words from the set using dynamic programming.\n        - If it can, add it to the result list.\n        - Add the current word to the set of known words (so it can be used for checking longer words).\n5. **Dynamic Programming Check**:\n   - For a given word `w`, create a DP array of length `len(w)+1`, with `dp[0] = True` (base case: empty string).\n   - For each index `i` from 1 to `len(w)`, check all indices `j` from 0 to `i`:\n        - If `dp[j]` is True and the substring `w[j:i]` is in the set of known words, then set `dp[i] = True` and break early (to avoid unnecessary checks).\n   - The word is concatenated if `dp[len(w)]` is True.\n\n### Solution Code\n```python\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.can_concatenate(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        return res\n    \n    def can_concatenate(self, word, word_set):\n        if not word_set:\n            return False\n        n = len(word)\n        dp = [False] * (n+1)\n        dp[0] = True\n        for i in range(1, n+1):\n            for j in range(i):\n                if dp[j] and word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n```\n\n### Explanation\n1. **Sorting Words**: The list of words is sorted by length to ensure we process shorter words first. This allows us to build a set of known words that can be used to check longer words.\n2. **Dynamic Programming Check**: For each word, we check if it can be segmented into words from the set. The DP array `dp` is used to track whether the substring ending at index `i` can be formed by concatenating words from the set. The base case `dp[0]` is set to True because an empty string is always considered to be concatenated.\n3. **Efficiency**: The inner loop checks all possible segments of the word. If a segment from `j` to `i` exists in the set and the substring up to `j` is valid, then the substring up to `i` is marked as valid. This approach efficiently checks all possible splits without resorting to brute force.\n4. **Result Collection**: Words that pass the DP check are added to the result list. Each word is added to the set after processing so that it can be used for checking subsequent longer words.\n\nThis approach efficiently identifies concatenated words by leveraging dynamic programming and a set for fast lookups, ensuring optimal performance even for large inputs.",
      "TypedCode": "\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.can_concatenate(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        return res\n    \n    def can_concatenate(self, word, word_set):\n        if not word_set:\n            return False\n        n = len(word)\n        dp = [False] * (n+1)\n        dp[0] = True\n        for i in range(1, n+1):\n            for j in range(i):\n                if dp[j] and word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 6004208458,
      "SolvedAt": "2025-11-20T21:13:49.856722+01:00",
      "PromptTokens": 472,
      "OutputTokens": 911
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "472",
        "typed_code": "\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.can_concatenate(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        return res\n    \n    def can_concatenate(self, word, word_set):\n        if not word_set:\n            return False\n        n = len(word)\n        dp = [False] * (n+1)\n        dp[0] = True\n        for i in range(1, n+1):\n            for j in range(i):\n                if dp[j] and word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T23:10:43+01:00"
    }
  }
}