{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "823",
        "questionId": "843",
        "Content": "<p>Given an array of unique integers, <code>arr</code>, where each integer <code>arr[i]</code> is strictly greater than <code>1</code>.</p>\n\n<p>We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node&#39;s value should be equal to the product of the values of its children.</p>\n\n<p>Return <em>the number of binary trees we can make</em>. The answer may be too large so return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,4,5,10]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the values of <code>arr</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "SampleTestCase": "[2,4]",
        "ExampleTestcases": "[2,4]\n[2,4,5,10]",
        "Difficulty": "Medium",
        "Title": "Binary Trees With Factors",
        "TitleSlug": "binary-trees-with-factors",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"157.1K\", \"totalSubmission\": \"296.3K\", \"totalAcceptedRaw\": 157065, \"totalSubmissionRaw\": 296267, \"acRate\": \"53.0%\"}",
        "Likes": 3358,
        "Dislikes": 260,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjU=",
            "Name": "Array",
            "Slug": "array"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEz",
            "Name": "Dynamic Programming",
            "Slug": "dynamic-programming"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "Name": "Sorting",
            "Slug": "sorting"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& arr) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public int numFactoredBinaryTrees(int[] arr) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def numFactoredBinaryTrees(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar numFactoredBinaryTrees = function(arr) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function numFactoredBinaryTrees(arr: number[]): number {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public int NumFactoredBinaryTrees(int[] arr) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "int numFactoredBinaryTrees(int* arr, int arrSize) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func numFactoredBinaryTrees(arr []int) int {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun numFactoredBinaryTrees(arr: IntArray): Int {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func numFactoredBinaryTrees(_ arr: [Int]) -> Int {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {Integer[]} arr\n# @return {Integer}\ndef num_factored_binary_trees(arr)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function numFactoredBinaryTrees($arr) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  int numFactoredBinaryTrees(List<int> arr) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def numFactoredBinaryTrees(arr: Array[Int]): Int = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec num_factored_binary_trees(arr :: [integer]) :: integer\n  def num_factored_binary_trees(arr) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec num_factored_binary_trees(Arr :: [integer()]) -> integer().\nnum_factored_binary_trees(Arr) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (num-factored-binary-trees arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T14:57:39.817181+01:00",
    "AcRate": "53.0",
    "TotalSubmissions": 296267,
    "TotalAccepted": 157065,
    "AcceptanceRate": 0.530146793264184,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/binary-trees-with-factors/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: arr = [2,4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: arr = [2,4,5,10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n\u00a0\nConstraints:\n\t1 <= arr.length <= 1000\n\t2 <= arr[i] <= 10^9\n\tAll the values of arr are unique.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to count the number of binary trees we can form from an array of unique integers such that each non-leaf node's value equals the product of its children's values. The solution involves dynamic programming and efficient factorization checks.\n\n### Approach\n1. **Sort the Array**: Sorting helps in processing numbers in increasing order, ensuring that when we consider a number, all its potential factors (if they exist) have been processed earlier.\n2. **Dynamic Programming (DP) Setup**: Use a DP dictionary where `dp[x]` will store the number of binary trees that can be formed with `x` as the root.\n3. **Initialize DP**: For each number in the sorted array, initialize `dp[x]` to 1. This accounts for the tree with just the root node.\n4. **Factor Check**: For each number `x` in the sorted array, check for factors in the array that are divisors of `x`. For each factor `a` (where `a * b = x`), if both `a` and `b` exist in the array, then the number of trees with root `x` can be increased by `dp[a] * dp[b]`. Note that if `a` and `b` are distinct, there are two ways to arrange them as left and right children? Actually, the problem does not distinguish between left and right children? Wait, from the examples: [10,2,5] and [10,5,2] are considered distinct. So the tree is ordered? Actually, the problem states \"binary tree\", which typically is ordered. So each pair of distinct children contributes two different trees? However, note the example: [4,2,2] has two children both 2. So if the children are the same, there is only one way to arrange them.\n   - Therefore, for distinct factors `a` and `b` (with `a != b`), the number of ways to form children is `dp[a] * dp[b] * 2`.\n   - For the same factors (i.e., `a == b`), the number of ways is `dp[a] * dp[b]` (which is `dp[a]^2`).\n5. **Modulo Operation**: Since the answer can be large, perform all operations modulo \\(10^9 + 7\\).\n6. **Sum Results**: The total number of trees is the sum of all `dp[x]` for every `x` in the array.\n\n### Solution Code\n```python\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        dp = {}\n        for num in arr:\n            dp[num] = 1\n        \n        for i, x in enumerate(arr):\n            for j in range(i):\n                a = arr[j]\n                if x % a == 0:\n                    b = x // a\n                    if b in dp:\n                        if a == b:\n                            dp[x] = (dp[x] + dp[a] * dp[b]) % MOD\n                        else:\n                            dp[x] = (dp[x] + dp[a] * dp[b] * 2) % MOD\n        \n        return sum(dp.values()) % MOD\n```\n\n### Explanation\n1. **Sorting and Initialization**: The array is sorted to process numbers from smallest to largest. Each number is initialized in the DP dictionary with a count of 1 (representing the tree with only the root).\n2. **Processing Each Number**: For each number `x`, we check all smaller numbers `a` (which are potential factors). If `a` divides `x` evenly, we compute `b = x // a`. If `b` exists in the array, we update the count for `x`:\n   - If `a` and `b` are the same, the number of trees with root `x` is increased by `dp[a] * dp[b]`.\n   - If they are different, it is increased by `dp[a] * dp[b] * 2` (accounting for two possible child arrangements).\n3. **Result Calculation**: The total number of trees is the sum of all values in the DP dictionary, taken modulo \\(10^9 + 7\\).\n\nThis approach efficiently counts all possible binary trees by leveraging dynamic programming and careful factor checks, ensuring correctness and optimal performance.",
      "TypedCode": "\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        dp = {}\n        for num in arr:\n            dp[num] = 1\n        \n        for i, x in enumerate(arr):\n            for j in range(i):\n                a = arr[j]\n                if x % a == 0:\n                    b = x // a\n                    if b in dp:\n                        if a == b:\n                            dp[x] = (dp[x] + dp[a] * dp[b]) % MOD\n                        else:\n                            dp[x] = (dp[x] + dp[a] * dp[b] * 2) % MOD\n        \n        return sum(dp.values()) % MOD\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 20031408583,
      "SolvedAt": "2025-11-20T21:13:15.31623+01:00",
      "PromptTokens": 446,
      "OutputTokens": 923
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "843",
        "typed_code": "\nclass Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        arr.sort()\n        dp = {}\n        for num in arr:\n            dp[num] = 1\n        \n        for i, x in enumerate(arr):\n            for j in range(i):\n                a = arr[j]\n                if x % a == 0:\n                    b = x // a\n                    if b in dp:\n                        if a == b:\n                            dp[x] = (dp[x] + dp[a] * dp[b]) % MOD\n                        else:\n                            dp[x] = (dp[x] + dp[a] * dp[b] * 2) % MOD\n        \n        return sum(dp.values()) % MOD\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 11,
        "status_msg": "Wrong Answer",
        "Finished": true,
        "State": "FAILED"
      },
      "SubmittedAt": "2025-11-20T23:19:16+01:00"
    }
  }
}