{
  "Question": {
    "Data": {
      "Question": {
        "questionFrontendId": "126",
        "questionId": "126",
        "Content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n",
        "SampleTestCase": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "ExampleTestcases": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "Difficulty": "Hard",
        "Title": "Word Ladder II",
        "TitleSlug": "word-ladder-ii",
        "IsPaidOnly": false,
        "Stats": "{\"totalAccepted\": \"438.3K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 438315, \"totalSubmissionRaw\": 1602775, \"acRate\": \"27.3%\"}",
        "Likes": 6461,
        "Dislikes": 823,
        "FreqBar": 0,
        "CategoryTitle": "Algorithms",
        "TopicTags": [
          {
            "Id": "VG9waWNUYWdOb2RlOjY=",
            "Name": "Hash Table",
            "Slug": "hash-table"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjEw",
            "Name": "String",
            "Slug": "string"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjE0",
            "Name": "Backtracking",
            "Slug": "backtracking"
          },
          {
            "Id": "VG9waWNUYWdOb2RlOjIy",
            "Name": "Breadth-First Search",
            "Slug": "breadth-first-search"
          }
        ],
        "CodeSnippets": [
          {
            "Lang": "C++",
            "LangSlug": "cpp",
            "Code": "class Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};"
          },
          {
            "Lang": "Java",
            "LangSlug": "java",
            "Code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "Python3",
            "LangSlug": "python3",
            "Code": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        "
          },
          {
            "Lang": "Python",
            "LangSlug": "python",
            "Code": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        "
          },
          {
            "Lang": "JavaScript",
            "LangSlug": "javascript",
            "Code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};"
          },
          {
            "Lang": "TypeScript",
            "LangSlug": "typescript",
            "Code": "function findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    \n};"
          },
          {
            "Lang": "C#",
            "LangSlug": "csharp",
            "Code": "public class Solution {\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "C",
            "LangSlug": "c",
            "Code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** findLadders(char* beginWord, char* endWord, char** wordList, int wordListSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
          },
          {
            "Lang": "Go",
            "LangSlug": "golang",
            "Code": "func findLadders(beginWord string, endWord string, wordList []string) [][]string {\n    \n}"
          },
          {
            "Lang": "Kotlin",
            "LangSlug": "kotlin",
            "Code": "class Solution {\n    fun findLadders(beginWord: String, endWord: String, wordList: List<String>): List<List<String>> {\n        \n    }\n}"
          },
          {
            "Lang": "Swift",
            "LangSlug": "swift",
            "Code": "class Solution {\n    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\n        \n    }\n}"
          },
          {
            "Lang": "Rust",
            "LangSlug": "rust",
            "Code": "impl Solution {\n    pub fn find_ladders(begin_word: String, end_word: String, word_list: Vec<String>) -> Vec<Vec<String>> {\n        \n    }\n}"
          },
          {
            "Lang": "Ruby",
            "LangSlug": "ruby",
            "Code": "# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {String[][]}\ndef find_ladders(begin_word, end_word, word_list)\n    \nend"
          },
          {
            "Lang": "PHP",
            "LangSlug": "php",
            "Code": "class Solution {\n\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return String[][]\n     */\n    function findLadders($beginWord, $endWord, $wordList) {\n        \n    }\n}"
          },
          {
            "Lang": "Dart",
            "LangSlug": "dart",
            "Code": "class Solution {\n  List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    \n  }\n}"
          },
          {
            "Lang": "Scala",
            "LangSlug": "scala",
            "Code": "object Solution {\n    def findLadders(beginWord: String, endWord: String, wordList: List[String]): List[List[String]] = {\n        \n    }\n}"
          },
          {
            "Lang": "Elixir",
            "LangSlug": "elixir",
            "Code": "defmodule Solution do\n  @spec find_ladders(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: [[String.t]]\n  def find_ladders(begin_word, end_word, word_list) do\n    \n  end\nend"
          },
          {
            "Lang": "Erlang",
            "LangSlug": "erlang",
            "Code": "-spec find_ladders(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].\nfind_ladders(BeginWord, EndWord, WordList) ->\n  ."
          },
          {
            "Lang": "Racket",
            "LangSlug": "racket",
            "Code": "(define/contract (find-ladders beginWord endWord wordList)\n  (-> string? string? (listof string?) (listof (listof string?)))\n  )"
          }
        ],
        "CompanyTagStats": ""
      }
    },
    "DownloadedAt": "2025-11-17T15:31:20.506798+01:00",
    "AcRate": "27.3",
    "TotalSubmissions": 1602775,
    "TotalAccepted": 438315,
    "AcceptanceRate": 0.2734725710096551,
    "ContentFeatures": "",
    "CodeSnippetFeatures": {
      "c": "",
      "cpp": "",
      "csharp": "",
      "dart": "",
      "elixir": "",
      "erlang": "",
      "golang": "",
      "java": "",
      "javascript": "",
      "kotlin": "",
      "php": "",
      "python": "",
      "python3": "",
      "racket": "",
      "ruby": "",
      "rust": "",
      "scala": "",
      "swift": "",
      "typescript": ""
    },
    "Url": "https://leetcode.com/problems/word-ladder-ii/"
  },
  "Solutions": {
    "deepseek/deepseek-chat-v3.1": {
      "Lang": "python3",
      "Prompt": "Hi, this is a coding interview. You will be given:\n* A problem statement (with sample test cases if available).\n* A starter code snippet (with fixed function signatures).\n\nPlease write your solution in the python3 programming language. Your code must:\n* Solve the problem fully and correctly.\n* Pass all provided sample test cases.\n* Run within acceptable time and memory limits (assume large inputs if none are specified).\n* Follow good coding practices (clear logic, readable structure, appropriate use of language features).\n\nHere is the problem statement: A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\tEvery adjacent pair of words differs by a single letter.\n\tEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n\tsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\u00a0\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation:\u00a0There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\u00a0\nConstraints:\n\t1 <= beginWord.length <= 5\n\tendWord.length == beginWord.length\n\t1 <= wordList.length <= 500\n\twordList[i].length == beginWord.length\n\tbeginWord, endWord, and wordList[i] consist of lowercase English letters.\n\tbeginWord != endWord\n\tAll the words in wordList are unique.\n\tThe sum of all shortest transformation sequences does not exceed 10^5.\n\nHere is the code snippet, which you should expand with your solution: class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        \n\nImportant Requirements:\n* Do not change any provided function signatures, class names, or method names.\n* Output only valid source code that can be executed as-is, without any further improvements or bugfixes.\n* Do not include docstrings, markdown, or commentary in your final code.\n\nGood luck!\n",
      "Answer": "To solve this problem, we need to find all the shortest transformation sequences from `beginWord` to `endWord` using a dictionary `wordList`, where each adjacent word in the sequence differs by exactly one letter. The solution involves using a BFS (Breadth-First Search) approach to explore the graph of words, but we need to efficiently collect all shortest paths.\n\n### Approach\n1. **Problem Analysis**: The problem is similar to finding the shortest paths in an unweighted graph where each node is a word, and edges exist between words that differ by exactly one letter. However, we need to return all shortest paths, not just one.\n\n2. **Key Insight**: Using BFS we can determine the shortest distance from `beginWord` to every other word. But to collect all paths, we need to know the parent-child relationships at each level. However, traditional BFS with a queue might not efficiently store all paths. Instead, we can use a two-directional BFS (bidirectional BFS) to reduce the search space, but for simplicity and given the constraints, we use a BFS that builds a graph of predecessors.\n\n3. **Algorithm Selection**:\n   - **BFS for Shortest Path**: We perform a BFS starting from `beginWord` to `endWord`. During BFS, we traverse level by level. For each word, we generate all possible transformations (by changing each letter to every other letter in the alphabet) and check if the transformed word is in the `wordList`.\n   - **Tracking Predecessors**: Instead of storing just the shortest distance, we store the predecessors of each word. This helps in reconstructing all paths later. For each word, we note which words led to it in the immediately previous level.\n   - **Level-wise Processing**: We process one level at a time. For each level, we record all words that can be reached and their predecessors. If we reach `endWord`, we stop after processing the current level.\n   - **Path Reconstruction**: Using DFS (or backtracking) on the predecessor graph, we reconstruct all paths from `endWord` back to `beginWord`.\n\n4. **Optimizations**:\n   - Use a set for `wordList` for O(1) lookups.\n   - To avoid cycles and unnecessary processing, we remove words from the set once they have been visited in a previous level. However, words that are reached again at the same level are allowed (to collect all paths) but not in the next levels.\n   - Use a queue that processes each level entirely before moving to the next.\n\n5. **Implementation Steps**:\n   - Convert `wordList` to a set for fast lookups.\n   - If `endWord` is not in `wordList`, return an empty list.\n   - Initialize a dictionary `predecessors` to store the predecessors of each word.\n   - Use a queue (collections.deque) for BFS. Start with `beginWord`.\n   - While the queue is not empty:\n        - Process all nodes at the current level.\n        - For each word in the current level, generate all possible one-letter variations.\n        - If a variation is in the word set, it is a valid next word.\n        - Record the current word as a predecessor of the variation.\n        - After processing the current level, remove all words that were visited in this level from the word set to avoid cycles (since we are using BFS, shorter paths are already found).\n   - Once we encounter `endWord` in a level, we stop after processing that level.\n   - Use DFS to reconstruct all paths from `endWord` to `beginWord` using the predecessor map.\n\n### Solution Code\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n        \n        # Predecessor dictionary\n        preds = {}\n        # Initialize with beginWord\n        preds[beginWord] = []\n        # Current level words\n        level = {beginWord}\n        \n        while level:\n            next_level = set()\n            # Remove words from word_set that are in current level to prevent cycles\n            for word in level:\n                word_set.discard(word)\n            \n            for word in level:\n                if word == endWord:\n                    # Found the endWord, we can stop and reconstruct paths\n                    return self.reconstruct_paths(beginWord, endWord, preds)\n                # Generate all possible next words\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in word_set:\n                            next_level.add(new_word)\n                            if new_word not in preds:\n                                preds[new_word] = []\n                            preds[new_word].append(word)\n            \n            level = next_level\n        \n        return []\n    \n    def reconstruct_paths(self, start, end, preds):\n        paths = []\n        if end == start:\n            return [[start]]\n        for predecessor in preds[end]:\n            for path in self.reconstruct_paths(start, predecessor, preds):\n                paths.append(path + [end])\n        return paths\n```\n\n### Explanation\n1. **Initialization**: The `wordList` is converted to a set for O(1) lookups. If `endWord` is not in this set, return an empty list.\n2. **BFS Setup**: We start with `beginWord` in the current level. For each word in the current level, we generate all one-letter variations. If a variation is in the set, it is added to the next level and the current word is recorded as its predecessor.\n3. **Level Processing**: After processing all words in the current level, these words are removed from the set to avoid reprocessing. This ensures we only consider shorter paths.\n4. **Path Reconstruction**: When `endWord` is found, we use DFS to recursively reconstruct all paths from `endWord` back to `beginWord` using the predecessor dictionary. Each path is built by backtracking from `endWord` to `beginWord` through the recorded predecessors.\n5. **Result**: The result is a list of all shortest paths from `beginWord` to `endWord`.\n\nThis approach efficiently collects all shortest paths by leveraging BFS to build a predecessor graph and DFS to reconstruct paths from this graph.",
      "TypedCode": "\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n        \n        # Predecessor dictionary\n        preds = {}\n        # Initialize with beginWord\n        preds[beginWord] = []\n        # Current level words\n        level = {beginWord}\n        \n        while level:\n            next_level = set()\n            # Remove words from word_set that are in current level to prevent cycles\n            for word in level:\n                word_set.discard(word)\n            \n            for word in level:\n                if word == endWord:\n                    # Found the endWord, we can stop and reconstruct paths\n                    return self.reconstruct_paths(beginWord, endWord, preds)\n                # Generate all possible next words\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in word_set:\n                            next_level.add(new_word)\n                            if new_word not in preds:\n                                preds[new_word] = []\n                            preds[new_word].append(word)\n            \n            level = next_level\n        \n        return []\n    \n    def reconstruct_paths(self, start, end, preds):\n        paths = []\n        if end == start:\n            return [[start]]\n        for predecessor in preds[end]:\n            for path in self.reconstruct_paths(start, predecessor, preds):\n                paths.append(path + [end])\n        return paths\n",
      "Model": "deepseek/deepseek-chat-v3.1",
      "Latency": 23977489084,
      "SolvedAt": "2025-11-20T21:30:07.9868+01:00",
      "PromptTokens": 634,
      "OutputTokens": 1376
    }
  },
  "Submissions": {
    "deepseek/deepseek-chat-v3.1": {
      "SubmitRequest": {
        "lang": "python3",
        "question_id": "126",
        "typed_code": "\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n        \n        # Predecessor dictionary\n        preds = {}\n        # Initialize with beginWord\n        preds[beginWord] = []\n        # Current level words\n        level = {beginWord}\n        \n        while level:\n            next_level = set()\n            # Remove words from word_set that are in current level to prevent cycles\n            for word in level:\n                word_set.discard(word)\n            \n            for word in level:\n                if word == endWord:\n                    # Found the endWord, we can stop and reconstruct paths\n                    return self.reconstruct_paths(beginWord, endWord, preds)\n                # Generate all possible next words\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in word_set:\n                            next_level.add(new_word)\n                            if new_word not in preds:\n                                preds[new_word] = []\n                            preds[new_word].append(word)\n            \n            level = next_level\n        \n        return []\n    \n    def reconstruct_paths(self, start, end, preds):\n        paths = []\n        if end == start:\n            return [[start]]\n        for predecessor in preds[end]:\n            for path in self.reconstruct_paths(start, predecessor, preds):\n                paths.append(path + [end])\n        return paths\n"
      },
      "SubmissionId": 0,
      "CheckResponse": {
        "status_code": 10,
        "status_msg": "Accepted",
        "Finished": true,
        "State": "SUCCESS"
      },
      "SubmittedAt": "2025-11-20T22:54:02+01:00"
    }
  }
}