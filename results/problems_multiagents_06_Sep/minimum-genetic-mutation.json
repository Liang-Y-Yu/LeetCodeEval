{"Question":{"Data":{"Question":{"questionFrontendId":"433","questionId":"433","Content":"<p>A gene string can be represented by an 8-character long string, with choices from <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<p>Suppose we need to investigate a mutation from a gene string <code>startGene</code> to a gene string <code>endGene</code> where one mutation is defined as one single character changed in the gene string.</p>\n\n<ul>\n\t<li>For example, <code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> is one mutation.</li>\n</ul>\n\n<p>There is also a gene bank <code>bank</code> that records all the valid gene mutations. A gene must be in <code>bank</code> to make it a valid gene string.</p>\n\n<p>Given the two gene strings <code>startGene</code> and <code>endGene</code> and the gene bank <code>bank</code>, return <em>the minimum number of mutations needed to mutate from </em><code>startGene</code><em> to </em><code>endGene</code>. If there is no such a mutation, return <code>-1</code>.</p>\n\n<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= bank.length &lt;= 10</code></li>\n\t<li><code>startGene.length == endGene.length == bank[i].length == 8</code></li>\n\t<li><code>startGene</code>, <code>endGene</code>, and <code>bank[i]</code> consist of only the characters <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code>.</li>\n</ul>\n","SampleTestCase":"\"AACCGGTT\"\n\"AACCGGTA\"\n[\"AACCGGTA\"]","ExampleTestcases":"\"AACCGGTT\"\n\"AACCGGTA\"\n[\"AACCGGTA\"]\n\"AACCGGTT\"\n\"AAACGGTA\"\n[\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]","Difficulty":"Medium","Title":"Minimum Genetic Mutation","TitleSlug":"minimum-genetic-mutation","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"246.9K\", \"totalSubmission\": \"442.1K\", \"totalAcceptedRaw\": 246896, \"totalSubmissionRaw\": 442111, \"acRate\": \"55.8%\"}","Likes":3224,"Dislikes":343,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int minMutation(string startGene, string endGene, vector<string>& bank) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int minMutation(String startGene, String endGene, String[] bank) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def minMutation(self, startGene, endGene, bank):\n        \"\"\"\n        :type startGene: str\n        :type endGene: str\n        :type bank: List[str]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int minMutation(char* startGene, char* endGene, char** bank, int bankSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int MinMutation(string startGene, string endGene, string[] bank) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} startGene\n * @param {string} endGene\n * @param {string[]} bank\n * @return {number}\n */\nvar minMutation = function(startGene, endGene, bank) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function minMutation(startGene: string, endGene: string, bank: string[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $startGene\n     * @param String $endGene\n     * @param String[] $bank\n     * @return Integer\n     */\n    function minMutation($startGene, $endGene, $bank) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func minMutation(_ startGene: String, _ endGene: String, _ bank: [String]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun minMutation(startGene: String, endGene: String, bank: Array<String>): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int minMutation(String startGene, String endGene, List<String> bank) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func minMutation(startGene string, endGene string, bank []string) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} start_gene\n# @param {String} end_gene\n# @param {String[]} bank\n# @return {Integer}\ndef min_mutation(start_gene, end_gene, bank)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def minMutation(startGene: String, endGene: String, bank: Array[String]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn min_mutation(start_gene: String, end_gene: String, bank: Vec<String>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (min-mutation startGene endGene bank)\n  (-> string? string? (listof string?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec min_mutation(StartGene :: unicode:unicode_binary(), EndGene :: unicode:unicode_binary(), Bank :: [unicode:unicode_binary()]) -> integer().\nmin_mutation(StartGene, EndGene, Bank) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec min_mutation(start_gene :: String.t, end_gene :: String.t, bank :: [String.t]) :: integer\n  def min_mutation(start_gene, end_gene, bank) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:47:48.602178963+02:00","AcRate":"55.8","TotalSubmissions":442111,"TotalAccepted":246896,"AcceptanceRate":0.5584479915677285,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/minimum-genetic-mutation/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n```\n\n=== DESIGN ===\nHere's the expanded code with the solution:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n```\n\n=== VERIFICATION ===\nHere is the verification report based on the criteria specified:\n\n1. **Correctness**: The code implements the breadth-first search (BFS) algorithm correctly to find the shortest path from `startGene` to `endGene` with valid mutations from the `bank`. It correctly checks whether `endGene` is in the `bank` initially and uses a queue to explore all possible mutations.\n\n2. **Edge Cases**: \n   - The code handles the case when `endGene` is not in the gene bank by returning -1 immediately.\n   - It correctly performs mutations only if the mutated gene is in the bank and not visited.\n   - Handles cases where no mutations are possible due to disjoint sets of gene strings in the bank.\n   - Note that the conditions assume `bank` can hold a minimum of 0 and maximum of 10 strings, ensuring it is within reasonable limits for BFS.\n\n3. **Complexity**: \n   - Time Complexity: The code potentially explores all valid single mutations, and since the bank size is constrained to around 10 at maximum, it is efficient. Therefore, the time complexity should be manageable.\n   - Space Complexity: Space usage is reasonable as it stores visited strings and the queue operations, considering constraints.\n\n4. **Code Quality**: The code is clean and follows Python best practices:\n   - It uses meaningful variable names and straightforward logic.\n   - It leverages helpful data structures like `set` for fast membership checking and `deque` for efficient queue operations.\n\n5. **Test Cases**: The provided examples are correctly handled:\n   - For `startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]`, it returns `1` which matches expectations.\n   - For `startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]`, it returns `2` which is correct.\n\n6. **Potential Issues**: The solution is robust given the constraints including gene bank size and string length. There do not appear to be any logical errors or bugs in the given solution. Any improvements would be speculative rather than necessary.\n\nFinal Conclusion: The implemented code correctly solves the problem according to specified constraints and conditions. It adheres to good coding practices and efficient use of space and time complexity, given sample sizes. The solution is valid.\n\nHere's the code as a complete solution:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n```\n\n","TypedCode":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n","Model":"se-gpt-4o","Latency":9836002229,"SolvedAt":"2025-09-06T23:01:45.238954538+02:00","PromptTokens":4064,"OutputTokens":1340}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"433","typed_code":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        if endGene not in bank:\n            return -1\n        \n        bank_set = set(bank)\n        choices = ['A', 'C', 'G', 'T']\n        \n        queue = deque([(startGene, 0)])\n        visited = set([startGene])\n        \n        while queue:\n            current_gene, mutations = queue.popleft()\n            \n            if current_gene == endGene:\n                return mutations\n            \n            for i in range(8):\n                for choice in choices:\n                    if current_gene[i] != choice:\n                        mutated_gene = current_gene[:i] + choice + current_gene[i+1:]\n                        if mutated_gene in bank_set and mutated_gene not in visited:\n                            visited.add(mutated_gene)\n                            queue.append((mutated_gene, mutations + 1))\n        \n        return -1\n"},"SubmissionId":1761936701,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:35:22.54512033+02:00"}}}
