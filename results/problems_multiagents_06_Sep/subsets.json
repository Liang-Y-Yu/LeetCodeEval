{"Question":{"Data":{"Question":{"questionFrontendId":"78","questionId":"78","Content":"<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n","SampleTestCase":"[1,2,3]","ExampleTestcases":"[1,2,3]\n[0]","Difficulty":"Medium","Title":"Subsets","TitleSlug":"subsets","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 2681905, \"totalSubmissionRaw\": 3295752, \"acRate\": \"81.4%\"}","Likes":18588,"Dislikes":323,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjE0","Name":"Backtracking","Slug":"backtracking"},{"Id":"VG9waWNUYWdOb2RlOjE5","Name":"Bit Manipulation","Slug":"bit-manipulation"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public IList<IList<int>> Subsets(int[] nums) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function subsets(nums: number[]): number[][] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsets($nums) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func subsets(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun subsets(nums: IntArray): List<List<Int>> {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<List<int>> subsets(List<int> nums) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func subsets(nums []int) [][]int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets(nums)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def subsets(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (subsets nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec subsets(Nums :: [integer()]) -> [[integer()]].\nsubsets(Nums) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec subsets(nums :: [integer]) :: [[integer]]\n  def subsets(nums) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:49:35.521641136+02:00","AcRate":"81.4","TotalSubmissions":3295752,"TotalAccepted":2681905,"AcceptanceRate":0.8137459978784811,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/subsets/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            result.append(list(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return result\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            # Add current subset to result\n            result.append(list(path))\n            \n            # Iterate and update the path\n            for i in range(start, len(nums)):\n                # Include nums[i] to the current subset\n                path.append(nums[i])\n                # Proceed to add more elements\n                backtrack(i + 1, path)\n                # Exclude nums[i] for further exploration\n                path.pop()\n        \n        # Initialize backtracking with an empty path\n        backtrack(0, [])\n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            result.append(list(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return result\n```\n\n=== VERIFICATION ===\nHere is the verified solution based on your requirements:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            result.append(list(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return result\n```\n\nVerification Report:\n\n1. **Correctness**: The implemented solution correctly generates all possible subsets of the given list `nums`. It uses a backtracking approach where subsets are formed by including and excluding elements from `nums`. This matches the intended functionality from the analysis and design specification.\n\n2. **Edge Cases**: The solution correctly handles edge cases such as:\n    - An empty input list `nums = []`, which would correctly yield `[[]]`.\n    - A list with just one element `nums = [0]`, which correctly yields `[[], [0]]`.\n\n3. **Complexity**: The solution has a time complexity of \\(O(2^n)\\) and a space complexity proportional to the number of subsets generated, \\(O(n \\times 2^n)\\), which is expected for generating power sets.\n\n4. **Code Quality**: The code is clean, structured well, and follows Python best practices such as clear variable names, succinct use of list operations, and appropriate use of helper functions like `backtrack`. It avoids unnecessary computations, and the use of a helper function makes the code modular and readable.\n\n5. **Test Cases**: Walking through the provided test cases:\n   - For `nums = [1,2,3]`, the output `[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]` is correct.\n   - For `nums = [0]`, the output `[[],[0]]` is as expected.\n\n6. **Potential Issues**: No potential issues, bugs, or logical errors were identified. The algorithm correctly implements the designed solution without redundancies or errors.\n\nIn conclusion, the solution correctly meets all coding requirements, solving the problem efficiently and accurately. No changes are necessary, and it is ready for use as-is.\n\n","TypedCode":"\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            result.append(list(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return result\n","Model":"se-gpt-4o","Latency":7792481735,"SolvedAt":"2025-09-06T23:06:53.428060359+02:00","PromptTokens":2650,"OutputTokens":796}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"78","typed_code":"\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        \n        def backtrack(start, path):\n            result.append(list(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return result\n"},"SubmissionId":1761940842,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:43:23.511920909+02:00"}}}
