{"Question":{"Data":{"Question":{"questionFrontendId":"198","questionId":"198","Content":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,9,3,1]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n","SampleTestCase":"[1,2,3,1]","ExampleTestcases":"[1,2,3,1]\n[2,7,9,3,1]","Difficulty":"Medium","Title":"House Robber","TitleSlug":"house-robber","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"3.1M\", \"totalSubmission\": \"5.9M\", \"totalAcceptedRaw\": 3115298, \"totalSubmissionRaw\": 5927764, \"acRate\": \"52.6%\"}","Likes":22727,"Dislikes":488,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int rob(int* nums, int numsSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int Rob(int[] nums) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function rob(nums: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function rob($nums) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func rob(_ nums: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun rob(nums: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int rob(List<int> nums) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func rob(nums []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @return {Integer}\ndef rob(nums)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def rob(nums: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (rob nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec rob(Nums :: [integer()]) -> integer().\nrob(Nums) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec rob(nums :: [integer]) :: integer\n  def rob(nums) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:44:19.935901232+02:00","AcRate":"52.6","TotalSubmissions":5927764,"TotalAccepted":3115298,"AcceptanceRate":0.5255435270365014,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/house-robber/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        prev1 = 0\n        prev2 = 0\n\n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n```\n\n=== DESIGN ===\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        # Algorithm Choice: Dynamic Programming\n        # We use dynamic programming to track the maximum amount of money that can be robbed up to each house.\n\n        # Step-by-Step Approach:\n        # 1. Handle the base case where there are no houses (return 0), or only one house (return the money in that house).\n        # 2. Initialize two variables prev1 and prev2 to keep track of the maximum money robbed up to the previous house and the one before that.\n        # 3. Iteratively calculate the max money that can be robbed at each house using the relation:\n        #    - For the current house, decide whether to rob it (adding its money to prev2) or skip it (keeping prev1).\n        #    - The decision is made by choosing the maximum of robbing this house with the best solution of two houses before or skipping this house with the best solution of the previous house.\n        # 4. Update prev1 and prev2 as we move to the next house.\n        # 5. The final value of prev1 after processing all houses will be our result.\n        \n        # Data Structures: We are simply using variables for tracking maximum sums.\n        \n        # Time Complexity: O(n), since we iterate through the list once.\n        \n        # Space Complexity: O(1), as we are using a constant amount of extra space.\n\n        # Pseudocode:\n        # if nums is empty:\n        #     return 0\n        # if nums has only one element:\n        #     return nums[0]\n        # Initialize prev1 = 0, prev2 = 0\n        # For each house in nums:\n        #     Calculate current = max(prev1, prev2 + house value)\n        #     Update prev2 = prev1\n        #     Update prev1 = current\n        # return prev1 as the maximum money that can be robbed\n\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        prev1 = 0  # Maximum money robbed including the previous house\n        prev2 = 0  # Maximum money robbed excluding the previous house\n        \n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        prev1 = 0\n        prev2 = 0\n        \n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n```\n\n=== VERIFICATION ===\nHere is the verification report:\n\n1. **Correctness**: \n   - The code correctly implements the dynamic programming approach to solve the problem, where it decides for each house whether to rob it or not based on maximizing the total amount. The implemented approach corresponds with the design explanation, where two variables (`prev1` and `prev2`) are used to track the maximum amount of money that can be robbed up to the current house, considering whether the current house is robbed or not.\n\n2. **Edge Cases**: \n   - The implementation handles all specified edge cases correctly: \n     - An empty list (`nums = []`) returns 0.\n     - A list with one house (`nums = [x]`) returns `x`.\n     - The code correctly handles cases with longer lists, adjusting the amounts based on the dynamic programming relation.\n\n3. **Complexity**:\n   - Time Complexity: The algorithm runs in O(n) time, where n is the number of houses, as it iterates over the list once.\n   - Space Complexity: Uses O(1) space since it only maintains two variables for the iteration.\n\n4. **Code Quality**:\n   - The code is clean, readable, and well structured.\n   - It follows good coding practices with clear variable names and no unnecessary complexity.\n\n5. **Test Cases**:\n   - Example 1: Input `nums = [1,2,3,1]`. Output is correctly `4`.\n   - Example 2: Input `nums = [2,7,9,3,1]`. Output is correctly `12`.\n   - The code produces the correct output for both provided examples.\n\n6. **Potential Issues**:\n   - No bugs or logical errors are present.\n   - No improvements are necessary as the solution is optimal, both in terms of logic and performance.\n\nConclusion:\nThe implemented solution is correct and meets all the requirements of the problem statement, algorithm design, and constraints. It handles edge cases effectively and performs within optimal time and space limits.\n\nHere is the verified and correct code:\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        prev1 = 0\n        prev2 = 0\n        \n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n```\n\n","TypedCode":"\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        prev1 = 0\n        prev2 = 0\n        \n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n","Model":"se-gpt-4o","Latency":9547177752,"SolvedAt":"2025-09-06T22:57:14.336779837+02:00","PromptTokens":3880,"OutputTokens":1219}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"198","typed_code":"\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        prev1 = 0\n        prev2 = 0\n        \n        for num in nums:\n            current = max(prev1, prev2 + num)\n            prev2 = prev1\n            prev1 = current\n            \n        return prev1\n"},"SubmissionId":1761931667,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:25:31.529213661+02:00"}}}
