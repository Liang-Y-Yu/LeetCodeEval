{"Question":{"Data":{"Question":{"questionFrontendId":"23","questionId":"23","Content":"<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted linked list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n","SampleTestCase":"[[1,4,5],[1,3,4],[2,6]]","ExampleTestcases":"[[1,4,5],[1,3,4],[2,6]]\n[]\n[[]]","Difficulty":"Hard","Title":"Merge k Sorted Lists","TitleSlug":"merge-k-sorted-lists","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"2.6M\", \"totalSubmission\": \"4.6M\", \"totalAcceptedRaw\": 2647614, \"totalSubmissionRaw\": 4599203, \"acRate\": \"57.6%\"}","Likes":20713,"Dislikes":768,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjc=","Name":"Linked List","Slug":"linked-list"},{"Id":"VG9waWNUYWdOb2RlOjEy","Name":"Divide and Conquer","Slug":"divide-and-conquer"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUx","Name":"Merge Sort","Slug":"merge-sort"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[Optional[ListNode]]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeKLists(ListNode[] lists) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode[] $lists\n     * @return ListNode\n     */\n    function mergeKLists($lists) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeKLists(lists: Array<ListNode?>): ListNode? {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeKLists(List<ListNode?> lists) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode[]} lists\n# @return {ListNode}\ndef merge_k_lists(lists)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeKLists(lists: Array[ListNode]): ListNode = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-k-lists lists)\n  (-> (listof (or/c list-node? #f)) (or/c list-node? #f))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_k_lists(Lists :: [#list_node{} | null]) -> #list_node{} | null.\nmerge_k_lists(Lists) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_k_lists(lists :: [ListNode.t | nil]) :: ListNode.t | nil\n  def merge_k_lists(lists) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:46:33.8238958+02:00","AcRate":"57.6","TotalSubmissions":4599203,"TotalAccepted":2647614,"AcceptanceRate":0.5756680016081047,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/merge-k-sorted-lists/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        # Initialize the min heap with the first node of each list\n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n```\n\n=== DESIGN ===\n```python\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        # Initialize the min heap with the first node of each list\n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n```\n\n=== VERIFICATION ===\n```python\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        # Initialize the min heap with the first node of each list\n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n```\n\n","TypedCode":"\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n","Model":"se-gpt-4o","Latency":7712255925,"SolvedAt":"2025-09-06T23:01:11.160802996+02:00","PromptTokens":3911,"OutputTokens":834}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"23","typed_code":"\nfrom typing import List, Optional\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        for index, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, index, node))\n        \n        dummy = ListNode(0)\n        tail = dummy\n        \n        while min_heap:\n            val, index, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, index, node.next))\n        \n        return dummy.next\n"},"SubmissionId":1761936067,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:34:07.227179398+02:00"}}}
