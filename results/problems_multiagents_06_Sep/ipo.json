{"Question":{"Data":{"Question":{"questionFrontendId":"502","questionId":"502","Content":"<p>Suppose LeetCode will start its <strong>IPO</strong> soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the <strong>IPO</strong>. Since it has limited resources, it can only finish at most <code>k</code> distinct projects before the <strong>IPO</strong>. Help LeetCode design the best way to maximize its total capital after finishing at most <code>k</code> distinct projects.</p>\n\n<p>You are given <code>n</code> projects where the <code>i<sup>th</sup></code> project has a pure profit <code>profits[i]</code> and a minimum capital of <code>capital[i]</code> is needed to start it.</p>\n\n<p>Initially, you have <code>w</code> capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.</p>\n\n<p>Pick a list of <strong>at most</strong> <code>k</code> distinct projects from given projects to <strong>maximize your final capital</strong>, and return <em>the final maximized capital</em>.</p>\n\n<p>The answer is guaranteed to fit in a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","SampleTestCase":"2\n0\n[1,2,3]\n[0,1,1]","ExampleTestcases":"2\n0\n[1,2,3]\n[0,1,1]\n3\n0\n[1,2,3]\n[0,1,2]","Difficulty":"Hard","Title":"IPO","TitleSlug":"ipo","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"284.9K\", \"totalSubmission\": \"536.2K\", \"totalAcceptedRaw\": 284893, \"totalSubmissionRaw\": 536210, \"acRate\": \"53.1%\"}","Likes":4061,"Dislikes":277,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjE3","Name":"Greedy","Slug":"greedy"},{"Id":"VG9waWNUYWdOb2RlOjYxMDQ5","Name":"Sorting","Slug":"sorting"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int FindMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} k\n * @param {number} w\n * @param {number[]} profits\n * @param {number[]} capital\n * @return {number}\n */\nvar findMaximizedCapital = function(k, w, profits, capital) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function findMaximizedCapital(k: number, w: number, profits: number[], capital: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $k\n     * @param Integer $w\n     * @param Integer[] $profits\n     * @param Integer[] $capital\n     * @return Integer\n     */\n    function findMaximizedCapital($k, $w, $profits, $capital) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func findMaximizedCapital(_ k: Int, _ w: Int, _ profits: [Int], _ capital: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun findMaximizedCapital(k: Int, w: Int, profits: IntArray, capital: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int findMaximizedCapital(int k, int w, List<int> profits, List<int> capital) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func findMaximizedCapital(k int, w int, profits []int, capital []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} k\n# @param {Integer} w\n# @param {Integer[]} profits\n# @param {Integer[]} capital\n# @return {Integer}\ndef find_maximized_capital(k, w, profits, capital)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def findMaximizedCapital(k: Int, w: Int, profits: Array[Int], capital: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (find-maximized-capital k w profits capital)\n  (-> exact-integer? exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec find_maximized_capital(K :: integer(), W :: integer(), Profits :: [integer()], Capital :: [integer()]) -> integer().\nfind_maximized_capital(K, W, Profits, Capital) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec find_maximized_capital(k :: integer, w :: integer, profits :: [integer], capital :: [integer]) :: integer\n  def find_maximized_capital(k, w, profits, capital) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:44:33.011415476+02:00","AcRate":"53.1","TotalSubmissions":536210,"TotalAccepted":284893,"AcceptanceRate":0.5313086290818896,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/ipo/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        projects = list(zip(capital, profits))\n        projects.sort()\n        \n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        for _ in range(k):\n            while current_index < n and projects[current_index][0] <= w:\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            if max_heap:\n                w += -heapq.heappop(max_heap)\n            else:\n                break\n                \n        return w\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        # Combine projects with their capital and profit as tuples\n        projects = list(zip(capital, profits))\n        # Sort projects by capital required (ascending order)\n        projects.sort()\n        \n        # Max heap to keep track of the maximal profit project available with current capital\n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        # Iterate until we've selected k projects or no profitable project can be selected\n        for _ in range(k):\n            # Add all projects that can be started with current capital to the max heap\n            while current_index < n and projects[current_index][0] <= w:\n                # Use negative profit for max heap to simulate a max heap with min heap structure\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            # Check if there is any project in the heap\n            if max_heap:\n                # Pop the project with maximum profit (top of max heap)\n                w += -heapq.heappop(max_heap)\n            else:\n                # No more projects can be selected\n                break\n        \n        return w\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        projects = list(zip(capital, profits))\n        projects.sort()\n        \n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        for _ in range(k):\n            while current_index < n and projects[current_index][0] <= w:\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            if max_heap:\n                w += -heapq.heappop(max_heap)\n            else:\n                break\n                \n        return w\n```\n\n=== VERIFICATION ===\nHere is the expanded solution code:\n\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        # Combine projects with their capital and profit as tuples\n        projects = list(zip(capital, profits))\n        # Sort projects by capital required (ascending order)\n        projects.sort()\n        \n        # Max heap to keep track of the maximal profit project available with current capital\n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        # Iterate until we've selected k projects or no profitable project can be selected\n        for _ in range(k):\n            # Add all projects that can be started with current capital to the max heap\n            while current_index < n and projects[current_index][0] <= w:\n                # Use negative profit for max heap to simulate a max heap with min heap structure\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            # Check if there is any project in the heap\n            if max_heap:\n                # Pop the project with maximum profit (top of max heap)\n                w += -heapq.heappop(max_heap)\n            else:\n                # No more projects can be selected\n                break\n        \n        return w\n```\n\nVerification Report:\n\n1. **Correctness**: The code correctly implements the algorithm as designed, ensuring that the capital is maximized by selecting at most k projects with available capital, using a max heap to prioritize projects with higher profit.\n\n2. **Edge Cases**: The solution effectively handles edge cases:\n   - When `k` is larger than the number of projects, it ensures no more than `n` projects are selected.\n   - When all projects have a capital requirement higher than the initial capital `w`, it correctly chooses no projects, resulting in the same capital.\n   - The given constraints, such as no negative profits or capital, ensure input is always valid.\n\n3. **Complexity**: The main operations involve sorting the projects by capital once (O(n log n)) and iterating through them, which is efficient given the constraints. The heap operations (insert and pop) are O(log n), ensuring the solution scales well to large inputs.\n\n4. **Code Quality**: The code is clean, well-structured, and follows best practices. It uses descriptive variable names, and employs Python's heapq library for max heap operations, maintaining readability and efficiency.\n\n5. **Test Cases**: The code returns correct outputs for the provided examples. For example:\n   - Example 1 produces a final capital of 4, correctly selecting projects based on current capital availability.\n   - Example 2 yields a capital of 6, similarly maximizing the capital efficiently by prioritizing profitable projects.\n\n6. **Potential Issues**: No bugs or logical errors are identified. The code does not have unnecessary complexity and addresses the problem requirements effectively.\n\nThe solution is confirmed valid and correct, meeting expected requirements and constraints.\n\n","TypedCode":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        projects = list(zip(capital, profits))\n        projects.sort()\n        \n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        for _ in range(k):\n            while current_index < n and projects[current_index][0] <= w:\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            if max_heap:\n                w += -heapq.heappop(max_heap)\n            else:\n                break\n                \n        return w\n","Model":"se-gpt-4o","Latency":9420368083,"SolvedAt":"2025-09-06T22:57:46.191060767+02:00","PromptTokens":4473,"OutputTokens":1222}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"502","typed_code":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        projects = list(zip(capital, profits))\n        projects.sort()\n        \n        max_heap = []\n        current_index = 0\n        n = len(profits)\n        \n        for _ in range(k):\n            while current_index < n and projects[current_index][0] <= w:\n                heapq.heappush(max_heap, -projects[current_index][1])\n                current_index += 1\n            \n            if max_heap:\n                w += -heapq.heappop(max_heap)\n            else:\n                break\n                \n        return w\n"},"SubmissionId":1761932325,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:26:44.865180645+02:00"}}}
