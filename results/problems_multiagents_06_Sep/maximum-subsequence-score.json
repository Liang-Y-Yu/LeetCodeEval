{"Question":{"Data":{"Question":{"questionFrontendId":"2542","questionId":"2636","Content":"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code> of equal length <code>n</code> and a positive integer <code>k</code>. You must choose a <strong>subsequence</strong> of indices from <code>nums1</code> of length <code>k</code>.</p>\n\n<p>For chosen indices <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, ..., <code>i<sub>k - 1</sub></code>, your <strong>score</strong> is defined as:</p>\n\n<ul>\n\t<li>The sum of the selected elements from <code>nums1</code> multiplied with the <strong>minimum</strong> of the selected elements from <code>nums2</code>.</li>\n\t<li>It can defined simply as: <code>(nums1[i<sub>0</sub>] + nums1[i<sub>1</sub>] +...+ nums1[i<sub>k - 1</sub>]) * min(nums2[i<sub>0</sub>] , nums2[i<sub>1</sub>], ... ,nums2[i<sub>k - 1</sub>])</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> possible score.</em></p>\n\n<p>A <strong>subsequence</strong> of indices of an array is a set that can be derived from the set <code>{0, 1, ..., n-1}</code> by deleting some or no elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> \nChoosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n","SampleTestCase":"[1,3,3,2]\n[2,1,3,4]\n3","ExampleTestcases":"[1,3,3,2]\n[2,1,3,4]\n3\n[4,2,3,1,1]\n[7,5,10,9,6]\n1","Difficulty":"Medium","Title":"Maximum Subsequence Score","TitleSlug":"maximum-subsequence-score","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"136.7K\", \"totalSubmission\": \"251.5K\", \"totalAcceptedRaw\": 136741, \"totalSubmissionRaw\": 251542, \"acRate\": \"54.4%\"}","Likes":3057,"Dislikes":206,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjE3","Name":"Greedy","Slug":"greedy"},{"Id":"VG9waWNUYWdOb2RlOjYxMDQ5","Name":"Sorting","Slug":"sorting"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar maxScore = function(nums1, nums2, k) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxScore(nums1: number[], nums2: number[], k: number): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxScore($nums1, $nums2, $k) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxScore(nums1: IntArray, nums2: IntArray, k: Int): Long {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int maxScore(List<int> nums1, List<int> nums2, int k) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxScore(nums1 []int, nums2 []int, k int) int64 {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer} k\n# @return {Integer}\ndef max_score(nums1, nums2, k)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxScore(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_score(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-score nums1 nums2 k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_score(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> integer().\nmax_score(Nums1, Nums2, K) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_score(nums1 :: [integer], nums2 :: [integer], k :: integer) :: integer\n  def max_score(nums1, nums2, k) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:46:28.773257598+02:00","AcRate":"54.4","TotalSubmissions":251542,"TotalAccepted":136741,"AcceptanceRate":0.5436110073069309,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/maximum-subsequence-score/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        # Zip and sort nums1 and nums2 by the values in nums2 in descending order\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n\n        # We iterate through the sorted pairs and maintain a min-heap of size k\n        for num1, num2 in indexed_pairs:\n            # Use a min-heap to keep the largest possible sum of nums1 with k elements\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            # If the heap is larger than k, remove the smallest element\n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            # When we have exactly k elements in the sum, calculate potential max score\n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n\n        return max_score\n```\n\n=== DESIGN ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n        \n        for num1, num2 in indexed_pairs:\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n        \n        return max_score\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n        \n        for num1, num2 in indexed_pairs:\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n        \n        return max_score\n```\n\n=== VERIFICATION ===\nThe code provided solves the problem using a strategic approach. Let's review it based on your criteria:\n\n1. **Correctness**: The code correctly implements the designed algorithm. It uses a min-heap to maintain the largest sum possible from `nums1` of size `k` while iterating over sorted pairs of `(nums1[i], nums2[i])` in descending order based on `nums2` values. This ensures that the minimum `nums2` value in the chosen subsequence is maximized, leading to an optimal score calculation.\n\n2. **Edge Cases**: The code handles edge cases effectively, such as when `k = n`, where it will iterate over all elements and select the best possible subsequence that meets the criteria.\n\n3. **Complexity**: The time complexity is O(n log n) due to sorting the initial array, and the space complexity is O(k) for the min-heap. Given that these are efficient for the problem constraints (1 ≤ n ≤ 100,000), the solution is appropriate.\n\n4. **Code Quality**: The code is clean, readable, and follows best practices. The use of comments and structured logic makes the implementation easy to understand.\n\n5. **Test Cases**: The code produces correct outputs for the provided examples:\n   - Example 1: Selecting indices `[0, 2, 3]`, yields score of `12`.\n   - Example 2: Selecting index `[2]`, gives a score of `30`.\nThe logic matches expected behavior.\n\n6. **Potential Issues**: There are no visible bugs or logical errors. The strategy ensures the maximum score is found using the conditions given.\n\nGiven this analysis, the solution is correct, efficient, and ready for execution.\n\nHere is the verified implementation:\n\n```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n        \n        for num1, num2 in indexed_pairs:\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n        \n        return max_score\n```\n\n","TypedCode":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n        \n        for num1, num2 in indexed_pairs:\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n        \n        return max_score\n","Model":"se-gpt-4o","Latency":10375708091,"SolvedAt":"2025-09-06T23:00:38.22591957+02:00","PromptTokens":4929,"OutputTokens":1154}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"2636","typed_code":"\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        indexed_pairs = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\n        \n        max_score = 0\n        sum_nums1 = 0\n        min_heap = []\n        \n        for num1, num2 in indexed_pairs:\n            heapq.heappush(min_heap, num1)\n            sum_nums1 += num1\n            \n            if len(min_heap) > k:\n                sum_nums1 -= heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                score = sum_nums1 * num2\n                max_score = max(max_score, score)\n        \n        return max_score\n"},"SubmissionId":1761935574,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:33:07.151620237+02:00"}}}
