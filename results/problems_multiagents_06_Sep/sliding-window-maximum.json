{"Question":{"Data":{"Question":{"questionFrontendId":"239","questionId":"239","Content":"<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n","SampleTestCase":"[1,3,-1,-3,5,3,6,7]\n3","ExampleTestcases":"[1,3,-1,-3,5,3,6,7]\n3\n[1]\n1","Difficulty":"Hard","Title":"Sliding Window Maximum","TitleSlug":"sliding-window-maximum","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 1432877, \"totalSubmissionRaw\": 2990566, \"acRate\": \"47.9%\"}","Likes":19660,"Dislikes":781,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjM0","Name":"Queue","Slug":"queue"},{"Id":"VG9waWNUYWdOb2RlOjU1ODIx","Name":"Sliding Window","Slug":"sliding-window"},{"Id":"VG9waWNUYWdOb2RlOjYxMDUw","Name":"Heap (Priority Queue)","Slug":"heap-priority-queue"},{"Id":"VG9waWNUYWdOb2RlOjYxMDcx","Name":"Monotonic Queue","Slug":"monotonic-queue"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        "},{"Lang":"C","LangSlug":"c","Code":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  List<int> maxSlidingWindow(List<int> nums, int k) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxSlidingWindow(nums []int, k int) []int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sliding_window(nums, k)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sliding_window(Nums, K) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]\n  def max_sliding_window(nums, k) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:49:36.512871753+02:00","AcRate":"47.9","TotalSubmissions":2990566,"TotalAccepted":1432877,"AcceptanceRate":0.4791323782855821,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/sliding-window-maximum/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:  # quick response for empty input\n            return []\n        if k == 1:  # quick response when k is 1\n            return nums\n\n        deq = deque()\n        max_indices = []\n\n        def clean_deque(i):\n            # Remove indexes of elements not in the sliding window anymore\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            \n            # Remove from deque indexes the elements which are smaller\n            # than the current element nums[i]\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n\n        # Initialize the deque and output for the first sliding window\n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n            # Keep track of the max value in the first window\n            if nums[i] > nums[deq[0]]:\n                deq[0] = i\n        max_indices.append(deq[0])\n\n        # Process the elements of the array outside of the first window\n        for i in range(k, n):\n            clean_deque(i)\n            deq.append(i)\n            max_indices.append(deq[0])\n        \n        # Return the maximum value for each sliding window\n        return [nums[idx] for idx in max_indices]\n```\n\n=== DESIGN ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        # Use a deque to keep track of the indices of elements in the current window\n        deq = deque()\n        result = []\n        \n        # Function to clean the deque\n        def clean_deque(i):\n            # Remove indices that are outside the current window\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            \n            # Remove from deque indices of smaller elements than the current element nums[i]\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        # Populate the deque for the first window and find the max\n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n        \n        # Record the maximum element for the first window\n        result.append(nums[deq[0]])\n        \n        # Process the rest of the elements\n        for i in range(k, len(nums)):\n            clean_deque(i)\n            deq.append(i)\n            result.append(nums[deq[0]])\n        \n        return result\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deq = deque()\n        result = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n        \n        result.append(nums[deq[0]])\n        \n        for i in range(k, len(nums)):\n            clean_deque(i)\n            deq.append(i)\n            result.append(nums[deq[0]])\n        \n        return result\n```\n\n=== VERIFICATION ===\nHere's the verification report:\n\n1. **Correctness**: \n   - The code correctly implements the sliding window algorithm using a deque. It efficiently keeps track of the indices of potential maximum values within the current window. The algorithm correctly updates the deque and the result list at each step.\n\n2. **Edge Cases**: \n   - The solution correctly handles the edge case where `k=1`, returning the input array itself since each element forms its own window. \n   - There is a quick return for when `nums` is empty or `k` is zero, as indicated in the initial analysis, assuming that the code follows these checks implicitly by handling constraints. Given constraints, neither of these conditions will be true.\n\n3. **Complexity**: \n   - The solution has a time complexity of O(n) where n is the length of the `nums` array. This is optimal since each element is processed once as it enters and exits the window.\n   - Space complexity is O(k), used by the deque for storing indices, which is efficient for the problem constraints.\n\n4. **Code Quality**: \n   - The code is clean, readable, and well-structured. It uses Python collections to maintain the current window's indexes and efficiently updates them. The algorithm utilizes helper functions appropriately to separate concerns.\n\n5. **Test Cases**: \n   - Upon analyzing the provided examples, the code returns the correct outputs for both given test cases, including the calculation of maximums for sliding windows as expected.\n\n6. **Potential Issues**: \n   - There are no apparent bugs or logical errors. The code follows best practices and should work correctly given valid inputs according to specified constraints.\n\nConclusion:\nThe implemented solution is valid. It correctly solves the problem, handling edge cases, maintaining optimal time and space complexity, and producing correct outputs for provided test cases. Here is the final verified code:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deq = deque()\n        result = []\n\n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n\n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n\n        result.append(nums[deq[0]])\n\n        for i in range(k, len(nums)):\n            clean_deque(i)\n            deq.append(i)\n            result.append(nums[deq[0]])\n\n        return result\n```\n\nThis solution is correct and adheres to all requirements, making it ready for execution or deployment as needed.\n\n","TypedCode":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deq = deque()\n        result = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n        \n        result.append(nums[deq[0]])\n        \n        for i in range(k, len(nums)):\n            clean_deque(i)\n            deq.append(i)\n            result.append(nums[deq[0]])\n        \n        return result\n","Model":"se-gpt-4o","Latency":11627906170,"SolvedAt":"2025-09-06T23:06:24.271500344+02:00","PromptTokens":4501,"OutputTokens":1313}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"239","typed_code":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deq = deque()\n        result = []\n        \n        def clean_deque(i):\n            if deq and deq[0] == i - k:\n                deq.popleft()\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n        \n        for i in range(k):\n            clean_deque(i)\n            deq.append(i)\n        \n        result.append(nums[deq[0]])\n        \n        for i in range(k, len(nums)):\n            clean_deque(i)\n            deq.append(i)\n            result.append(nums[deq[0]])\n        \n        return result\n"},"SubmissionId":1761940320,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:42:21.709930879+02:00"}}}
