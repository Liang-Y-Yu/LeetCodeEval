{"Question":{"Data":{"Question":{"questionFrontendId":"123","questionId":"123","Content":"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n","SampleTestCase":"[3,3,5,0,0,3,1,4]","ExampleTestcases":"[3,3,5,0,0,3,1,4]\n[1,2,3,4,5]\n[7,6,4,3,1]","Difficulty":"Hard","Title":"Best Time to Buy and Sell Stock III","TitleSlug":"best-time-to-buy-and-sell-stock-iii","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"846.9K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 846941, \"totalSubmissionRaw\": 1628220, \"acRate\": \"52.0%\"}","Likes":10332,"Dislikes":216,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int maxProfit(int* prices, int pricesSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxProfit(prices: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int maxProfit(List<int> prices) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxProfit(prices []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-profit prices)\n  (-> (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_profit(Prices :: [integer()]) -> integer().\nmax_profit(Prices) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_profit(prices :: [integer]) :: integer\n  def max_profit(prices) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:41:16.227650532+02:00","AcRate":"52.0","TotalSubmissions":1628220,"TotalAccepted":846941,"AcceptanceRate":0.5201637370871258,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\n=== DESIGN ===\nSure, let's design a solution approach:\n\n1. **Algorithm Choice**:\n   - Use dynamic programming to track the maximum profit attainable through two separate transactions.\n\n2. **Step-by-Step Approach**:\n   - Compute maximum profit for each day assuming transactions can only happen up to that day (`left_profits`).\n   - Compute maximum profit for each day assuming transactions can only happen after that day (`right_profits`).\n   - The maximum combined profit for two transactions on any given day is the sum of maximum profits from `left_profits` and `right_profits` for that day.\n   - Iterate over the entire price list and calculate the maximum profit possible using the combination of left and right profits.\n\n3. **Data Structures**:\n   - Arrays `left_profits` and `right_profits` to store maximum profit from one transaction from the left and right of each day.\n\n4. **Time Complexity**:\n   - O(n), where n is the number of days. The algorithm iterates over the list of prices twice.\n\n5. **Space Complexity**:\n   - O(n), due to storing the left and right profits arrays.\n\n6. **Pseudocode**:\n   ```\n   Initialize left_profits array with 0 values, length = n\n   Initialize right_profits array with 0 values, length = n\n   Set min_price to the first element of prices\n   For each day i from 1 to n-1:\n       Update left_profits[i] to the maximum of left_profits[i-1] and the profit if sold on day i (prices[i] - min_price)\n       Update min_price to the minimum of min_price and prices[i]\n   Set max_price to the last element of prices\n   For each day i from n-2 to 0:\n       Update right_profits[i] to the maximum of right_profits[i+1] and the profit if bought on day i (max_price - prices[i])\n       Update max_price to the maximum of max_price and prices[i]\n   Initialize max_profit to 0\n   For each day i from 0 to n-1:\n       Update max_profit to the maximum of max_profit and the sum of left_profits[i] and right_profits[i]\n   Return max_profit\n   ```\n\nHere's the implementation of this approach:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\n=== VERIFICATION ===\nHere's the verification report for the provided solution:\n\n1. **Correctness**: \n   - The code correctly implements the designed algorithm to calculate the maximum profit possible with at most two transactions. It uses dynamic programming to track the profits after the first and second transactions separately.\n\n2. **Edge Cases**:\n   - Handles the case where `prices` is empty or has less than 2 elements, returning 0 profit as expected. This is checked explicitly with `if not prices or len(prices) < 2:`.\n   - Handles cases where the prices are in descending order, hence no profit can be made, returning 0.\n   - Handles cases where prices do not allow two transactions (i.e., having only one clear profit opportunity).\n\n3. **Complexity**:\n   - The code achieves a time complexity of O(n) and a space complexity of O(n), both acceptable given the constraints (1 ≤ n ≤ 10^5). This ensures efficiency in both time and memory usage.\n\n4. **Code Quality**:\n   - The code is clean and readable. It follows best practices, including the use of descriptive variable names (`left_profits`, `right_profits`, `min_price`, `max_price`) and systematic approach in solving the problem using dynamic programming.\n\n5. **Test Cases**:\n   - The solution correctly produces the expected outputs for the provided example test cases:\n     - Example 1: `[3,3,5,0,0,3,1,4]` outputs `6`, as expected.\n     - Example 2: `[1,2,3,4,5]` outputs `4`, as expected.\n     - Example 3: `[7,6,4,3,1]` outputs `0`, as expected.\n\n6. **Potential Issues**:\n   - No bugs or logical errors are found. The current algorithm efficiently calculates the maximum profit possible with the conditions specified.\n\nSince the solution meets all the requirements and correctly implements the algorithm design, we confirm its validity. Here is the final code:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n```\n\nThe solution is correct and performs within expected complexity boundaries, handling all specified edge cases.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n","Model":"se-gpt-4o","Latency":16369862311,"SolvedAt":"2025-09-06T22:52:36.586108539+02:00","PromptTokens":5189,"OutputTokens":1880}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"123","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        \n        n = len(prices)\n        \n        # First transaction\n        left_profits = [0] * n\n        min_price = prices[0]\n        \n        for i in range(1, n):\n            left_profits[i] = max(left_profits[i-1], prices[i] - min_price)\n            min_price = min(min_price, prices[i])\n        \n        # Second transaction\n        right_profits = [0] * n\n        max_price = prices[-1]\n        \n        for i in range(n-2, -1, -1):\n            right_profits[i] = max(right_profits[i+1], max_price - prices[i])\n            max_price = max(max_price, prices[i])\n        \n        # Calculate max possible profit with two transactions\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, left_profits[i] + right_profits[i])\n        \n        return max_profit\n"},"SubmissionId":1761926656,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:15:56.501016622+02:00"}}}
