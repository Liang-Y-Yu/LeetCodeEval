{"Question":{"Data":{"Question":{"questionFrontendId":"127","questionId":"127","Content":"<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n","SampleTestCase":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]","ExampleTestcases":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]","Difficulty":"Hard","Title":"Word Ladder","TitleSlug":"word-ladder","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.3M\", \"totalAcceptedRaw\": 1441744, \"totalSubmissionRaw\": 3303133, \"acRate\": \"43.6%\"}","Likes":13044,"Dislikes":1944,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjIy","Name":"Breadth-First Search","Slug":"breadth-first-search"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int ladderLength(char* beginWord, char* endWord, char** wordList, int wordListSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return Integer\n     */\n    function ladderLength($beginWord, $endWord, $wordList) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func ladderLength(beginWord string, endWord string, wordList []string) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (ladder-length beginWord endWord wordList)\n  (-> string? string? (listof string?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec ladder_length(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> integer().\nladder_length(BeginWord, EndWord, WordList) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec ladder_length(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: integer\n  def ladder_length(begin_word, end_word, word_list) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-09-06T22:51:03.064234469+02:00","AcRate":"43.6","TotalSubmissions":3303133,"TotalAccepted":1441744,"AcceptanceRate":0.4364777318987761,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/word-ladder/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Ensure endWord is in the wordList\n        if endWord not in wordList:\n            return 0\n\n        wordSet = set(wordList)  # Convert list to set for O(1) lookups\n        queue = deque([(beginWord, 1)])  # Queue for BFS, stores (current_word, current_length)\n\n        while queue:\n            current_word, current_length = queue.popleft()\n\n            # Generate all possible transformations of current_word\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    # Change one character at position i\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    \n                    # If the transformed word is endWord, we return the length + 1\n                    if next_word == endWord:\n                        return current_length + 1\n                    \n                    # If next_word is in the set, we add it to the queue\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)  # Mark this word as visited\n                        queue.append((next_word, current_length + 1))\n        \n        return 0  # If no transformation sequence is found, return 0\n```\n\n=== DESIGN ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Ensure endWord is in the wordList\n        if endWord not in wordList:\n            return 0\n        \n        # Convert wordList to a set for O(1) lookups\n        wordSet = set(wordList)\n        \n        # Initialize queue for BFS, storing pairs of (current_word, current_length)\n        queue = deque([(beginWord, 1)])\n        \n        # Perform BFS\n        while queue:\n            current_word, current_length = queue.popleft()\n            \n            # Generate all possible transformations of current_word\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    # Change one character at position i\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    \n                    # If the transformed word is endWord, we return the length + 1\n                    if next_word == endWord:\n                        return current_length + 1\n                    \n                    # If next_word is in the set and not yet visited\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)  # Mark this word as visited\n                        queue.append((next_word, current_length + 1))\n        \n        # If no transformation sequence is found, return 0\n        return 0\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        while queue:\n            current_word, current_length = queue.popleft()\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    if next_word == endWord:\n                        return current_length + 1\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, current_length + 1))\n        return 0\n```\n\n=== VERIFICATION ===\nThe implemented code for the `ladderLength` method appears to be correct upon review. I will address the verification criteria:\n\n1. **Correctness**: \n   - The code correctly uses Breadth-First Search (BFS) to explore all possible transformations, ensuring it finds the shortest path.\n   - It returns the correct transformation length, incrementing by one each time a valid word transformation is found.\n\n2. **Edge Cases**:\n   - The code handles edge cases where the `endWord` is not in the `wordList` by immediately returning `0`.\n   - It works with words of varying lengths as long as they meet the constraints.\n   - It correctly handles cases where no transformation path exists by returning `0`.\n\n3. **Complexity**:\n   - Time complexity is O(M^2 * N), where:\n     - M is the length of each word.\n     - N is the number of words in the `wordList`.\n   - Space complexity is O(N) due to the usage of sets for tracking visited words and the queue for BFS.\n\n4. **Code Quality**:\n   - The code is clean, well-structured, and follows Python best practices.\n   - It uses appropriate constructs like `deque` for BFS and `set` for O(1) lookups.\n\n5. **Test Cases**:\n   - Example test cases are correctly handled:\n     1. From `hit` to `cog` using the given `wordList` results in a transformation length of 5.\n     2. When `endWord` is not in the list, it correctly returns `0`.\n\n6. **Potential Issues**:\n   - The code efficiently handles transformations without unnecessary computations or logical errors.\n   - No immediate improvements are needed as the structure and logic handle the given problem constraints effectively.\n\nIn conclusion, the solution is technically correct, efficient, and adheres to best coding practices. It provides the correct outputs for the sample test cases and handles edge cases as expected.\n\nHere is the verified solution in Python:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        while queue:\n            current_word, current_length = queue.popleft()\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    if next_word == endWord:\n                        return current_length + 1\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, current_length + 1))\n        return 0\n```\n\n","TypedCode":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        while queue:\n            current_word, current_length = queue.popleft()\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    if next_word == endWord:\n                        return current_length + 1\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, current_length + 1))\n        return 0\n","Model":"se-gpt-4o","Latency":11236487630,"SolvedAt":"2025-09-06T23:12:02.91134517+02:00","PromptTokens":4514,"OutputTokens":1354}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"127","typed_code":"\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        while queue:\n            current_word, current_length = queue.popleft()\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + char + current_word[i+1:]\n                    if next_word == endWord:\n                        return current_length + 1\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, current_length + 1))\n        return 0\n"},"SubmissionId":1761942681,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-09-06T23:47:19.685407905+02:00"}}}
