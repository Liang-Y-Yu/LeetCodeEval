{"Question":{"Data":{"Question":{"questionFrontendId":"188","questionId":"188","Content":"<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n","SampleTestCase":"2\n[2,4,1]","ExampleTestcases":"2\n[2,4,1]\n2\n[3,2,6,5,0,3]","Difficulty":"Hard","Title":"Best Time to Buy and Sell Stock IV","TitleSlug":"best-time-to-buy-and-sell-stock-iv","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"621.8K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 621804, \"totalSubmissionRaw\": 1301074, \"acRate\": \"47.8%\"}","Likes":7810,"Dislikes":218,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int maxProfit(int k, int[] prices) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int maxProfit(int k, int* prices, int pricesSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int MaxProfit(int k, int[] prices) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(k, prices) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function maxProfit(k: number, prices: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $k\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($k, $prices) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun maxProfit(k: Int, prices: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int maxProfit(int k, List<int> prices) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func maxProfit(k int, prices []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} k\n# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(k, prices)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def maxProfit(k: Int, prices: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (max-profit k prices)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec max_profit(K :: integer(), Prices :: [integer()]) -> integer().\nmax_profit(K, Prices) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec max_profit(k :: integer, prices :: [integer]) :: integer\n  def max_profit(k, prices) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:09:53.508232436+02:00","AcRate":"47.8","TotalSubmissions":1301074,"TotalAccepted":621804,"AcceptanceRate":0.4779159371411618,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        \n        # If k is greater than n/2, it's equivalent to unlimited transactions.\n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n        \n        # dp[i][j] is the max profit we can get with at most i transactions by the j-th day\n        dp = [[0] * n for _ in range(k+1)]\n        \n        for i in range(1, k + 1):\n            maxDiff = -prices[0]  # max difference between price and profit from previous transaction\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])\n        \n        return dp[k][n-1]\n```\n\n=== DESIGN ===\n```python\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        \n        # If k is greater than n/2, it's equivalent to unlimited transactions.\n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n        \n        # dp[i][j] will store the max profit with at most i transactions by the j-th day\n        dp = [[0] * n for _ in range(k+1)]\n        \n        for i in range(1, k + 1):\n            maxDiff = -prices[0]  # Max difference between price and profit from previous transaction\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])\n        \n        return dp[k][n-1]\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        \n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n        \n        dp = [[0] * n for _ in range(k+1)]\n        \n        for i in range(1, k + 1):\n            maxDiff = -prices[0]\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])\n        \n        return dp[k][n-1]\n```\n\n=== VERIFICATION ===\nHere is the verification report for the provided solution:\n\n1. **Correctness**: The implemented code correctly follows the design and matches the algorithm described. It appropriately addresses the problem of finding the maximum profit with at most `k` transactions.\n\n2. **Edge Cases**: The code handles various edge cases:\n   - If the `prices` list is empty, it correctly returns 0.\n   - If `k` is greater than or equal to `n // 2`, which means transactions are effectively limitless, it computes the maximum achievable profit by summing profitable differences.\n   - The algorithm handles normal cases with valid prices and transactions.\n   \n3. **Complexity**: \n   - The time complexity of the algorithm is O(k * n), where `k` is the number of transactions and `n` is the number of days/prices. This is efficient given the constraints (1 <= k <= 100 and 1 <= prices.length <= 1000).\n   - The space complexity is O(k * n) due to the 2D DP table. This is acceptable within the given constraints.\n\n4. **Code Quality**: \n   - The code is clean and follows best practices. It is organized, with descriptive variable names and a logical structure.\n   - The use of list comprehensions is appropriate for the sum calculation when `k` exceeds `n // 2`.\n   - The solution uses dynamic programming to efficiently track potential profits for each transaction count up to `k`.\n\n5. **Test Cases**: \n   - The provided code passes the example test cases given in the problem description:\n      - Example 1: Input `k = 2, prices = [2,4,1]`, output is correctly `2`.\n      - Example 2: Input `k = 2, prices = [3,2,6,5,0,3]`, output is correctly `7`.\n   - The solution should work for other test cases within the constraints as it handles various scenarios.\n\n6. **Potential Issues**: No significant issues were found. The solution is optimal and correctly handles the constraints and edge cases detailed in the problem statement.\n\nThe original code implementation is verified as correct and follows the expected design and algorithm. There are no changes needed for the solution as it meets all requirements given in the problem statement.\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        \n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n        \n        dp = [[0] * n for _ in range(k+1)]\n        \n        for i in range(1, k + 1):\n            maxDiff = -prices[0]\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])\n        \n        return dp[k][n-1]\n","Model":"se-gpt-4o","Latency":12992147770,"SolvedAt":"2025-08-07T09:31:00.391726621+02:00","PromptTokens":3967,"OutputTokens":1125}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"188","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        \n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n        \n        dp = [[0] * n for _ in range(k+1)]\n        \n        for i in range(1, k + 1):\n            maxDiff = -prices[0]\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])\n        \n        return dp[k][n-1]\n"},"SubmissionId":1726594550,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T09:54:38.782409205+02:00"}}}
