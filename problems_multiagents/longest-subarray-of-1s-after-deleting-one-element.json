{"Question":{"Data":{"Question":{"questionFrontendId":"1493","questionId":"1586","Content":"<p>Given a binary array <code>nums</code>, you should delete one element from it.</p>\n\n<p>Return <em>the size of the longest non-empty subarray containing only </em><code>1</code><em>&#39;s in the resulting array</em>. Return <code>0</code> if there is no such subarray.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,0,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1&#39;s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1,1,0,1,1,0,1]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1&#39;s is [1,1,1,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You must delete one element.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n","SampleTestCase":"[1,1,0,1]","ExampleTestcases":"[1,1,0,1]\n[0,1,1,1,0,1,1,0,1]\n[1,1,1]","Difficulty":"Medium","Title":"Longest Subarray of 1's After Deleting One Element","TitleSlug":"longest-subarray-of-1s-after-deleting-one-element","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"449.8K\", \"totalSubmission\": \"648.1K\", \"totalAcceptedRaw\": 449810, \"totalSubmissionRaw\": 648059, \"acRate\": \"69.4%\"}","Likes":4298,"Dislikes":95,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjU=","Name":"Array","Slug":"array"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"},{"Id":"VG9waWNUYWdOb2RlOjU1ODIx","Name":"Sliding Window","Slug":"sliding-window"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int longestSubarray(int[] nums) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int longestSubarray(int* nums, int numsSize) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int LongestSubarray(int[] nums) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestSubarray = function(nums) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function longestSubarray(nums: number[]): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestSubarray($nums) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func longestSubarray(_ nums: [Int]) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun longestSubarray(nums: IntArray): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int longestSubarray(List<int> nums) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func longestSubarray(nums []int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer[]} nums\n# @return {Integer}\ndef longest_subarray(nums)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def longestSubarray(nums: Array[Int]): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (longest-subarray nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec longest_subarray(Nums :: [integer()]) -> integer().\nlongest_subarray(Nums) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec longest_subarray(nums :: [integer]) :: integer\n  def longest_subarray(nums) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:14:11.364935021+02:00","AcRate":"69.4","TotalSubmissions":648059,"TotalAccepted":449810,"AcceptanceRate":0.6940880382804652,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n```\n\n=== DESIGN ===\nCertainly! Let's design a solution.\n\n1. **Algorithm Choice**: We'll use the sliding window (two-pointer) approach to find the longest subarray of 1's. The main idea is to adjust the window to always contain at most one zero, which allows us to remove a zero and maximize the consecutive 1's.\n\n2. **Step-by-Step Approach**:\n   - Initialize pointers `left` and variables `max_len`, `count_zeros`, and `current_ones`.\n   - Traverse the array with a `right` pointer.\n   - Maintain a count of zeros within the current window defined by `left` and `right`.\n   - If more than one zero is in the current window, move `left` forward until it's reduced to one to ensure a possible deletion.\n   - Update `max_len` with the longest segment of 1's found considering a zero removal.\n   - If the entire array consists of 1's, return the length minus one, due to the mandatory deletion.\n\n3. **Data Structures**: Simple integer counters and a list for input storage.\n\n4. **Time Complexity**: The time complexity is O(n), where n is the length of the input array. This is because each element is processed at most twice.\n\n5. **Space Complexity**: The space complexity is O(1), aside from the input array, as we use a constant amount of extra space.\n\n6. **Pseudocode**:\n   ```\n   Initialize left, max_len, current_ones, count_zeros as 0\n   Iterate over nums with the right pointer:\n       If nums[right] is 1:\n           Increment current_ones\n       Else:\n           Increment count_zeros\n       While count_zeros > 1:\n           If nums[left] is 0:\n               Decrement count_zeros\n           Else:\n               Decrement current_ones\n           Increment left\n       Update max_len with max(max_len, current_ones)\n   If count_zeros == 0:\n       Return max_len - 1\n   Return max_len\n   ```\n\nNow, let's implement this approach in Python:\n\n```python\nclass Solution:\n    def longestSubarray(self, nums: list[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom typing import List\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n```\n\n=== VERIFICATION ===\nThe provided solution correctly implements the sliding window technique to solve the problem of finding the size of the longest non-empty subarray containing only 1's after deleting one element from the given binary array. Here's the verification report:\n\n1. **Correctness**: \n   - The code correctly implements the described algorithm using the sliding window approach. It maintains the constraints of having at most one zero in the current window and updates the maximum length of contiguous 1's that can be achieved by removing one zero.\n   - The logic of handling an array with all 1's is correctly implemented by returning `max_len - 1`.\n\n2. **Edge Cases**:\n   - Handles the case when the array is full of 1's, returning `max_len - 1`.\n   - Correctly processes arrays with alternating 0's and 1's, as well as arrays with multiple zeros interspersed with segments of 1's.\n\n3. **Complexity**:\n   - The algorithm runs in O(n) time complexity, processing each element of the array at most twice (once when expanding the window and once when contracting it).\n   - It uses O(1) space aside from the input since it only requires a few integer variables to hold counters and indices.\n\n4. **Code Quality**: \n   - The solution is clean and adheres to best practices. The use of variable names such as `max_len`, `current_ones`, `count_zeros`, and `left` is clear and reflects their respective roles.\n   - The while loop inside the for loop is efficiently used to adjust the `left` pointer, maintaining the invariant of at most one zero in the window.\n\n5. **Test Cases**:\n   - The solution passes all provided test cases:\n     - `Input: [1,1,0,1]` -> Output: `3`\n     - `Input: [0,1,1,1,0,1,1,0,1]` -> Output: `5`\n     - `Input: [1,1,1]` -> Output: `2`\n   - There are sufficient checks in place to validate these outputs.\n\n6. **Potential Issues**:\n   - There are no apparent bugs or logical errors in the solution.\n   - It efficiently addresses all the requirements mentioned in the problem statement.\n\nThe solution is valid and complete, and I confirm its correctness. Here's the final Python code ready to execute:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n```\n\n","TypedCode":"\nfrom typing import List\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n","Model":"se-gpt-4o","Latency":17839009156,"SolvedAt":"2025-08-07T09:40:17.819624876+02:00","PromptTokens":4284,"OutputTokens":1608}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"1586","typed_code":"\nfrom typing import List\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        current_ones = 0\n        count_zeros = 0\n        left = 0\n        \n        for right in range(len(nums)):\n            if nums[right] == 1:\n                current_ones += 1\n            else:\n                count_zeros += 1\n                \n            while count_zeros > 1:\n                if nums[left] == 0:\n                    count_zeros -= 1\n                else:\n                    current_ones -= 1\n                left += 1\n                \n            max_len = max(max_len, current_ones)\n        \n        if count_zeros == 0:\n            return max_len - 1\n        \n        return max_len\n"},"SubmissionId":1726605064,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T10:08:53.060836199+02:00"}}}
