{"Question":{"Data":{"Question":{"questionFrontendId":"70","questionId":"70","Content":"<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n","SampleTestCase":"2","ExampleTestcases":"2\n3","Difficulty":"Easy","Title":"Climbing Stairs","TitleSlug":"climbing-stairs","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"8.2M\", \"totalAcceptedRaw\": 4415004, \"totalSubmissionRaw\": 8232433, \"acRate\": \"53.6%\"}","Likes":23495,"Dislikes":978,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjg=","Name":"Math","Slug":"math"},{"Id":"VG9waWNUYWdOb2RlOjEz","Name":"Dynamic Programming","Slug":"dynamic-programming"},{"Id":"VG9waWNUYWdOb2RlOjMz","Name":"Memoization","Slug":"memoization"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        "},{"Lang":"C","LangSlug":"c","Code":"int climbStairs(int n) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public int ClimbStairs(int n) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function climbStairs(n: number): number {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function climbStairs($n) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func climbStairs(_ n: Int) -> Int {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun climbStairs(n: Int): Int {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  int climbStairs(int n) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func climbStairs(n int) int {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {Integer} n\n# @return {Integer}\ndef climb_stairs(n)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def climbStairs(n: Int): Int = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (climb-stairs n)\n  (-> exact-integer? exact-integer?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec climb_stairs(N :: integer()) -> integer().\nclimb_stairs(N) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec climb_stairs(n :: integer) :: integer\n  def climb_stairs(n) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:10:45.340247434+02:00","AcRate":"53.6","TotalSubmissions":8232433,"TotalAccepted":4415004,"AcceptanceRate":0.5362939485811788,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/climbing-stairs/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        # Initialize the base cases\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        # Fill the dp table using the relation\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n```\n\n=== DESIGN ===\nAlgorithm Choice:\nThe problem can be solved using dynamic programming. The number of distinct ways to climb the stairs depends on the sum of the ways to climb the previous one and two steps. This is because there are two possible choices for reaching the nth step: stepping from the (n-1) step or stepping from the (n-2) step. Therefore, the problem can be reduced to a recurrence relation similar to the Fibonacci sequence: `dp[i] = dp[i - 1] + dp[i - 2]`.\n\nStep-by-Step Approach:\n1. Check if `n` is either 1 or 2, as they are base cases with known results. Return `n` directly in these cases.\n2. Initialize a list `dp` of size `n + 1` to store the number of ways to get to each step. This will use a dynamic programming approach to build the solution bottom-up.\n3. Set `dp[1]` to 1 since there's only one way to reach the first step (1 step). Set `dp[2]` to 2 as there are two ways to reach the second step (two 1 steps or one 2 step).\n4. Use a loop to fill the `dp` list from index 3 to `n`. At each index `i`, calculate `dp[i]` as the sum of `dp[i-1]` and `dp[i-2]`.\n5. After the loop completes, `dp[n]` will contain the number of distinct ways to reach the `n`th step. Return this result.\n\nData Structures:\nA list `dp` will be used to store intermediate results for dynamic programming. The length of `dp` will be `n + 1`.\n\nTime Complexity:\nThe time complexity will be O(n), as the algorithm will iterate through each step from 3 to `n` once to compute the answer.\n\nSpace Complexity:\nThe space complexity will be O(n), due to the storage of intermediate results in the `dp` list.\n\nPseudocode:\n```\nfunction climbStairs(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    \n    dp = array of size (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i from 3 to n:\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n```\n\nHere is the code that implements the above plan:\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n```\n\n=== IMPLEMENTATION ===\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n```\n\n=== VERIFICATION ===\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n```\n\n","TypedCode":"\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n","Model":"se-gpt-4o","Latency":9450648737,"SolvedAt":"2025-08-07T09:31:47.803242534+02:00","PromptTokens":3905,"OutputTokens":1001}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"70","typed_code":"\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n"},"SubmissionId":1726595592,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T09:56:06.699742787+02:00"}}}
