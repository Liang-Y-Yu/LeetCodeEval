{"Question":{"Data":{"Question":{"questionFrontendId":"76","questionId":"76","Content":"<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n","SampleTestCase":"\"ADOBECODEBANC\"\n\"ABC\"","ExampleTestcases":"\"ADOBECODEBANC\"\n\"ABC\"\n\"a\"\n\"a\"\n\"a\"\n\"aa\"","Difficulty":"Hard","Title":"Minimum Window Substring","TitleSlug":"minimum-window-substring","IsPaidOnly":false,"Stats":"{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 1831778, \"totalSubmissionRaw\": 4005529, \"acRate\": \"45.7%\"}","Likes":19233,"Dislikes":803,"FreqBar":0,"CategoryTitle":"Algorithms","TopicTags":[{"Id":"VG9waWNUYWdOb2RlOjY=","Name":"Hash Table","Slug":"hash-table"},{"Id":"VG9waWNUYWdOb2RlOjEw","Name":"String","Slug":"string"},{"Id":"VG9waWNUYWdOb2RlOjU1ODIx","Name":"Sliding Window","Slug":"sliding-window"}],"CodeSnippets":[{"Lang":"C++","LangSlug":"cpp","Code":"class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};"},{"Lang":"Java","LangSlug":"java","Code":"class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}"},{"Lang":"Python","LangSlug":"python","Code":"class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        "},{"Lang":"Python3","LangSlug":"python3","Code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        "},{"Lang":"C","LangSlug":"c","Code":"char* minWindow(char* s, char* t) {\n    \n}"},{"Lang":"C#","LangSlug":"csharp","Code":"public class Solution {\n    public string MinWindow(string s, string t) {\n        \n    }\n}"},{"Lang":"JavaScript","LangSlug":"javascript","Code":"/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};"},{"Lang":"TypeScript","LangSlug":"typescript","Code":"function minWindow(s: string, t: string): string {\n    \n};"},{"Lang":"PHP","LangSlug":"php","Code":"class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return String\n     */\n    function minWindow($s, $t) {\n        \n    }\n}"},{"Lang":"Swift","LangSlug":"swift","Code":"class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        \n    }\n}"},{"Lang":"Kotlin","LangSlug":"kotlin","Code":"class Solution {\n    fun minWindow(s: String, t: String): String {\n        \n    }\n}"},{"Lang":"Dart","LangSlug":"dart","Code":"class Solution {\n  String minWindow(String s, String t) {\n    \n  }\n}"},{"Lang":"Go","LangSlug":"golang","Code":"func minWindow(s string, t string) string {\n    \n}"},{"Lang":"Ruby","LangSlug":"ruby","Code":"# @param {String} s\n# @param {String} t\n# @return {String}\ndef min_window(s, t)\n    \nend"},{"Lang":"Scala","LangSlug":"scala","Code":"object Solution {\n    def minWindow(s: String, t: String): String = {\n        \n    }\n}"},{"Lang":"Rust","LangSlug":"rust","Code":"impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        \n    }\n}"},{"Lang":"Racket","LangSlug":"racket","Code":"(define/contract (min-window s t)\n  (-> string? string? string?)\n  )"},{"Lang":"Erlang","LangSlug":"erlang","Code":"-spec min_window(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmin_window(S, T) ->\n  ."},{"Lang":"Elixir","LangSlug":"elixir","Code":"defmodule Solution do\n  @spec min_window(s :: String.t, t :: String.t) :: String.t\n  def min_window(s, t) do\n    \n  end\nend"}],"CompanyTagStats":""}},"DownloadedAt":"2025-08-07T09:15:57.598946174+02:00","AcRate":"45.7","TotalSubmissions":4005529,"TotalAccepted":1831778,"AcceptanceRate":0.45731237996279644,"ContentFeatures":"","CodeSnippetFeatures":{"c":"","cpp":"","csharp":"","dart":"","elixir":"","erlang":"","golang":"","java":"","javascript":"","kotlin":"","php":"","python":"","python3":"","racket":"","ruby":"","rust":"","scala":"","swift":"","typescript":""},"Url":"https://leetcode.com/problems/minimum-window-substring/"},"Solutions":{"se-gpt-4o":{"Lang":"python3","Prompt":"Multi-agent approach:\n1. Analysis\n2. Design\n3. Implementation\n4. Verification","Answer":"=== ANALYSIS ===\n```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        \n        # Dictionary to keep a count of all the unique characters in t.\n        target_count = Counter(t)\n        \n        # Variables to keep track of the number of characters matched.\n        required = len(target_count)\n        \n        # Two pointers for the sliding window.\n        left, right = 0, 0\n        \n        # Dictionary to keep a count of characters in the current window.\n        window_counts = {}\n        \n        # To keep track of the characters in the current window that match the required count in target_count.\n        formed = 0\n        \n        # To keep track of the minimum length of the window found.\n        min_length = float('inf')\n        answer = (0, 0)\n        \n        while right < len(s):\n            # Add character from the right pointer to the window.\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            \n            # Check if the current character count matches the required count in target_count.\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n            \n            # Try and contract the window till it ceases to be 'desirable'.\n            while left <= right and formed == required:\n                character = s[left]\n                \n                # Save the smallest window found so far.\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n                \n                # The character at the position pointed by the `left` pointer is no longer part of the window.\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n                \n                # Move the left pointer ahead, this helps in contracting the window.\n                left += 1\n            \n            # Keep expanding the window once we have contracted the window.\n            right += 1\n        \n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n```\n\n=== DESIGN ===\n```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        # Initialize the count of characters in t\n        target_count = Counter(t)\n\n        # Number of unique characters in t to match with window\n        required = len(target_count)\n\n        # Two pointers for the window's start and end\n        left, right = 0, 0\n\n        # Counts of characters in the current window\n        window_counts = {}\n\n        # Number of characters that match the required count in target_count in current window\n        formed = 0\n\n        # Variables to store result and minimum length of the window found\n        min_length = float('inf')\n        answer = (0, 0)\n\n        while right < len(s):\n            # Add current character at right to the window_counts\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            # Check if the current character in the window matches the count in target_count\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n\n            # Try to contract the window to find the smallest window\n            while left <= right and formed == required:\n                character = s[left]\n                \n                # Save the smallest window found when it's valid\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n\n                # Remove characters from the window from the left\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n\n                # Move the left pointer forward to contract the window\n                left += 1\n\n            # Expand the window by moving right pointer forward\n            right += 1\n        \n        # Return the smallest window substring or empty string if no windows are found\n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n```\n\n=== IMPLEMENTATION ===\n```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        target_count = Counter(t)\n        required = len(target_count)\n        left, right = 0, 0\n        window_counts = {}\n        formed = 0\n        min_length = float('inf')\n        answer = (0, 0)\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n\n                left += 1\n\n            right += 1\n\n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n```\n\n=== VERIFICATION ===\nThe given solution can be verified step-by-step based on your requirements:\n\n1. **Correctness**: The solution employs a sliding window approach to find the minimum substring in `s` that contains all characters present in `t`. It correctly utilizes two pointers (`left` and `right`) to expand and contract the window, and it updates a count dictionary to keep track of character occurrences in the current window. This approach meets the requirements of the problem statement.\n\n2. **Edge Cases**: The solution considers edge cases like:\n   - When `s` or `t` is empty, it returns an empty string.\n   - When `t` has characters that are not present enough times in `s`, it returns an empty string (e.g., Example 3).\n\n3. **Complexity**: The solution runs in O(m + n) time, where m is the length of `s` and n is the length of `t`. This is achieved by processing each character at most twice (once for expanding the window and once for contracting). Space complexity is also efficient, requiring O(n) space for storing character counts related to `t` and the window.\n\n4. **Code Quality**: The code is clean, readable, and follows best practices. Variable names are intuitive (`target_count`, `window_counts`, `formed`, etc.). Comments are present to guide understanding but don't clutter the code. The logic is structured appropriately with conditions and loops.\n\n5. **Test Cases**: The solution correctly handles the provided examples:\n   - In Example 1, the output \"BANC\" is correct.\n   - In Example 2, the output \"a\" is correct.\n   - In Example 3, the output \"\" is correct.\n\n6. **Potential Issues**: No apparent bugs or logical errors exist in this implementation. The solution is optimized and does not need improvements beyond what is present.\n\nTherefore, the solution is verified to be correct and meets all the outlined requirements.\n\nHere is the final code snippet for execution:\n\n```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        target_count = Counter(t)\n        required = len(target_count)\n        left, right = 0, 0\n        window_counts = {}\n        formed = 0\n        min_length = float('inf')\n        answer = (0, 0)\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n                left += 1\n                \n            right += 1\n\n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n```\n\nThis code will function correctly as-is and solve the given problem statement efficiently.\n\n","TypedCode":"\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        target_count = Counter(t)\n        required = len(target_count)\n        left, right = 0, 0\n        window_counts = {}\n        formed = 0\n        min_length = float('inf')\n        answer = (0, 0)\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n\n                left += 1\n\n            right += 1\n\n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n","Model":"se-gpt-4o","Latency":21324654749,"SolvedAt":"2025-08-07T09:44:21.080843971+02:00","PromptTokens":5077,"OutputTokens":1881}},"Submissions":{"se-gpt-4o":{"SubmitRequest":{"lang":"python3","question_id":"76","typed_code":"\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        target_count = Counter(t)\n        required = len(target_count)\n        left, right = 0, 0\n        window_counts = {}\n        formed = 0\n        min_length = float('inf')\n        answer = (0, 0)\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in target_count and window_counts[character] == target_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    answer = (left, right)\n\n                window_counts[character] -= 1\n                if character in target_count and window_counts[character] < target_count[character]:\n                    formed -= 1\n\n                left += 1\n\n            right += 1\n\n        return \"\" if min_length == float('inf') else s[answer[0]:answer[1] + 1]\n"},"SubmissionId":1726609118,"CheckResponse":{"status_code":10,"status_msg":"Accepted","Finished":true,"State":"SUCCESS"},"SubmittedAt":"2025-08-07T10:14:19.406762406+02:00"}}}
